# Разработка Antiopa

## Переключение уже установленной antiopa на другую версию

```
kubectl -n antiopa test edit deploy/antiopa
```

Меняем версию образа `registry.flant.com/sys/antiopa:stable`, например, на `registry.flant.com/sys/antiopa:master`.

## Структура директорий модуля

```
modules
├── test1
│   ├── Chart.yaml
│   ├── hooks
│   │   ├── after-helm
│   │   │   └── onexit.sh
│   │   └── before-helm
│   │       ├── 000_print_values.sh
│   │       └── 001_abcd.sh
│   ├── templates
│   │   ├── 000_namespace.yaml
│   │   └── mysql.yaml
│   ├── initial_values
│   └── values.yaml
...
```

Каждый модуль это директория в директории `/modules`. Модуль это чарт для helm.

### Helm

* Helm upgrade --install вызывается при наличии файла `/modules/<module-name>/Chart.yaml`.
* Для каждого модуля создается релиз в helm с именем модуля. Т.к. это отдельный instance tiller.
* Чтобы просмотреть релизы в helm: TILLER_NAMESPACE=antiopa helm list.
* При первом выкате релиза в helm, если в кластере уже есть ресурсы, описанные в релизе – выкат в helm упадет. При этом будет создан релиз в состоянии FAILED. При повторном запуске (будет вызван автоматом через 30 сек) ошибка с уже существующим ресурсом проявляться не будет.

### Хуки

* Хук — это произвольный исполняемый файл.
* Хуки модулей
    * Before-helm хуки добавляются в директрию `/modules/<module-name>/hooks/before-helm/`
    * After-helm хуки добавляются в директрию `/modules/<module-name>/hooks/after-helm/`
* Глобальные хуки
    * On-kube-node-change хуки добавляются в директорию `/global-hooks/on-kube-node-change/`
        * Вызывается перед запуском всех модулей
        * Вызывается при изменении списка узлов
            * добавление/удаление узла
            * изменение узла
                * имя узла, поля spec, annotations, labels
* Хуки в каждой директории вызываются в алфавитном порядке.
* Хуки могут генерировать values для helm.
    * На данный момент поддерживается только генерация values для глобального хука on-kube-node-change
    * В хуке доступна переменная окружения RETURN_VALUES_PATH, в которой записан путь к пустому файлу (гарантируется, что файл существует на момент запуска хука). Содержимое файла после запуска хука будет воспринято как yaml.
    * Все values, которые возвращают хуки объединяются в единый в том порядке, в котором эти хуки вызывались.
* В хуках доступно использование утилиты kubectl или подключение к kubernetes-api через in-cluster connection (работает из коробки в любом языке).

### Values для helm

Есть 6 источников values.yaml для helm:

* Файл `/modules/values.yaml` — глобальные для всех модулей, для всех инсталляций.
* Values, которые генерируют глобальные хуки (возвращаются через файл $RETURN_VALUES_PATH).
* Файл `/modules/<module-name>/values.yaml` — для фодуля module-name, для всех инсталляций.
* Файл `/modules/<module-name>/initial_values` — для модуля module-name, для всех инсталляций, скрипт-генератор values (должен вернуть YAML в stdout).
* ConfigMap-antiopa yaml-строка в `data[values]` — глобальные для всех модулей, для данной инсталляции.
* ConfigMap-antiopa yaml-строка в `data[<module-name>-values]` — для модуля module-name, для данной инсталляции.

Все merge-ться в единый values.yaml в указанном порядке.

Результат initial_values дописывается в ConfigMap связанного модуля и "запоминается". Например, таким образом можно сгенерить пароль. Пароль при первом вызове initial_values запишется в ConfigMap и больше не будет перезаписан. Если после этого поменять этот пароль руками в ConfigMap — то все будет работать как и ожидается, т.к. значения из ConfigMap имеют приоритет.

Схема устройства merge-значений: https://docs.google.com/a/flant.com/drawings/d/1WjE9MtLjWQTul4mURE-TSrAXpLfEbpC22-zWIqc5RxI/edit?usp=sharing

Изменение ConfigMap-antiopa на данный момент не вызывает перезапуск модулей, поэтому требуется убить pod antiopa, чтобы инициировать перезапуск.

Пример манифеста:

```
apiVersion: v1
kind: ConfigMap
metadata:
name: antiopa
data:
  values: |
    go:
    - 2
  test1-values: |
    go:
    - 4
    - 6
    - 7
  test2-values: |
    key: value
```

### Обновление кода модулей
При коммите изменений модулей или самой antiopa в git-репо происходит сборка нового docker образа.

Уже запущенная версия antiopa периодически проверяет наличие нового образа в docker-registry (новый id для того же имени образа, т.е. всегда по логике "latest"). Если новый образ появился – запущенная версия antiopa изменяет manifest своего deployment и завершает работу, обновление до последней версии образа из registry делает уже сам deployment.

При каждом новом запуске/перезапуске antiopa перезапускает все модули (в алфавитном порядке).

### Как запускаются модули

* Модули запускаются при каждом старте программы/пода
    * Чтобы инициировать рестарт – убиваем под
    * Модули между собой запускаются в алфавитном порядке
    * Хуки модуля из одной директории запускаются в алфавитном порядке.
* Если во время работы модуля произошла ошибка, то он попадает в очередь на рестарт. Каждые 30 секунд перезапускается один модуль из этой очереди и если он отработает успешно, то больше не перезапускается, если опять фейл – попадает в конец очереди.
* Если во время работы глобального хука произошла ошибка, то перезапуск хуков и всех модулей откладывается на 30 секунд.

### Отключение модулей

Модули, которые указаны в ключе disable-modules в ConfigMap antiopa, будут выключены. Перечисляются через запятую, можно использовать glob'ы.

Пример:

```
apiVersion: v1
kind: ConfigMap
metadata:
name: antiopa
data:
  disable-modules: test*, kube-dashboard
...
```

## Как проверить мою версию

CI настроен так, что каждый бранч всегда собирается в образ и доступен по адресу `registry.flant.com/sys/antiopa/dev:<BRANCH>`. Все что нужно, чтобы проверить версию из еще не принятого бранча — изменить образ в deployment'е antiopa.


## Процесс релиза

Когда в master набралось достаточно изменений, чтобы сделать релиз, делается следующее:
1. Проверяем изменения, выкатив master
    - В последнем pipeline master'а нажимается кнопка `master` (в колонке `deploy`), при этом dapp делает push образа, который уже есть в `antiopa/dev:master`, в `antiopa:master` и все инсталляции antiopa, подключенные к версии master, обновляются.
    - Проверяем логи на достаточном наборе кластеров подключенных к версии `master`, чтобы быть уверенным, что все хорошо. Если есть проблемы — заводим issue, исправляем в MR, принимаем эти MR и снова выкатываем версию `master`.
2. Создаем релиз
    - Определяем `название релиза` в формате `YYYY-MM-DD.N` (где N, это номер релиза за день, начиная с 1).
    - Переименовываем Milestone'ы:
        - `current` переименовывать в `<название релиза>`,
        - создаем новый `current`, в который передвигаем все оставшиеся задачи и MR'ы,
        - если задач и MR'ов нет, то просто `next` переименовываем в `current`, `after-next` в `next` и создаем новый, пустой, `after-next`.
    - Составляем подробное описание изменений, предназначенное, в первую очередь, для DevOps команд (чтобы они могли четко понимат, какие изменения есть в релизе).
    - Ставим git tag `<название релиза>` на ветку master, в описание тега размещаем подробно описание релиза. CI настроен так, что при этом dapp сделает push образа `antiopa:<tag>`.
3. Выкатываем релиз сначала на `ea`, затем на `stable`
    - Уведомляем DevOps команды в соответсвтующем канале в slack.
    - Для выката в pipeline tag'а есть соответствующие кнопки `ea` и `stable`. При нажатии на эти кнопки dapp делает push образа, который уже есть в `antiopa:<tag>`, в `antiopa:ea` или `antiopa:stable` соответственно.
    - Как именно проверять корерктность выката на `ea` и сколько выжидать до выката на `stable` — зависит от изменений, которые попали в релиз.

## Соглашение об именовании

* Для всего, что написано на Shell — мы используем [Shell Style Guid](https://google.github.io/styleguide/shell.xml).
* Для идентификаторов в Kubernetes мы используем [соответствующий стандарт](https://github.com/kubernetes/community/blob/master/contributors/design-proposals/architecture/identifiers.md).
* Для Helm Values мы используем camelCase как в Kubernetes, согласно [официальным рекомендациям](https://github.com/kubernetes/helm/blob/master/docs/chart_best_practices/values.md#naming-conventions). Исключение: проброс целиком части values в Kubernetes (например как в случае с nodeSelector).
* Для названий Helm Chart'ов мы используем маленькие буквы и дефисы, согласно [официальные рекомендии](https://github.com/kubernetes/helm/blob/master/docs/chart_best_practices/conventions.md#chart-names).
* Название модуля должно всегда соответствовать названию Helm Chart'а.
* Для названий образов модулей (тех, которые лежат в `modules/*/images/*`) мы используем маленькие буквы и дефисы (чтобы ссылка на image, которая так же содержит имя модуля, не была в разных стилях).
* Переменные в Go-шаблонах в Helm Chat'ах мы именуем camelCase'ом, как это принято в Go.
* На структуру Helm Chart'ов у нас пока нет никаких соглашений, так что каждый как захочет!
* Если одно и тоже название нам нужно использовать в разных местах, например в ConfigMap (идентификатор Kubernetes), Helm Values, Shell и Go — мы используем в каждому случае свое соглашение об именовании, соответственно: `use-proxy-protocol`, `useProxyProtocol`, `use_proxy_protocol`. Согласно этому правилу название модуля и название имени образа модуля (которые содержат дефис), когда они используются в Helm Values, становятся camelCase.
* Если на то нет других причин, в названиях фалов, в качестве разделителей, мы старемся использовать нижние подчеркивания и точки, а не дефисы.
* При именовании объектов в kubernetes мы придерживаемся следующей статегии:
    * namespace называем так-же как модуль, но с приставкой `kube-` (символизируя этим, что это НЕ пользовательское приложение, а "системный компонент"), например, модуль `prometheus`, а namespace — `kube-prometheus`.
    * все глобальные объекты и объекты, которые мы размещаем за пределами наших namespace'ов, называем так-же как namespace или используем название namespace'а в качестве префикса, например: `clusterrole/kube-prometheus:node-exporter`, `service/kube-prometheus-discovery-of-kube-controller-manager` (в namespace `kube-system`), `daemonset/kube-prometheus-kube-control-plane-proxy` (в namespace `kube-system`).

## Значения в Helm Values

* Для bool значений используем всегда настоящий bool, а не строку. И используем слова true или false, а не любые другие.
* Для констант используем соглашение, как в Kubernetes — с большой буквы, CamelCase. Например: `LoadBalancer`, `ClusterIP`.

## Обязательные лейблы antiopa

У всех ресурсов, которые **создаются и управляются antiopa**, должны стоять два лейбла:
* `heritage: antiopa`
* `module: <имя модуля>`

**Внимание!!!* Это не означает, что эти лейблы нужно ставить на pod'ы, создаваемые другими контроллерами и пр. Нет. Указанные лейблы необходимо ставить только на первичные ресурсы, находящиеся под управлением antiopa.

## Рекомендации по использованию лейблов

Рекомендуется использовать лейблы `app` и `component`.

## Содержимое Chart.yaml

Там должно быть только название и версия `0.0.1`.

## Values для модулей

Values для конкретного модуля объявляются в глобальном ключе с именем модуля (сконвертированным в camelCase).

```
myModule:
  mysql:
    rootPassword: password
    database: main
    user:
      name: user
      password: password
```

Внутри ConfigMap antiopa'ы данный пример будет выглядеть так:

```
apiVersion: v1
kind: ConfigMap
metadata:
  name: antiopa
data:
  my-module-values: |
    myModule:
      mysql:
        rootPassword: password
        database: main
        user:
          name: user
          password: password
...
```

