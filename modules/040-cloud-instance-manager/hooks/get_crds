#!/bin/bash

source /deckhouse/shell_lib.sh

function __config__() {
  if [ -n "${D8_IS_TESTS_ENVIRONMENT-}" ]; then
    instance_class_kind=D8TestInstanceClass
  else
    instance_class_kind="$(kubectl get -n kube-system secret d8-node-manager-cloud-provider -o json 2>/dev/null | jq -r '.data.instanceClassKind' | base64 -d || true)"
    if [ -n "$instance_class_kind" ]; then
      echo "$instance_class_kind" > /tmp/node-manager-instance-class-kind
    fi
  fi

  cat << EOF
    configVersion: v1
    kubernetes:
    - name: ngs
      queue: /modules/$(module::name::kebab_case)
      includeSnapshotsFrom: [ngs,$([ -n "$instance_class_kind" ] && echo -n "ics,")cloud_provider_secrets,machine_deployments]
      apiVersion: deckhouse.io/v1alpha1
      kind: NodeGroup
      jqFilter: |
        {
          "name": .metadata.name,
          "spec": (
            .spec
            +
            {"manualRolloutID": (.metadata.annotations."manual-rollout-id" // "")}
          )
        }
    $(
    if [ -n "$instance_class_kind" ]; then
      echo "
    - name: ics
      queue: /modules/$(module::name::kebab_case)
      includeSnapshotsFrom: [ngs,ics,cloud_provider_secrets,machine_deployments]
      apiVersion: deckhouse.io/v1alpha1
      kind: ${instance_class_kind}
      jqFilter: |
        {
          "name": .metadata.name,
          "spec": .spec,
          "bundle": .spec.bashible.bundle
        }
"
    fi
    )
    - name: cloud_provider_secrets
      queue: /modules/$(module::name::kebab_case)
      includeSnapshotsFrom: [ngs,$([ -n "$instance_class_kind" ] && echo -n "ics,")cloud_provider_secrets,machine_deployments]
      apiVersion: v1
      kind: Secret
      namespace:
        nameSelector:
          matchNames: [kube-system]
      nameSelector:
        matchNames: [d8-node-manager-cloud-provider]
      jqFilter: |
        (.data | [to_entries[] | (.value |= (. | @base64d))] | from_entries)
        +
        (.data | [to_entries[] | try(.value |= (. | @base64d | fromjson))] | from_entries)
        | {"zones": .zones}
    - name: machine_deployments
      apiVersion: machine.sapcloud.io/v1alpha1
      kind: MachineDeployment
      includeSnapshotsFrom: [ngs,$([ -n "$instance_class_kind" ] && echo -n "ics,")cloud_provider_secrets,machine_deployments]
      namespace:
        nameSelector:
          matchNames: [d8-cloud-instance-manager]
      labelSelector:
        matchExpressions:
        - key: heritage
          operator: In
          values: ["deckhouse"]
      jqFilter: |
        {
          "name": .metadata.name,
          "zone": .metadata.annotations.zone
        }
EOF
}

function __on_kubernetes::cloud_provider_secrets() {
  if [ ! -v D8_IS_TESTS_ENVIRONMENT ] && [ "$(context::jq -r '.snapshots.cloud_provider_secrets | length')" -gt "0" ]; then
    instance_class_kind="$(cat /tmp/node-manager-instance-class-kind 2>/dev/null || true)"
    if [ "$instance_class_kind" != "$(context::get snapshots.cloud_provider_secrets.0.object.data.instanceClassKind | base64 -d)" ]; then
      kill 1
    fi
  fi
}

# $1 — CIG name
# $2 — error message or empty string
function _set_ng_error_status() {
  if [ -n "$2" ]; then
    status_patch="$(jq -n --arg msg "$2" '{"error": $msg}')"
  else
    status_patch="$(jq -n '{"error": null}')"
  fi
  kubernetes::status::patch "" "deckhouse.io/v1alpha1" "nodegroups" "${1}" "${status_patch}"
}

function __main__() {
  if [ -n "${D8_IS_TESTS_ENVIRONMENT-}" ]; then
    instance_class_kind=D8TestInstanceClass
  else
    instance_class_kind="$(cat /tmp/node-manager-instance-class-kind 2>/dev/null || true)"
  fi

  cluster_version="$(values::get global.discovery.clusterVersion)"
  default_zones=$(context::jq -r '.snapshots |
  (if .machine_deployments[0] | has("object") then [.machine_deployments[].object.metadata.annotations.zone | select(length > 0)] else [] end) as $a |
  (if .cloud_provider_secrets[0] | has("object") then .cloud_provider_secrets[].filterResult.zones else [] end) as $b |
  $a + $b | unique')

  final_node_groups="[]"
  for i in $(context::jq -r '.snapshots.ngs | keys[]'); do
    ng_name="$(context::get snapshots.ngs.$i.filterResult.name)"
    ng="$(context::get snapshots.ngs.$i.filterResult.spec)"
    ng="$(jq \
            --arg name "${ng_name}" \
            --arg default_kubernetes_version "$(semver get major $cluster_version).$(semver get minor $cluster_version)" \
            '.name = $name | .kubernetesVersion //= $default_kubernetes_version' <<< "$ng")"

    # If cloud provider exists
    if [ -n "$instance_class_kind" ] && [ "$(context::jq '.snapshots.ics | length')" -gt "0" ]; then
      instance_classes="$(context::jq -r '
        [.snapshots.ics[]] | reduce .[] as $i ({}; . + {($i.filterResult.name): $i.filterResult.spec})
      ')"

      # check #1 — is .spec.cloudInstances.classReference.kind allowed in our cluster
      ng_instance_class_kind=$(jq -r '.cloudInstances.classReference.kind' <<< "$ng")
      if [[ "$ng_instance_class_kind" != "$instance_class_kind" ]] ; then
        error_message="Wrong classReference: Kind $ng_instance_class_kind is not allowed, the only allowed kind is $instance_class_kind."

        if
          values::has cloudInstanceManager.internal.nodeGroups && \
          earlier_stored_ng="$(values::jq -er --arg ng_name "${ng_name}" '.cloudInstanceManager.internal.nodeGroups[] | select(.name == $ng_name)')"
        then
          final_node_groups="$(jq --argjson ng "$earlier_stored_ng" '. + [$ng]' <<< $final_node_groups)"
          error_message="$error_message Earlier stored version of NG is in use now!"
        fi

        >&2 echo "ERROR: Bad NodeGroup $ng_name: $error_message"
        _set_ng_error_status "${ng_name}" "${error_message}"
        continue
      fi

      # check #2 — is .spec.cloudInstances.classReference valid
      ng_instance_class_name=$(jq -r '.cloudInstances.classReference.name' <<< "$ng")
      if jq -e '. | has("'$ng_instance_class_name'") | not' <<< "$instance_classes" >/dev/null 2>&1; then
        error_message="Wrong classReference: There is no valid instance class $ng_instance_class_name of type $ng_instance_class_kind."

        if
          values::has cloudInstanceManager.internal.nodeGroups && \
          earlier_stored_ng="$(values::jq -er --arg ng_name "${ng_name}" '.cloudInstanceManager.internal.nodeGroups[] | select(.name == $ng_name)')"
        then
          final_node_groups="$(jq --argjson ng "$earlier_stored_ng" '. + [$ng]' <<< $final_node_groups)"
          error_message="$error_message Earlier stored version of NG is in use now!"
        fi

        >&2 echo "ERROR: Bad NodeGroup $ng_name: $error_message"
        _set_ng_error_status "${ng_name}" "${error_message}"
        continue
      fi

      ng_instance_class="$(jq --arg name $ng_instance_class_name '.[$name]' <<< "$instance_classes")"
      ng="$(jq \
        --argjson instance_class "${ng_instance_class}" \
        --argjson default_zones "${default_zones}" \
        '.instanceClass = $instance_class | .cloudInstances.zones //= $default_zones' <<< "$ng")"
    fi

    if [ "$default_zones" != "[]" ]; then
      ng="$(jq --argjson default_zones "$default_zones" '.cloudInstances.zones //= $default_zones' <<< "$ng")"
    fi

    _set_ng_error_status "${ng_name}" ""
    final_node_groups="$(jq --argjson ng "$ng" '. + [$ng]' <<< $final_node_groups)"
  done

  values::set cloudInstanceManager.internal.nodeGroups "$final_node_groups"
}

hook::run "$@"
