#!/bin/bash

source /deckhouse/shell_lib.sh

function __config__() {
  cat << EOF
    configVersion: v1
    kubernetes:
    - name: cigs
      queue: /modules/cloud_instance_manager
      apiVersion: deckhouse.io/v1alpha1
      kind: CloudInstanceGroup
      jqFilter: |
        {
          "isReadyToChaos": (.status.desired > 1 and .status.desired == .status.ready),
          "spec": .spec,
          "name": .metadata.name
        }
    - name: nodes
      queue: /modules/cloud_instance_manager
      apiVersion: v1
      kind: Node
      labelSelector:
        matchExpressions:
        - key: cloud-instance-manager.deckhouse.io/cloud-instance-group
          operator: Exists
      jqFilter: |
        {
          "cloudInstanceGroup": (.metadata.labels."cloud-instance-manager.deckhouse.io/cloud-instance-group" // null),
          "name": .metadata.name
        }
    - name: machines
      queue: /modules/cloud_instance_manager
      apiVersion: machine.sapcloud.io/v1alpha1
      kind: Machine
      labelSelector:
        matchExpressions:
        - key: cloud-instance-manager.deckhouse.io/cloud-instance-group
          operator: Exists
      jqFilter: |
        {
          "isMonkeyVictim": (.metadata.labels | has("cloud-instance-manager.deckhouse.io/chaos-monkey-victim")),
          "node": .metadata.labels.node,
          "name": .metadata.name
        }
    schedule:
    - name: monkey
      queue: /modules/cloud_instance_manager/chaos_monkey
      crontab: "* * * * *"
      includeSnapshotsFrom: [cigs,nodes,machines]
EOF
}

function __on_kubernetes::cigs() {
  return 0
}

function __on_kubernetes::nodes() {
  return 0
}

function __on_kubernetes::machines() {
  return 0
}

function __on_schedule::monkey() {
  # for testing environment
  if [ -n "${RANDOM_SEED-}" ]; then
    RANDOM="${RANDOM_SEED}"
    tmp=$(mktemp)
    echo $RANDOM_SEED > $tmp
    export SHUF_RANDOM_SOURCE="--random-source=$tmp"
  else
    export SHUF_RANDOM_SOURCE=""
  fi

  instance_group_names="$(context::jq -r '.snapshots.cigs[] | select(.filterResult.isReadyToChaos) | .object.metadata.name')"
  for ig_name in $instance_group_names ; do
    if context::jq -e '[.snapshots.machines[] | select(.filterResult.isMonkeyVictim)] | any'; then
      # If there is node in deleting state then do nothing
      continue
    fi

    ig_spec="$(context::jq -r --arg ig_name "$ig_name" '.snapshots.cigs[] | select(.filterResult.name == $ig_name) | .filterResult.spec')"
    ig_chaos_mode=$(jq -r '.chaos.mode // "DrainAndDelete"' <<< "$ig_spec")
    ig_chaos_period_seconds=$(jq -r '.chaos.period // "6h"' <<< "$ig_spec" | deckhouse-controller helper unit convert --mode duration)

    run=$(( RANDOM % (ig_chaos_period_seconds / 60) ))
    if [[ "$run" == "0" ]]; then
      victim_node="$(context::jq -r --arg ig_name "${ig_name}" '.snapshots.nodes[] | select(.filterResult.cloudInstanceGroup == $ig_name) | .filterResult.name' | shuf -n 1 $SHUF_RANDOM_SOURCE)"
      victim_machine="$(context::jq -r --arg node "${victim_node}" '.snapshots.machines[] | select(.filterResult.node == $node) | .filterResult.name' | shuf -n 1 $SHUF_RANDOM_SOURCE)"
      if [[ "$ig_chaos_mode" == "DrainAndDelete" ]] ; then
        kubernetes::patch_jq "d8-cloud-instance-manager" "machine/$victim_machine" '.metadata.labels."cloud-instance-manager.deckhouse.io/chaos-monkey-victim" = ""'
        kubernetes::delete "d8-cloud-instance-manager" "machine/$victim_machine"
      fi
    fi
  done
}

hook::run "$@"
