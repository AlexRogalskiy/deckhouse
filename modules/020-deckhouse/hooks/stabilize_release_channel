#!/bin/bash

source /deckhouse/shell_lib.sh

function __config__() {
  cat << EOF
    configVersion: v1
    schedule:
    - name: stabilize_release_channel
      queue: /modules/$(module::name::kebab_case)/stabilize_release_channel
      crontab: "*/10 * * * *"
EOF
}

function __main__() {
  declare -A release_channels_order; release_channels_order=( ["Alpha"]=0 ["Beta"]=1 ["EarlyAccess"]=2 ["Stable"]=3 ["RockSolid"]=4 )
  declare -A release_channels_tags; release_channels_tags=( ["alpha"]="Alpha" ["beta"]="Beta" ["early-access"]="EarlyAccess" ["stable"]="Stable" ["rock-solid"]="RockSolid" )
  declare -A orders_to_tags; orders_to_tags=( [0]="alpha" [1]="beta" [2]="early-access" [3]="stable" [4]="rock-solid" )

  # Get desired release channel
  desired_release_channel=$(values::get deckhouse.releaseChannel)
  if [[ "$desired_release_channel" == "null" ]]; then
    return 0
  fi

  if [[ ! ${release_channels_order[$desired_release_channel]+_} ]]; then
    >&2 echo "ERROR: Desired release channel does not exist. Check 'deckhouse.releaseChannel' section of deckhouse configmap."
    return 1
  fi

  # Get current release channel
  current_release_channel_tag=$(kubectl -n d8-system get deploy/deckhouse -o json | jq -r '.spec.template.spec.containers[0].image' | awk -F ":" '{ print $2 }')
  if [[ ! ${release_channels_tags[$current_release_channel_tag]+_} ]]; then
    # Current image tag does not match any release channel, skip stabilization
    return 0
  fi
  current_release_channel=${release_channels_tags[$current_release_channel_tag]}

  desired_order=${release_channels_order[$desired_release_channel]}
  current_order=${release_channels_order[$current_release_channel]}

  # Nothing to do, if we already on desired channel
  if [[ "$desired_order" -eq "$current_order" ]]; then
    return 0
  fi

  registry=$(values::get global.modulesImages.registry)

  credentials=$(cat /etc/registrysecret/.dockerconfigjson | jq -r '.auths | to_entries[] | .value | "--username=" + .username + " --password=" + .password')
  current_digest=$(reg digest $credentials "${registry}:${current_release_channel_tag}")

  result_tag=$current_release_channel_tag
  index=${release_channels_order[${release_channels_tags[$current_release_channel_tag]}]}

  if [[ "$desired_order" -lt "$current_order" ]]; then
    # Searching for first upgrade (new digest) docker image tag
    while [[ "$index" -ne 0 ]]; do
      index=$(("$index" - 1))
      candidate_tag=${orders_to_tags[$index]}
      candidate_digest=$(reg digest $credentials "${registry}:${candidate_tag}")
      if [[ "$current_digest" != "$candidate_digest" ]] || [[ "$index" == "$desired_order" ]]; then
        result_tag=$candidate_tag
        break
      fi
    done
  else
    # If current release channel docker image digest equals to next order release channel docker image digest, we can switch to it
    while [[ "$index" -ne 4 ]]; do
      index=$(("$index" + 1))
      candidate_tag=${orders_to_tags[$index]}
      candidate_digest=$(reg digest $credentials "${registry}:${candidate_tag}")
      if [[ "$current_digest" != "$candidate_digest" ]]; then
        break
      fi
      result_tag=$candidate_tag
    done
  fi
  if [[ "$result_tag" != "$current_release_channel_tag" ]]; then
    kubernetes::patch_jq d8-system deployment/deckhouse ".spec.template.spec.containers[0].image = \"${registry}:${result_tag}\""
  fi
}

hook::run "$@"
