---
title: "Модуль deckhouse"
---

Модуль не устанавливает, но настраивает **Deckhouse**, а также создает Deployment с сайтом документации текущей версии.   

По умолчанию документация доступна по адресу 'deckhouse.', согласно значению глобального параметра [publicDomainTemplate]({{ site.baseurl }}/#параметры).

Конфигурация
------------

### Параметры

* `logLevel` — уровень логирования Deckhouse: 
    * Возможные варианты: `Debug`, `Info`, `Error`; 
    * По умолчанию `Info`.
* `bundle` — вариант поставки Deckhouse. Определяет включенные по умолчанию модули. 
    * Возможные варианты:
        * `Default` — включает рекомендованный набор модулей для работы кластера: мониторинга, контроля авторизации, организации работы сети и других потребностей. С актуальным списком можно ознакомиться [здесь](modules/values-default.yaml).
        * `Minimal` — минимально возможная поставка, которая включает единственный модуль (этот).
        * `Managed` - поставка для managed кластеров от облачных провайдеров, например Google Kubernetes Engine (GKE)
    * По умолчанию `Default`.
* `releaseChannel` — канал обновлений Deckhouse.
    * Возможные варианты в порядке возрастания стабильности обновлений: `Alpha`, `Beta`, `EarlyAccess`, `Stable`, `RockSolid`. 
* `ingressClass` — класс ingress-контроллера сервера документации.
    * Опциональный параметр, по-умолчанию используется глобальное значение `modules.ingressClass`.
* `auth` — опции, связанные с аутентификацией и авторизацией доступа на сервер документации:
    * `externalAuthentication` - параметры для подключения внешней аутентификации (используется механизм Nginx Ingress [external-auth](https://kubernetes.github.io/ingress-nginx/examples/auth/external-auth/), работающей на основе модуля Nginx [auth_request](http://nginx.org/en/docs/http/ngx_http_auth_request_module.html).
         * `authURL` - URL сервиса аутентификации. Если пользователь прошел аутентификацию, сервис должен возвращать код ответа HTTP 200.
         * `authSignInURL` - URL, куда будет перенаправлен пользователь для прохождения аутентификации (если сервис аутентификации вернул код ответа HTTP отличный от 200).
    * `password` — пароль для http-авторизации для пользователя `admin` (генерируется автоматически, но можно менять)
         * Используется если не включен параметр `externalAuthentication`.
* `https` — выбираем, какой типа сертификата использовать для HTTP-сервера документации.
    * При использовании этого параметра полностью переопределяются глобальные настройки `global.modules.https`.
    * `mode` — режим работы HTTPS:
        * `Disabled` — в данном режиме сервер документации будет работать только по HTTP;
        * `CertManager` — сервер документации будет работать по HTTPS и заказывать сертификат с помощью clusterIssuer заданного в параметре `certManager.clusterIssuerName`;
        * `CustomCertificate` — сервер документации будет работать по HTTPS используя сертификат из namespace `d8-system`;
        * `OnlyInURI` — сервер документации будет работать по HTTP (подразумевая, что перед ним стоит внешний HTTPS-балансер, который терминирует HTTPS) и все ссылки в `user-authn` будут генерироваться с HTTPS-схемой.
    * `certManager`
      * `clusterIssuerName` — указываем, какой ClusterIssuer использовать для сервера документации (в данный момент доступны `letsencrypt`, `letsencrypt-staging`, `selfsigned`, но вы можете определить свои).
        * По-умолчанию `letsencrypt`.
    * `customCertificate`
      * `secretName` - указываем имя secret'а в namespace `d8-system`, который будет использоваться для сервера документации (данный секрет должен быть в формате [kubernetes.io/tls](https://kubernetes.github.io/ingress-nginx/user-guide/tls/#tls-secrets)).
        * По-умолчанию `false`.
* `nodeSelector` — как в Kubernetes в `spec.nodeSelector` у pod'ов.
    * Если ничего не указано — будет [использоваться автоматика]({{ site.baseurl }}/#выделение-узлов-под-определенный-вид-нагрузки).
    * Можно указать `false`, чтобы не добавлять никакой nodeSelector.
* `tolerations` — как в Kubernetes в `spec.tolerations` у pod'ов.
    * Если ничего не указано — будет [использоваться автоматика]({{ site.baseurl }}/#выделение-узлов-под-определенный-вид-нагрузки).
    * Можно указать `false`, чтобы не добавлять никакие toleration'ы.

### Пример конфига

```yaml
deckhouse: |
  logLevel: Debug
  bundle: Minimal
  releaseChannel: RockSolid
```

Автоматическая стабилизация релизного канала
--------------------------------------------
При указании в конфигурации параметра `releaseChannel` Deckhouse сам переключит image на соответствующий тег Docker-образа. Дополнительных действий со стороны пользователя не требуется.

**Внимание:** переключение не происходит мгновенно и зависит от обновлений Deckhouse.

<details>
  <summary>Логика работы:
  </summary><br>

Каждые 10 минут будет запускаться скрипт стабилизации канала обновлений:
* Если указанный канал обновлений соответствует тегу Docker-образа Deckhouse — ничего не произойдет;
* При смене канала обновлений на более стабильный (например с Alpha на EarlyAccess) будет произведен плавный переход.
  
  Сначала мы проверяем равенство [digest](https://success.docker.com/article/images-tagging-vs-digests) для тегов Docker-образов, соответствующих текущему каналу обновлений и ближайшему к нему более стабильному (в нашем примере это каналы Alpha и Beta).
  
  Если digest'ы равны, будет проверен следующий по очереди тег (в нашем примере соответствующий каналу обновлений EarlyAccess).
  
  В итоге Deckhouse будет переключен на более стабильный канал обновлений c digest'ом, равным текущему.

* Если указан менее стабильный канал обновлений, чем тот, который соответствует текущему тегу Docker-образа Deckhouse — мы сверим digest'ы соответствующие образам Docker для текущего канала обновлений и следующего менее стабильного (например хотим перейти на Alpha, и сейчас мы на EarlyAccess, — сравнивать будем EarlyAccess и Beta).

  Если digest не равны, Deckhouse будет переключен на следующий канал обновлений (в нашем случае на Beta). Это необходимо, чтобы не пропустить важные миграции, которые мы проводим при обновлении Deckhouse.
  
  Если digest равны, будет проверен следующий по убыванию стабильности канал обновлений (в нашем случае Alpha).
  
  Когда проверка дойдет до желаемого канала обновлений (в примере — Alpha), переключение Deckhouse произойдет независимо от равенства digest.

В итоге, постоянный запуск скрипта стабилизации рано или поздно приведет Deckhouse к состоянию, при котором тег его Docker-образа будет соответствовать заданному каналу обновлений.

</details>
