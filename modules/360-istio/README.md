Модуль istio (v1.2.2)
=====================

Модуль устанавливает [istio](https://istio.io/).

Конфигурация
------------

### Параметры
* `tlsMode` — режим прозрачного шифрования трафика между pod'ами ([Mutual TLS](https://istio.io/docs/tasks/security/mtls-migration/)).
    * Возможные значения:
        * `"Off"` — pod'ы не будут шифровать исходящие запросы и не будут отклонять реквесты, которые не зашифрованы. (Hint: пишите "Off" только в кавычках).
        * `"MutualPermissive"` — pod'ы будут шифровать исходящие запросы, но не будут отклонять реквесты, которые не зашифрованы. Режим полезен в переходный момент при переезде на mTLS.
        * `"Mutual"` — pod'ы будут шифровать исходящие запросы и строго будут принимать только зашифрованные реквесты.
    * При включении режима `"Mutual"` перестанут работать классические HTTP-пробы, так как kubelet ничего про mTLS не знает. Но в sidecar c istio предусмотрен специальный порт, куда можно эти пробы направить. Sidecar-injector, который добавляет sidecar-ы в поды, заодно перенаправит ваши пробы на специальный порт.
    * По-умолчанию `"Off"`.
    * Управлять режимом mTLS можно локально с помощью ресурсов [Policy](/modules/360-istio/docs/USAGE.md#policy) и [DestinationRule](/modules/360-istio/docs/USAGE.md#destinationrule).
* `disableMixerTelemetry` — выключить компонент Mixer и сбор [телеметрии](https://istio.io/docs/concepts/policies-and-telemetry/). Деплоймент mixer-telemetry будет получать от сайдкаров метрики и аггрегировать их для экспорта в Prometheus. Может повлиять на производительность сайдкаров.
    * По-умолчанию `false`.
* `enableAuthorizationGlobally` — включить режим [нативной авторизации](/modules/360-istio/docs/USAGE.md#нативная авторизация) средствами istio-proxy "что не разрешено, то запрещено".
    * **Важно!** Авторизация без mTLS-аутентификации не будет работать в полной мере. В этом случае будут доступны только простейшие аргументы для составления политик, такие как source.ip и request.headers.
    * При включении авторизации перестанут работать классические HTTP-пробы, так как разрешающих правил для проб никто не сделал. Но в sаidecar c istio предусмотрен специальный порт, куда можно эти пробы направить. Sidecar-injector, который добавляет sidecar-ы в поды, заодно перенаправит ваши пробы на специальный порт.
    * Авторизацию также можно включать локально, для namespace или для единственного сервиса с помощью ресурса [RbacConfig](/modules/360-istio/docs/USAGE.md#RbacConfig).
    * По-умолчанию `false`.
* `sidecarInjectorPolicy` — определяет поведение sidecar-injector-а после того, как его натравили на прикладной namespace (см. [Как активировать istio для моего приложения?](#Как активировать istio для моего приложения?)).
    * Возможные значения — `enabled` (вставлять sidecar в новые поды) или `disabled` (не вставлять sidecar в новые поды). Переопределить поведение можно аннотацией к поду `sidecar.istio.io/inject`.
    * По-умолчанию — `enabled`.
* `sidecar`:
    * `includeOutboundIPRanges` — трафик в сторону этих диапазонов IP насильно заворачивается через istio.
        * Формат — массив подсетей или `["*"]`.
        * По-умолчанию — список из Pod CIDR, Service CIDR и адресов нод, собранных с кластера discovery-хуком `cluster_ip_ranges`. То есть, в интернет ходим по-старинке, а локальный трафик контролируем.
        * Можно локально переопределить аннотацией `traffic.sidecar.istio.io/includeOutboundIPRanges`.
    * `excludeOutboundIPRanges` — трафик в сторону этих диапазонов IP гарантированно не заворачивается через istio.
        * Формат — массив подсетей или `["*"]`.
        * По-умолчанию `[]`. То есть, исключений не делаем.
        * Можно локально переопределить аннотацией `traffic.sidecar.istio.io/excludeOutboundIPRanges`.
    * `excludeInboundPorts` — диапазоны входящих портов, чей трафик гарантированно не заворачивается через istio.
        * Формат — массив портов или `["*"]`.
        * По-умолчанию `[]`. То есть, исключений не делаем.
        * Можно локально переопределить аннотацией `traffic.sidecar.istio.io/excludeInboundPorts`.
    * `excludeOutboundPorts` — диапазоны исходящих портов, чей трафик гарантированно не заворачивается через istio.
        * Формат — массив портов или `["*"]`.
        * По-умолчанию `[]`. То есть, исключений не делаем.
        * Можно локально переопределить аннотацией `traffic.sidecar.istio.io/excludeOutboundPorts`.
    * `zipkinAddress` — адрес сервиса, который готов принять трейсы в формате Zipkin. Это может быть либо инсталляция zipkin, либо jaeger collector (Envoy, на котором основан Istio не умеет слать трейсы по правильному протоколу в jaeger agent, только zipkin). см. [Трассировка](#Трассировка).
        * Формат — `адрес:порт` (например, `jaeger.kube-jaeger:9411`).
        * По-умолчанию `false`.
* `nodeSelector` — как в Kubernetes в `spec.nodeSelector` у pod'ов.
    * Если ничего не указано — будет [использоваться автоматика](/README.md#выделение-узлов-под-определенный-вид-нагрузки).
    * Можно указать `false`, чтобы не добавлять никакой nodeSelector.
* `tolerations` — как в Kubernetes в `spec.tolerations` у pod'ов.
    * Если ничего не указано — будет [использоваться автоматика](/README.md#выделение-узлов-под-определенный-вид-нагрузки).
    * Можно указать `false`, чтобы не добавлять никакие toleration'ы.

### Как активировать istio для моего приложения?
Основная цель активации — добавить sidecar-контейнер "istio-proxy" на основе envoy к подам приложения, после чего через него зарулится трафик и тем самым станет подконтрольным.

Рекомендованный способ добавления sidecar-ов — использовать sidecar-injector. Istio умеет "подселять" к вашим подам sidecar-контейнер с помощью механизма [Admission Webhook](https://kubernetes.io/docs/reference/access-authn-authz/extensible-admission-controllers/). Настраивается с помощью лейблов и аннотаций:
* лейбл к **namespace** — `istio-injection=enabled`, обращает внимание sidecar-injector-а на ваш namespace, после установки лейбла, согласно настройке `sidecarInjectorPolicy`, к новым подам будут прикрепляться sidecar-ы или не будут.
* аннотация к **поду** — `sidecar.istio.io/inject` (`"true"` или `"false"`), позволяет локально переопределить политику `sidecarInjectorPolicy`.

**Важно знать!** istio-proxy, который работает в качестве sidecar-контейнера тоже потребляет ресурсы! По-умолчанию контейнеры реквестят `cpu: 100m` и `memory: 128Mi`, лимитов не установлено. Переопределить можно двумя аннотациями одновременно:
* `sidecar.istio.io/proxyCPU`
* `sidecar.istio.io/proxyMemory`

### Что мне даст Istio?
* Circuit breaker — если сервис прилёг и количество ошибочных запросов перевалило за определённый порог, то сайдкар начнёт возвращать HTTP-ошибку на каждый новый запрос дабы дать сервису время придти в себя.
* mTLS — Прозрачное шифрование трафика и аутентификация между сервисами. Сомнения:
    * Eсли сеть в кластере нельзя считать доверенной, это в любом случае создает проблемы:
        * Если сеть в кластере "не совсем доверенная", например это VPC в AWS и вы боитесь, как бы ваш трафик Amazon не соснифали — не стоит, Amazon в любом случае имеет полный доступ к виртуальным машинам.
        * Если вы боитесь, что админы кластера VMWare могут соснифать — тоже не бойтесь, у них все равно есть полный доступ ко всему.
        * Если сеть работает через "публичку" — нужно делать VPN и защищать весь трафик, а если это более-менее доверенная локалка — в большинстве случаев mTLS никак не изменит ситуацию.
        * Если похакают ноду, то и трафик соснифают и от лица сервиса смогут вести активность.
    * Использовать политики Istio для ограничения доступа следует с осторожностью. Если есть возможность использовать простые сетевые политики — то лучше поступать так. Политики от Istio — это реквест в Mixer из сайдкара на каждый запрос, соответственно, ещё один SPoF.
* Хитрая маршрутизация — на основе нестандартных параметров, например, спец-заголовков или просто рандома, направлять часть трафика на дополнительный бекенд.
* [Помощь в трассировке](#Трассировка).

### Трассировка
**Важно знать!** Istio чудесным образом не добавит трейсы в ваш неподготовленный проект! Он собирает трейсы только если видит спец-заголовки в пролетающих через него пакетах.

Для обработки трейсов вам потребуется:
* Инсталляция jaeger.
* Настройка приложения. Два варианта:
    * Правильный путь — добавить в приложение полноценный [jaeger-клиент](https://www.jaegertracing.io/docs/1.9/client-libraries/). В этом случае станут доступны **все** возможности трассировки, в т.ч. трассировка запросов к БД после соответствующих правок в коде (обернуть `mysql_query` трейс-триггерами, например).
    * Istio-путь — добавить в приложение поддержку спец-заголовков, что зачастую по трудозатратам сопоставимо с "Правильным путём". В этом случае дополнительный трейсы в виде запросов к БД или прочих внешних запросов **доступны не будут**.
