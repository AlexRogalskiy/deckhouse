---
title: "Модуль istio"
---

Модуль устанавливает [Istio](https://istio.io/).

## Что даст Istio
* Circuit breaker — если сервис прилёг и количество ошибочных запросов перевалило за определённый порог, то сайдкар начнёт возвращать HTTP-ошибку на каждый новый запрос дабы дать сервису время придти в себя.
* mTLS — Прозрачное шифрование трафика и аутентификация между сервисами. Сомнения:
    * Если сеть в кластере нельзя считать доверенной, это в любом случае создает проблемы:
        * Если сеть в кластере "не совсем доверенная", например это VPC в AWS и вы боитесь, как бы ваш трафик Amazon не соснифали — не стоит, Amazon в любом случае имеет полный доступ к виртуальным машинам.
        * Если вы боитесь, что админы кластера VMWare могут сосниффать — тоже не бойтесь, у них все равно есть полный доступ ко всему.
        * Если сеть работает через "публичку" — нужно делать VPN и защищать весь трафик, а если это более-менее доверенная локалка — в большинстве случаев mTLS никак не изменит ситуацию.
        * Если похакают ноду, то и трафик соснифают и от лица сервиса смогут вести активность.
    * Использовать политики Istio для ограничения доступа следует с осторожностью. Если есть возможность использовать простые сетевые политики — то лучше поступать так.
* Хитрую маршрутизацию — например, может направлять часть трафика на дополнительный бекенд на основе нестандартных параметров (например случайных или специальных заголовков).
* [Помощь в трассировке](#трассировка).

## Как активировать Istio для приложения
Основная цель активации — добавить sidecar-контейнер "istio-proxy" на основе envoy к подам приложения, после чего через него начнет маршрутизироваться трафик и Istio сможет им управлять.

Рекомендованный способ добавления sidecar-ов — использовать sidecar-injector. Istio умеет "подселять" к вашим подам sidecar-контейнер с помощью механизма [Admission Webhook](https://kubernetes.io/docs/reference/access-authn-authz/extensible-admission-controllers/). Настраивается с помощью лейблов и аннотаций:
* Лейбл к **namespace** — обращает внимание sidecar-injector-а на ваш namespace, после установки лейбла, к новым подам будут подселяться sidecar-ы:
  * `istio-injection=enabled` — использовать самую свежую установленную версию Istio.
  * `istio.io/rev=v1x8x1` — использовать конкретную версию Istio для данного namespace.
* Аннотация к **поду** — `sidecar.istio.io/inject` (`"true"` или `"false"`), позволяет локально переопределить политику `sidecarInjectorPolicy`. Эти аннотации работают только в namespace, обозначенных лейблами из списка выше.

**Важно знать!** Istio-proxy, который работает в качестве sidecar-контейнера тоже потребляет ресурсы и добавляет оверхед:
* Каждый запрос DNAT-ится в envoy, который обрабатывает реквест и создаёт ещё один. На принимающей стороне аналогично.
* Каждый envoy хранит информацию обо всех сервисах в кластере, что требует памяти. Больше кластер — больше памяти потребляет envoy. Решение — CustomResource [Sidecar](cr.html#sidecar).

### Трассировка
**Важно знать!** Istio чудесным образом не добавит трейсы в ваш неподготовленный проект! Он собирает трейсы только если видит спец-заголовки в пролетающих через него пакетах.

Для обработки трейсов вам потребуется:
* Инсталляция jaeger.
* Настройка приложения. Два варианта:
    * Правильный путь — добавить в приложение полноценный [jaeger-клиент](https://www.jaegertracing.io/docs/1.9/client-libraries/). В этом случае станут доступны **все** возможности трассировки, в т.ч. трассировка запросов к БД после соответствующих правок в коде (обернуть `mysql_query` трейс-триггерами, например).
    * Istio-путь — добавить в приложение поддержку спец-заголовков, что зачастую по трудозатратам сопоставимо с "Правильным путём". В этом случае дополнительные трейсы в виде запросов к БД или прочих внешних запросов **доступны не будут**.
