Index: go.mod
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/go.mod b/go.mod
index 4863516..a8470cd 100644
--- a/go.mod
+++ b/go.mod
@@ -10,7 +10,7 @@ require (
 	github.com/spf13/cobra v1.1.1
 	github.com/spf13/pflag v1.0.5
 	github.com/ugorji/go v1.1.4 // indirect
-	github.com/vmware/govmomi v0.21.0
+	github.com/vmware/govmomi v0.21.1-0.20191118233729-446ecc5f2e3f
 	github.com/xordataexchange/crypt v0.0.3-0.20170626215501-b2862e3d0a77 // indirect
 	golang.org/x/net v0.0.0-20201110031124-69a78807bb2b
 	google.golang.org/grpc v1.27.1
Index: go.sum
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/go.sum b/go.sum
--- a/go.sum	(revision 803294317670aacf5f0ee9eace31eb288284b527)
+++ b/go.sum	(revision 55b58029493df3ae81d9d085e28dcb7a160ef702)
@@ -547,6 +547,8 @@
 github.com/vmware/govmomi v0.20.3/go.mod h1:URlwyTFZX72RmxtxuaFL2Uj3fD1JTvZdx59bHWk6aFU=
 github.com/vmware/govmomi v0.21.0 h1:jc8uMuxpcV2xMAA/cnEDlnsIjvqcMra5Y8onh/U3VuY=
 github.com/vmware/govmomi v0.21.0/go.mod h1:zbnFoBQ9GIjs2RVETy8CNEpb+L+Lwkjs3XZUL0B3/m0=
+github.com/vmware/govmomi v0.21.1-0.20191118233729-446ecc5f2e3f h1:Oz9SOSs3UACQUAy75CAkZEb1YRrdBkkhSr25poAzQIg=
+github.com/vmware/govmomi v0.21.1-0.20191118233729-446ecc5f2e3f/go.mod h1:Y+Wq4lst78L85Ge/F8+ORXIWiKYqaro1vhAulACy9Lc=
 github.com/vmware/vmw-guestinfo v0.0.0-20170707015358-25eff159a728/go.mod h1:x9oS4Wk2s2u4tS29nEaDLdzvuHdB19CvSGJjPgkZJNk=
 github.com/xiang90/probing v0.0.0-20190116061207-43a291ad63a2 h1:eY9dn8+vbi4tKz5Qo6v2eYzo7kUS51QINcR5jNpbZS8=
 github.com/xiang90/probing v0.0.0-20190116061207-43a291ad63a2/go.mod h1:UETIi67q53MR2AWcXfiuqkDkRtnGDLqkBTpCHuJHxtU=
Index: pkg/common/config/config.go
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/pkg/common/config/config.go b/pkg/common/config/config.go
--- a/pkg/common/config/config.go	(revision 803294317670aacf5f0ee9eace31eb288284b527)
+++ b/pkg/common/config/config.go	(revision 55b58029493df3ae81d9d085e28dcb7a160ef702)
@@ -150,6 +150,10 @@
 		cfg.Global.IPFamily = DefaultIPFamily
 	}
 
+	if v := os.Getenv("VSPHERE_VM_FOLDER_PATH"); v != "" {
+		cfg.Global.VmFolderPath = v
+	}
+
 	//Build VirtualCenter from ENVs
 	for _, e := range os.Environ() {
 		pair := strings.Split(e, "=")
@@ -236,6 +240,11 @@
 				externalNetworkNames = cfg.Global.ExternalNetworkNames
 			}
 
+			_, vmFolderPath, errVmFolderPath := getEnvKeyValue("VCENTER_"+id+"_VM_FOLDER_PATH", false)
+			if errVmFolderPath != nil {
+				vmFolderPath = cfg.Global.VmFolderPath
+			}
+
 			// If server is explicitly set, that means the vcenter value above is the TenantRef
 			vcenterIP := vcenter
 			tenantRef := vcenter
@@ -261,6 +270,7 @@
 				IPFamily:             ipFamily,
 				InternalNetworkNames: internalNetworkNames,
 				ExternalNetworkNames: externalNetworkNames,
+				VmFolderPath:         vmFolderPath,
 			}
 		}
 	}
@@ -283,6 +293,7 @@
 			IPFamily:             cfg.Global.IPFamily,
 			InternalNetworkNames: cfg.Global.InternalNetworkNames,
 			ExternalNetworkNames: cfg.Global.ExternalNetworkNames,
+			VmFolderPath:         cfg.Global.VmFolderPath,
 		}
 	}
 
@@ -365,6 +376,7 @@
 			IPFamilyPriority:     ipFamilyPriority,
 			InternalNetworkNames: cfg.Global.InternalNetworkNames,
 			ExternalNetworkNames: cfg.Global.ExternalNetworkNames,
+			VmFolderPath:         cfg.Global.VmFolderPath,
 		}
 		cfg.VirtualCenter[cfg.Global.VCenterIP] = vcConfig
 	}
@@ -455,6 +467,10 @@
 		if vcConfig.ExternalNetworkNames == "" {
 			vcConfig.ExternalNetworkNames = cfg.Global.ExternalNetworkNames
 		}
+
+		if vcConfig.VmFolderPath == "" {
+			vcConfig.VmFolderPath = cfg.Global.VmFolderPath
+		}
 	}
 
 	return nil
Index: pkg/common/config/types.go
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/pkg/common/config/types.go b/pkg/common/config/types.go
--- a/pkg/common/config/types.go	(revision 803294317670aacf5f0ee9eace31eb288284b527)
+++ b/pkg/common/config/types.go	(revision 55b58029493df3ae81d9d085e28dcb7a160ef702)
@@ -63,6 +63,8 @@
 		// will be used in respective status.addresses fields. Comma-separated.
 		InternalNetworkNames string `gcfg:"internal-network-names"`
 		ExternalNetworkNames string `gcfg:"external-network-names"`
+		// VmFolderPath (e.g. "production/ubuntu-test-runners") is a path (relative to root datacenter VM folder), in which Kubernetes VMs reside
+		VmFolderPath string `gcfg:"vm-folder-path"`
 	}
 
 	// Virtual Center configurations
@@ -121,4 +123,6 @@
 	// will be used in respective status.addresses fields. Comma-separated.
 	InternalNetworkNames string `gcfg:"internal-network-names"`
 	ExternalNetworkNames string `gcfg:"external-network-names"`
+	// VmFolderPath (e.g. "production/ubuntu-test-runners") is a path (relative to root datacenter VM folder), in which Kubernetes VMs reside
+	VmFolderPath string `gcfg:"vm-folder-path"`
 }
Index: pkg/common/connectionmanager/search.go
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/pkg/common/connectionmanager/search.go b/pkg/common/connectionmanager/search.go
--- a/pkg/common/connectionmanager/search.go	(revision 803294317670aacf5f0ee9eace31eb288284b527)
+++ b/pkg/common/connectionmanager/search.go	(revision 55b58029493df3ae81d9d085e28dcb7a160ef702)
@@ -167,13 +167,25 @@
 				var vm *vclib.VirtualMachine
 				var err error
 
-				switch searchBy {
-				case FindVMByUUID:
-					vm, err = res.datacenter.GetVMByUUID(ctx, myNodeID)
-				case FindVMByIP:
-					vm, err = res.datacenter.GetVMByIP(ctx, myNodeID)
-				default:
-					vm, err = res.datacenter.GetVMByDNSName(ctx, myNodeID)
+				folderPath := cm.VsphereInstanceMap[res.tenantRef].Cfg.VmFolderPath
+				if len(folderPath) == 0 {
+					switch searchBy {
+					case FindVMByUUID:
+						vm, err = res.datacenter.GetVMByUUID(ctx, myNodeID)
+					case FindVMByIP:
+						vm, err = res.datacenter.GetVMByIP(ctx, myNodeID)
+					default:
+						vm, err = res.datacenter.GetVMByDNSName(ctx, myNodeID)
+					}
+				} else {
+					switch searchBy {
+					case FindVMByUUID:
+						vm, err = res.datacenter.GetVMByUUIDInFolder(ctx, myNodeID, folderPath)
+					case FindVMByIP:
+						vm, err = res.datacenter.GetVMByIPInFolder(ctx, myNodeID, folderPath)
+					default:
+						vm, err = res.datacenter.GetVMByDNSNameInFolder(ctx, myNodeID, folderPath)
+					}
 				}
 
 				if err != nil {
Index: pkg/common/vclib/datacenter.go
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/pkg/common/vclib/datacenter.go b/pkg/common/vclib/datacenter.go
--- a/pkg/common/vclib/datacenter.go	(revision 803294317670aacf5f0ee9eace31eb288284b527)
+++ b/pkg/common/vclib/datacenter.go	(revision 55b58029493df3ae81d9d085e28dcb7a160ef702)
@@ -20,6 +20,7 @@
 	"context"
 	"errors"
 	"fmt"
+	"path"
 	"path/filepath"
 	"strings"
 
@@ -93,6 +94,55 @@
 	virtualMachine := VirtualMachine{svm.(*object.VirtualMachine), dc}
 	return &virtualMachine, nil
 }
+
+// GetVMByIPInFolder gets the VM object from the given IP address and folder path
+func (dc *Datacenter) GetVMByIPInFolder(ctx context.Context, ipAddy, folderPath string) (*VirtualMachine, error) {
+	finder := find.NewFinder(dc.Client())
+
+	vmFolder, err := finder.Folder(ctx, path.Join("/", dc.Name(), "vm", folderPath))
+
+	s := object.NewSearchIndex(dc.Client())
+	ipAddy = strings.ToLower(strings.TrimSpace(ipAddy))
+
+	vmRefs, err := s.FindAllByIp(ctx, dc.Datacenter, ipAddy, true)
+	if err != nil {
+		klog.Errorf("Can't find VMs by IP %s: %s", ipAddy, err)
+		return nil, err
+	}
+	if len(vmRefs) == 0 {
+		klog.Errorf("Can't find VMs by IP %s: %s", ipAddy, err)
+		return nil, ErrNoVMFound
+	}
+
+	var matchingChildRef *types.ManagedObjectReference
+	for _, vmRef := range vmRefs {
+		hasAncestor, err := ObjectHasAncestor(ctx, dc.Client(), vmRef, vmFolder.Reference())
+		if err != nil {
+			klog.Errorf("can't find whether %+v has %+v ancestor: %s", vmRef, vmFolder.Reference(), err)
+			return nil, err
+		}
+
+		if hasAncestor {
+			childRef := vmRef.Reference()
+			matchingChildRef = &childRef
+			break
+		}
+	}
+
+	if matchingChildRef != nil {
+		svm := object.NewReference(s.Client(), matchingChildRef.Reference())
+		if svm == nil {
+			klog.Errorf("Unable to find VM by IP. VM IP: %s", ipAddy)
+			return nil, ErrNoVMFound
+		}
+
+		virtualMachine := VirtualMachine{svm.(*object.VirtualMachine), dc}
+		return &virtualMachine, nil
+	} else {
+		klog.Errorf("Unable to find VM by IP. VM IP: %s", ipAddy)
+		return nil, ErrNoVMFound
+	}
+}
 
 // GetVMByDNSName gets the VM object from the given dns name
 func (dc *Datacenter) GetVMByDNSName(ctx context.Context, dnsName string) (*VirtualMachine, error) {
@@ -110,6 +160,55 @@
 	virtualMachine := VirtualMachine{svm.(*object.VirtualMachine), dc}
 	return &virtualMachine, nil
 }
+
+// GetVMByDNSNameInFolder gets the VM object from the given dns name in folder path
+func (dc *Datacenter) GetVMByDNSNameInFolder(ctx context.Context, dnsName, folderPath string) (*VirtualMachine, error) {
+	finder := find.NewFinder(dc.Client())
+
+	vmFolder, err := finder.Folder(ctx, path.Join("/", dc.Name(), "vm", folderPath))
+
+	s := object.NewSearchIndex(dc.Client())
+	dnsName = strings.ToLower(strings.TrimSpace(dnsName))
+
+	vmRefs, err := s.FindAllByDnsName(ctx, dc.Datacenter, dnsName, true)
+	if err != nil {
+		klog.Errorf("Can't find VMs by DNS Name %s: %s", dnsName, err)
+		return nil, err
+	}
+	if len(vmRefs) == 0 {
+		klog.Errorf("Can't find VMs by DNS Name %s: %s", dnsName, err)
+		return nil, ErrNoVMFound
+	}
+
+	var matchingChildRef *types.ManagedObjectReference
+	for _, vmRef := range vmRefs {
+		hasAncestor, err := ObjectHasAncestor(ctx, dc.Client(), vmRef, vmFolder.Reference())
+		if err != nil {
+			klog.Errorf("can't find whether %+v has %+v ancestor: %s", vmRef, vmFolder.Reference(), err)
+			return nil, err
+		}
+
+		if hasAncestor {
+			childRef := vmRef.Reference()
+			matchingChildRef = &childRef
+			break
+		}
+	}
+
+	if matchingChildRef != nil {
+		svm := object.NewReference(s.Client(), matchingChildRef.Reference())
+		if svm == nil {
+			klog.Errorf("Unable to find VM by DNS Name. VM DNS Name: %s", dnsName)
+			return nil, ErrNoVMFound
+		}
+
+		virtualMachine := VirtualMachine{svm.(*object.VirtualMachine), dc}
+		return &virtualMachine, nil
+	} else {
+		klog.Errorf("Unable to find VM by DNS Name. VM DNS Name: %s", dnsName)
+		return nil, ErrNoVMFound
+	}
+}
 
 // GetVMByUUID gets the VM object from the given vmUUID
 func (dc *Datacenter) GetVMByUUID(ctx context.Context, vmUUID string) (*VirtualMachine, error) {
@@ -127,6 +226,58 @@
 	virtualMachine := VirtualMachine{svm.(*object.VirtualMachine), dc}
 	return &virtualMachine, nil
 }
+
+// GetVMByUUIDInFolder gets the VM object from the given vmUUID address and folder path
+func (dc *Datacenter) GetVMByUUIDInFolder(ctx context.Context, vmUUID, folderPath string) (*VirtualMachine, error) {
+	finder := find.NewFinder(dc.Client())
+
+	vmFolder, err := finder.Folder(ctx, path.Join("/", dc.Name(), "vm", folderPath))
+	if err != nil {
+		return nil, err
+	}
+
+	s := object.NewSearchIndex(dc.Client())
+	vmUUID = strings.ToLower(strings.TrimSpace(vmUUID))
+
+	vmRefs, err := s.FindAllByUuid(ctx, dc.Datacenter, vmUUID, true, nil)
+	if err != nil {
+		klog.Errorf("Can't find VMs by UUID %s: %s", vmUUID, err)
+		return nil, err
+	}
+	if len(vmRefs) == 0 {
+		klog.Errorf("Can't find VMs by UUID %s: %s", vmUUID, err)
+		return nil, ErrNoVMFound
+	}
+
+	var matchingChildRef *types.ManagedObjectReference
+	for _, vmRef := range vmRefs {
+		hasAncestor, err := ObjectHasAncestor(ctx, dc.Client(), vmRef, vmFolder.Reference())
+		if err != nil {
+			klog.Errorf("can't find whether %+v has %+v ancestor: %s", vmRef, vmFolder.Reference(), err)
+			return nil, err
+		}
+
+		if hasAncestor {
+			childRef := vmRef.Reference()
+			matchingChildRef = &childRef
+			break
+		}
+	}
+
+	if matchingChildRef != nil {
+		svm := object.NewReference(s.Client(), matchingChildRef.Reference())
+		if svm == nil {
+			klog.Errorf("Unable to find VM by UUID. VM UUID: %s", vmUUID)
+			return nil, ErrNoVMFound
+		}
+
+		virtualMachine := VirtualMachine{svm.(*object.VirtualMachine), dc}
+		return &virtualMachine, nil
+	} else {
+		klog.Errorf("Unable to find VM by UUID. VM UUID: %s", vmUUID)
+		return nil, ErrNoVMFound
+	}
+}
 
 // GetVMByPath gets the VM object from the given vmPath
 // vmPath should be the full path to VM and not just the name
Index: pkg/common/vclib/utils.go
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/pkg/common/vclib/utils.go b/pkg/common/vclib/utils.go
--- a/pkg/common/vclib/utils.go	(revision 803294317670aacf5f0ee9eace31eb288284b527)
+++ b/pkg/common/vclib/utils.go	(revision 55b58029493df3ae81d9d085e28dcb7a160ef702)
@@ -17,11 +17,15 @@
 package vclib
 
 import (
+	"context"
 	"fmt"
 	"path/filepath"
 	"regexp"
 	"strings"
 
+	"github.com/vmware/govmomi/property"
+	"github.com/vmware/govmomi/vim25"
+
 	"github.com/vmware/govmomi/find"
 	"github.com/vmware/govmomi/object"
 	"github.com/vmware/govmomi/vim25/mo"
@@ -218,3 +222,21 @@
 	}
 	return false
 }
+
+// Checks
+func ObjectHasAncestor(ctx context.Context, client *vim25.Client, object object.Reference, requiredAncestor object.Reference) (bool, error) {
+	ancestors, err := mo.Ancestors(ctx, client.Client, property.DefaultCollector(client).Reference(), object.Reference())
+	if err != nil {
+		return false, fmt.Errorf("can't collect ancestors for vm %+v", object.Reference())
+	}
+
+	var found bool
+	for _, ancestor := range ancestors {
+		if ancestor.Reference() == requiredAncestor.Reference() {
+			found = true
+			break
+		}
+	}
+
+	return found, nil
+}
