#!/bin/bash

source /deckhouse/shell_lib.sh

function __config__() {
  cat << EOF
    configVersion: v1
    kubernetes:
    - name: secrets
      queue: /modules/secret-copier
      apiVersion: v1
      kind: Secret
      namespace:
        nameSelector:
          matchNames: [default]
      labelSelector:
        matchLabels:
          antiopa-secret-copier: "yes"
EOF
}

# $1 — secret name
function _copy_secret() {
  secret="$1"
  # для каждого Namespace, кроме "default"
  for namespace in $(kubectl get namespace -o json |
                    jq -r '.items[] |
                      select((.metadata.name == "default" | not) and .status.phase == "Active") | .metadata.name')
  do
    # копируем секрет, предварительно удалив лишние поля из metadata
    kubectl -n default get secret $secret -o json | \
      jq -r ".metadata.namespace=\"${namespace}\" |
              .metadata |= with_entries(select([.key] | inside([\"name\", \"namespace\", \"labels\"])))" \
      | kubernetes::replace_or_create_json
  done
}

function __on_kubernetes::secrets::synchronization() {
  for secret in $(context::jq -r '.objects[] | .object.metadata.name'); do
    _copy_secret "$secret"
  done
}

function __on_kubernetes::secrets::added_or_modified() {
  _copy_secret "$(context::get object.metadata.name)"
}

function __on_kubernetes::secrets::deleted() {
  secret="$(context::get object.metadata.name)"
  for namespace in $(kubectl get namespace -o json |
                      jq -r '.items[] |
                        select((.metadata.name == "default" | not) and .status.phase == "Active") | .metadata.name')
  do
    if ! $(kubectl -n $namespace get secret $secret > /dev/null 2> /dev/null) ; then
      continue
    fi

    kubectl -n $namespace delete secret $secret || echo "Deletion of secret $secret in namespace $namespace failed. Skipping... "
  done
}

hook::run $@
