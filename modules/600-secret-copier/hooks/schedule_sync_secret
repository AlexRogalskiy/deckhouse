#!/bin/bash

source /deckhouse/shell_lib.sh

function __config__() {
  cat << EOF
    configVersion: v1
    schedule:
    - name: sync_secret
      queue: /modules/$(module::name::kebab_case)
      crontab: "0 3 * * *"
      allowFailure: true
EOF
}

function __main__() {
  # Добавляем во все namespace secret из default namespace, если вдруг их там не оказалось
  for secret in $(kubectl -n default get secret -l antiopa-secret-copier=yes -o name);
    do
    # для каждого Namespace, кроме "default"
    for namespace in $(kubectl get namespace -o json |
                        jq -r '.items[] |
                          select((.metadata.name == "default" | not) and .status.phase == "Active") | .metadata.name')
    do
      # копируем секрет, предварительно удалив лишние поля из metadata
      kubectl -n default get $secret -o json | \
        jq -r ".metadata.namespace=\"${namespace}\" |
                .metadata |= with_entries(select([.key] | inside([\"name\", \"namespace\", \"labels\"])))" \
        | kubernetes::replace_or_create_json
    done
  done

  # Получаем список имен из default Namespace с лейблами, проходимся далее по всем секретам в кластере
  # и получаем список тех, у которых лейбл присутствует, а имя не входит в массив имён, полученных из
  # default Namespace
  # Финальный список скармливаем `kubectl delete`
  kubectl get secret --all-namespaces -o json | \
    jq -r '([.items[] | select(.metadata.labels."antiopa-secret-copier" == "yes" and .metadata.namespace == "default").metadata.name]) as $secrets |
             .items[] | select(.metadata.labels."antiopa-secret-copier" == "yes" and .metadata.namespace != "default" and ([.metadata.name] | inside($secrets) | not)) |
             "\(.metadata.namespace) secret \(.metadata.name)"' | \
    while read -r secret
    do
      kubectl delete -n $secret || echo "Deletion of $secret failed. Skipping... "
    done
}

hook::run $@
