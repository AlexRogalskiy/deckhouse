#!/bin/bash

source /deckhouse/shell_lib.sh

function __config__() {
  if [ -n "${D8_IS_TESTS_ENVIRONMENT-}" ]; then
    instance_class_kind=D8TestInstanceClass
  else
    if kubectl get -n kube-system secret d8-node-manager-cloud-provider >/dev/null 2>/dev/null; then
      instance_class_kind="$(kubectl get -n kube-system secret d8-node-manager-cloud-provider -o json 2>/dev/null | jq -r '.data.instanceClassKind' | base64 -d || true)"
    elif kubectl get -n kube-system secret d8-cloud-instance-manager-cloud-provider >/dev/null 2>/dev/null; then
      instance_class_kind="$(kubectl get -n kube-system secret d8-cloud-instance-manager-cloud-provider -o json 2>/dev/null | jq -r '.data.instanceClassKind' | base64 -d || true)"
    fi
    if [ -v instance_class_kind ]; then
      echo "$instance_class_kind" > /tmp/node-manager-instance-class-kind
    fi
  fi

  cat << EOF
    configVersion: v1
    beforeHelm: 10
    kubernetes:
    - name: ngs
      queue: /modules/$(module::name::kebab_case)
      group: main
      includeSnapshotsFrom: ["cloud_provider_secrets"]
      keepFullObjectsInMemory: false
      apiVersion: deckhouse.io/v1alpha1
      kind: NodeGroup
      jqFilter: |
        {
          "name": .metadata.name,
          "spec": (
            .spec
            +
            {"manualRolloutID": (.metadata.annotations."manual-rollout-id" // "")}
          )
        }
    $(
    if [ -n "$instance_class_kind" ]; then
      echo "
    - name: ics
      queue: /modules/$(module::name::kebab_case)
      group: main
      includeSnapshotsFrom: ["cloud_provider_secrets"]
      keepFullObjectsInMemory: false
      apiVersion: deckhouse.io/v1alpha1
      kind: ${instance_class_kind}
      jqFilter: |
        {
          \"name\": .metadata.name,
          \"spec\": .spec,
          \"bundle\": .spec.bashible.bundle
        }
"
    fi
    )
    - name: machine_deployments
      queue: /modules/$(module::name::kebab_case)
      apiVersion: machine.sapcloud.io/v1alpha1
      kind: MachineDeployment
      group: main
      includeSnapshotsFrom: ["cloud_provider_secrets"]
      keepFullObjectsInMemory: false
      namespace:
        nameSelector:
          matchNames: [d8-cloud-instance-manager]
      labelSelector:
        matchExpressions:
        - key: heritage
          operator: In
          values: ["deckhouse"]
      jqFilter: |
        {
          "name": .metadata.name,
          "zone": .metadata.annotations.zone
        }
    - name: cloud_provider_secrets
      queue: /modules/$(module::name::kebab_case)
      includeSnapshotsFrom: ["cloud_provider_secrets"]
      keepFullObjectsInMemory: false
      apiVersion: v1
      kind: Secret
      namespace:
        nameSelector:
          matchNames: [kube-system]
      nameSelector:
        matchNames: [d8-node-manager-cloud-provider]
      jqFilter: |
        (.data | [to_entries[] | (.value |= (. | @base64d))] | from_entries)
        +
        (.data | [to_entries[] | try(.value |= (. | @base64d | fromjson))] | from_entries) |
        {
          "instanceClassKind": .instanceClassKind,
          "zones": .zones
        }
    schedule:
    - group: main
      includeSnapshotsFrom: ["cloud_provider_secrets"]
      queue: /modules/$(module::name::kebab_case)
      crontab: "*/10 * * * *"
EOF
}

function __on_kubernetes::cloud_provider_secrets() {
  if [ ! -v D8_IS_TESTS_ENVIRONMENT ] && context::has snapshots.cloud_provider_secrets.0; then
    current_instance_class_kind="$(cat /tmp/node-manager-instance-class-kind 2>/dev/null || true)"
    new_instance_class_kind="$(context::get snapshots.cloud_provider_secrets.0.filterResult.instanceClassKind)"
    if [ "$current_instance_class_kind" != "$new_instance_class_kind" ]; then
      echo "INFO: InstanceClassKind has changed from $current_instance_class_kind to $new_instance_class_kind, restarting deckhouse..."
      kill 1 # restart deckhouse
    fi
  fi
}

# $1 — NG name
# $2 — error message or empty string
function _set_ng_error_status() {
  status_patch="$(jq -n --arg msg "$2" '{"error": $msg}')"
  kubernetes::status::merge_patch "" "deckhouse.io/v1alpha1" "nodegroups" "${1}" "${status_patch}"
}

function __main__() {
  if [ -n "${D8_IS_TESTS_ENVIRONMENT-}" ]; then
    instance_class_kind=D8TestInstanceClass
  else
    instance_class_kind="$(cat /tmp/node-manager-instance-class-kind 2>/dev/null || true)"
  fi

  # Read kubernetes version either from clusterConfiguration or from discovery
  global_target_kubernetes_version="$(semver::majmin "$(values::get global.discovery.kubernetesVersion)")"
  if values::has global.clusterConfiguration.kubernetesVersion ; then
    global_target_kubernetes_version="$(values::get global.clusterConfiguration.kubernetesVersion)"
  fi
  control_plane_kubernetes_versions="$(values::jq -r '.global.discovery.kubernetesVersions[]')"
  control_plane_min_kubernetes_version="$(semver::majmin "$(semver::get_min "$control_plane_kubernetes_versions")")"
  control_plane_max_kubernetes_version="$(semver::majmin "$(semver::get_max "$control_plane_kubernetes_versions")")"

  default_zones=$(context::jq -r '.snapshots |
  (if (.machine_deployments | length) > 0 then [.machine_deployments[].filterResult.zone | select(length > 0)] else [] end) as $a |
  (if (.cloud_provider_secrets | length) > 0 then .cloud_provider_secrets[].filterResult.zones else [] end) as $b |
  $a + $b | unique')

  timestamp=$(date +%s)
  if [ -n "${D8_IS_TESTS_ENVIRONMENT-}" ]; then
    timestamp="1234567890" # Fake timestamp for updateEpoch test values
  fi

  final_node_groups="[]"

  metrics_group="/modules/$(module::name::kebab_case)/internal_network_cidrs"

  jq -c --arg group "$metrics_group" '.group = $group' <<< '{"action":"expire"}' >> $METRICS_PATH

  for i in $(context::jq -r '.snapshots.ngs | keys[]'); do
    ng_name="$(context::get snapshots.ngs.$i.filterResult.name)"
    ng="$(context::get snapshots.ngs.$i.filterResult.spec)"
    ng="$(jq --arg name "${ng_name}" '.name = $name' <<< "$ng")"

    if jq -e '.nodeType == "Static"' <<< "$ng" > /dev/null; then
      # Metric for deprecation alert
      if jq -rce '.static' <<< "$ng" > /dev/null; then
        jq -c --arg group "$metrics_group" --arg ng_name "$ng_name" \
          '.group = $group | .labels = {"name": $ng_name}' \
          <<< '{"name": "d8_node_group_internal_network_cidrs", "set": 1}' \
          >> $METRICS_PATH
      fi

      if values::has nodeManager.internal.static.internalNetworkCIDRs ; then
        cidrs=$(values::get nodeManager.internal.static)
        ng=$(jq -r --argjson cidrs "$cidrs" '.static = $cidrs' <<< "$ng")
      fi
    fi

    # If nodeType is "Cloud" and cloud provider exists
    if (jq -e '.nodeType == "Cloud"' <<< "$ng" > /dev/null) && [ -n "$instance_class_kind" ]; then
      instance_classes="$(context::jq -r '
        [.snapshots.ics[]] | reduce .[] as $i ({}; . + {($i.filterResult.name): $i.filterResult.spec})
      ')"

      # check #1 — is .spec.cloudInstances.classReference.kind allowed in our cluster
      ng_instance_class_kind=$(jq -r '.cloudInstances.classReference.kind' <<< "$ng")
      if [[ "$ng_instance_class_kind" != "$instance_class_kind" ]] ; then
        error_message="Wrong classReference: Kind $ng_instance_class_kind is not allowed, the only allowed kind is $instance_class_kind."

        if
          values::has nodeManager.internal.nodeGroups && \
          earlier_stored_ng="$(values::jq -er --arg ng_name "${ng_name}" '.nodeManager.internal.nodeGroups[] | select(.name == $ng_name)')"
        then
          final_node_groups="$(jq --argjson ng "$earlier_stored_ng" '. + [$ng]' <<< $final_node_groups)"
          error_message="$error_message Earlier stored version of NG is in use now!"
        fi

        >&2 echo "ERROR: Bad NodeGroup $ng_name: $error_message"
        _set_ng_error_status "${ng_name}" "${error_message}"
        continue
      fi

      # check #2 — is .spec.cloudInstances.classReference valid
      ng_instance_class_name=$(jq -r '.cloudInstances.classReference.name' <<< "$ng")
      if jq -e '. | has("'$ng_instance_class_name'") | not' <<< "$instance_classes" > /dev/null; then
        error_message="Wrong classReference: There is no valid instance class $ng_instance_class_name of type $ng_instance_class_kind."

        if
          values::has nodeManager.internal.nodeGroups && \
          earlier_stored_ng="$(values::jq -er --arg ng_name "${ng_name}" '.nodeManager.internal.nodeGroups[] | select(.name == $ng_name)')"
        then
          final_node_groups="$(jq --argjson ng "$earlier_stored_ng" '. + [$ng]' <<< $final_node_groups)"
          error_message="$error_message Earlier stored version of NG is in use now!"
        fi

        >&2 echo "ERROR: Bad NodeGroup $ng_name: $error_message"
        _set_ng_error_status "${ng_name}" "${error_message}"
        continue
      fi

      # check #3 — are zones valid
      if [ "$default_zones" != "[]" ]; then
        if jq --argjson default_zones "$default_zones" -e '.cloudInstances.zones as $zones | ($zones | length) > 0 and ($default_zones | contains($zones) | not) ' <<< "$ng"; then
          error_message="unknown zones."
          >&2 echo "ERROR: Bad NodeGroup $ng_name: $error_message"
          _set_ng_error_status "${ng_name}" "${error_message}"
          continue
        fi
      fi

      ng_instance_class="$(jq --arg name $ng_instance_class_name '.[$name]' <<< "$instance_classes")"
      ng="$(jq \
        --argjson instance_class "${ng_instance_class}" \
        --argjson default_zones "${default_zones}" \
        '.instanceClass = $instance_class | .cloudInstances.zones //= $default_zones' <<< "$ng")"

      if [ "$default_zones" != "[]" ]; then
        ng="$(jq --argjson default_zones "$default_zones" '.cloudInstances.zones //= $default_zones' <<< "$ng")"
      fi
    fi

    # Calculate effective version
    effective_kubernetes_version="$global_target_kubernetes_version"
    if jq -e '.kubernetesVersion != null' <<< "$ng" > /dev/null; then
      effective_kubernetes_version="$(jq -r '.kubernetesVersion' <<< "$ng")"

      # If kubernetesVersion IS specified in NodeGroup, we don't allow Nodes
      # to be more than 2 version befind control plane
      if semver::lt "$effective_kubernetes_version" "$(semver::unbump_minor "$(semver::unbump_minor "$control_plane_max_kubernetes_version")")" ; then
        effective_kubernetes_version="$(semver::unbump_minor "$(semver::unbump_minor "$control_plane_max_kubernetes_version")")"
      fi
    else
      # If kubernetesVersion is NOT specified in NodeGroup, we don't allow Nodes
      # to be more than 1 version befind control plane
      if semver::lt "$effective_kubernetes_version" "$(semver::unbump_minor "$control_plane_max_kubernetes_version")" ; then
        effective_kubernetes_version="$(semver::unbump_minor "$control_plane_max_kubernetes_version")"
      fi
    fi
    if semver::gt "$effective_kubernetes_version" "$control_plane_min_kubernetes_version" ; then
      # Nodes should not be above control plane
      effective_kubernetes_version="$control_plane_min_kubernetes_version"
    fi

    ng="$(jq --arg effective_kubernetes_version "$effective_kubernetes_version" '.kubernetesVersion = $effective_kubernetes_version' <<< "$ng")"

    # detect cri
    default_cri="Docker"
    if values::has global.clusterConfiguration.defaultCRI ; then
      default_cri="$(values::get global.clusterConfiguration.defaultCRI)"
    fi

    cri="$(jq -r '.cri.type' <<< "$ng")"

    # Check if cri is set, or set to global cri
    if [ "$cri" == "null" ]; then
      cri="$default_cri"
    fi

    case $cri in
    "Docker")
    # Check if cri set to Docker and docker.manage set to false
    if ! jq -e 'if .docker.manage == null then true else .docker.manage end' <<< "$ng" >/dev/null; then
      cri="NotManaged"
    fi
    ;;
    "Containerd")
      # Check if cri is set to Containerd kubernetes version must be 1.19+
    if semver::lt "$effective_kubernetes_version" "1.19" ; then
      >&2 echo "ERROR: Containerd cri allowed only for kubernetes 1.19+."
      return 1
    fi
    ;;
    esac

    ng="$(jq --arg cri "$cri" '.cri.type = $cri' <<< "$ng")"

    # Calculate update epoch
    seedMD5="$(md5sum <<< "$(values::get global.discovery.clusterUUID)${ng_name}" | cut -f1 -d" ")"
    update_epoch=$(awk -v seed="$seedMD5" -v timestamp="$timestamp" \
      'BEGIN{srand(seed); printf("%d\n", ((rand() * 14400) + timestamp) / 14400)}'
    )
    ng="$(jq --arg update_epoch "$update_epoch" '.updateEpoch = $update_epoch' <<< "$ng")"

    _set_ng_error_status "${ng_name}" ""
    final_node_groups="$(jq --argjson ng "$ng" '. + [$ng]' <<< $final_node_groups)"
  done

  values::set nodeManager.internal.nodeGroups "$final_node_groups"
}

hook::run "$@"
