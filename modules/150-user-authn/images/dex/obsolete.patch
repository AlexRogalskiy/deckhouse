diff --git a/server/handlers.go b/server/handlers.go
index 694ababb..e2e882ec 100644
--- a/server/handlers.go
+++ b/server/handlers.go
@@ -963,7 +963,8 @@ func (s *Server) handleRefreshToken(w http.ResponseWriter, r *http.Request, clie
 		s.tokenErrHelper(w, errInvalidRequest, "Refresh token is invalid or has already been claimed by another client.", http.StatusBadRequest)
 		return
 	}
-	if refresh.Token != token.Token {
+
+	if refresh.Token != token.Token && refresh.ObsoleteToken != token.Token {
 		s.logger.Errorf("refresh token with id %s claimed twice", refresh.ID)
 		s.tokenErrHelper(w, errInvalidRequest, "Refresh token is invalid or has already been claimed by another client.", http.StatusBadRequest)
 		return
@@ -1013,12 +1014,6 @@ func (s *Server) handleRefreshToken(w http.ResponseWriter, r *http.Request, clie
 		connectorData = session.ConnectorData
 	}

-	conn, err := s.getConnector(refresh.ConnectorID)
-	if err != nil {
-		s.logger.Errorf("connector with ID %q not found: %v", refresh.ConnectorID, err)
-		s.tokenErrHelper(w, errServerError, "", http.StatusInternalServerError)
-		return
-	}
 	ident := connector.Identity{
 		UserID:            refresh.Claims.UserID,
 		Username:          refresh.Claims.Username,
@@ -1029,19 +1024,32 @@ func (s *Server) handleRefreshToken(w http.ResponseWriter, r *http.Request, clie
 		ConnectorData:     connectorData,
 	}

-	// Can the connector refresh the identity? If so, attempt to refresh the data
-	// in the connector.
-	//
-	// TODO(ericchiang): We may want a strict mode where connectors that don't implement
-	// this interface can't perform refreshing.
-	if refreshConn, ok := conn.Connector.(connector.RefreshConnector); ok {
-		newIdent, err := refreshConn.Refresh(r.Context(), parseScopes(scopes), ident)
+	currentTime := s.now()
+	isExpiredObsoleteToken := refresh.ObsoleteToken == token.Token && currentTime.After(refresh.LastUsed.Add(s.idTokensValidFor / 4))
+	isNonObsoleteToken := refresh.ObsoleteToken != token.Token
+
+	if isExpiredObsoleteToken || isNonObsoleteToken {
+		conn, err := s.getConnector(refresh.ConnectorID)
 		if err != nil {
-			s.logger.Errorf("failed to refresh identity: %v", err)
+			s.logger.Errorf("connector with ID %q not found: %v", refresh.ConnectorID, err)
 			s.tokenErrHelper(w, errServerError, "", http.StatusInternalServerError)
 			return
 		}
-		ident = newIdent
+
+		// Can the connector refresh the identity? If so, attempt to refresh the data
+		// in the connector.
+		//
+		// TODO(ericchiang): We may want a strict mode where connectors that don't implement
+		// this interface can't perform refreshing.
+		if refreshConn, ok := conn.Connector.(connector.RefreshConnector); ok {
+			newIdent, err := refreshConn.Refresh(r.Context(), parseScopes(scopes), ident)
+			if err != nil {
+				s.logger.Errorf("failed to refresh identity: %v", err)
+				s.tokenErrHelper(w, errServerError, "", http.StatusInternalServerError)
+				return
+			}
+			ident = newIdent
+		}
 	}

 	claims := storage.Claims{
@@ -1067,10 +1075,11 @@ func (s *Server) handleRefreshToken(w http.ResponseWriter, r *http.Request, clie
 		return
 	}

-	newToken := &internal.RefreshToken{
-		RefreshId: refresh.ID,
-		Token:     storage.NewID(),
+	newToken := token
+	if isExpiredObsoleteToken || isNonObsoleteToken {
+		newToken.Token = storage.NewID()
 	}
+
 	rawNewToken, err := internal.Marshal(newToken)
 	if err != nil {
 		s.logger.Errorf("failed to marshal refresh token: %v", err)
@@ -1078,47 +1087,50 @@ func (s *Server) handleRefreshToken(w http.ResponseWriter, r *http.Request, clie
 		return
 	}

-	lastUsed := s.now()
-	updater := func(old storage.RefreshToken) (storage.RefreshToken, error) {
-		if old.Token != refresh.Token {
-			return old, errors.New("refresh token claimed twice")
+	if isExpiredObsoleteToken || isNonObsoleteToken {
+		lastUsed := currentTime
+		updater := func(old storage.RefreshToken) (storage.RefreshToken, error) {
+			if old.Token != refresh.Token {
+				return old, errors.New("refresh token claimed twice")
+			}
+			old.ObsoleteToken = old.Token
+			old.Token = newToken.Token
+			// Update the claims of the refresh token.
+			//
+			// UserID intentionally ignored for now.
+			old.Claims.Username = ident.Username
+			old.Claims.PreferredUsername = ident.PreferredUsername
+			old.Claims.Email = ident.Email
+			old.Claims.EmailVerified = ident.EmailVerified
+			old.Claims.Groups = ident.Groups
+			old.LastUsed = lastUsed
+
+			// ConnectorData has been moved to OfflineSession
+			old.ConnectorData = []byte{}
+			return old, nil
 		}
-		old.Token = newToken.Token
-		// Update the claims of the refresh token.
-		//
-		// UserID intentionally ignored for now.
-		old.Claims.Username = ident.Username
-		old.Claims.PreferredUsername = ident.PreferredUsername
-		old.Claims.Email = ident.Email
-		old.Claims.EmailVerified = ident.EmailVerified
-		old.Claims.Groups = ident.Groups
-		old.LastUsed = lastUsed
-
-		// ConnectorData has been moved to OfflineSession
-		old.ConnectorData = []byte{}
-		return old, nil
-	}
-
-	// Update LastUsed time stamp in refresh token reference object
-	// in offline session for the user.
-	if err := s.storage.UpdateOfflineSessions(refresh.Claims.UserID, refresh.ConnectorID, func(old storage.OfflineSessions) (storage.OfflineSessions, error) {
-		if old.Refresh[refresh.ClientID].ID != refresh.ID {
-			return old, errors.New("refresh token invalid")
+
+		// Update LastUsed time stamp in refresh token reference object
+		// in offline session for the user.
+		if err := s.storage.UpdateOfflineSessions(refresh.Claims.UserID, refresh.ConnectorID, func(old storage.OfflineSessions) (storage.OfflineSessions, error) {
+			if old.Refresh[refresh.ClientID].ID != refresh.ID {
+				return old, errors.New("refresh token invalid")
+			}
+			old.Refresh[refresh.ClientID].LastUsed = lastUsed
+			old.ConnectorData = ident.ConnectorData
+			return old, nil
+		}); err != nil {
+			s.logger.Errorf("failed to update offline session: %v", err)
+			s.tokenErrHelper(w, errServerError, "", http.StatusInternalServerError)
+			return
 		}
-		old.Refresh[refresh.ClientID].LastUsed = lastUsed
-		old.ConnectorData = ident.ConnectorData
-		return old, nil
-	}); err != nil {
-		s.logger.Errorf("failed to update offline session: %v", err)
-		s.tokenErrHelper(w, errServerError, "", http.StatusInternalServerError)
-		return
-	}

-	// Update refresh token in the storage.
-	if err := s.storage.UpdateRefreshToken(refresh.ID, updater); err != nil {
-		s.logger.Errorf("failed to update refresh token: %v", err)
-		s.tokenErrHelper(w, errServerError, "", http.StatusInternalServerError)
-		return
+		// Update refresh token in the storage.
+		if err := s.storage.UpdateRefreshToken(refresh.ID, updater); err != nil {
+			s.logger.Errorf("failed to update refresh token: %v", err)
+			s.tokenErrHelper(w, errServerError, "", http.StatusInternalServerError)
+			return
+		}
 	}

 	s.writeAccessToken(w, idToken, accessToken, rawNewToken, expiry)
diff --git a/storage/kubernetes/types.go b/storage/kubernetes/types.go
index 5eda1781..787ff88b 100644
--- a/storage/kubernetes/types.go
+++ b/storage/kubernetes/types.go
@@ -448,7 +448,8 @@ type RefreshToken struct {
 	ClientID string   `json:"clientID"`
 	Scopes   []string `json:"scopes,omitempty"`

-	Token string `json:"token,omitempty"`
+	Token         string `json:"token,omitempty"`
+	ObsoleteToken string `json:"obsoleteToken,omitempty"`

 	Nonce string `json:"nonce,omitempty"`

@@ -468,6 +469,7 @@ func toStorageRefreshToken(r RefreshToken) storage.RefreshToken {
 	return storage.RefreshToken{
 		ID:            r.ObjectMeta.Name,
 		Token:         r.Token,
+		ObsoleteToken: r.ObsoleteToken,
 		CreatedAt:     r.CreatedAt,
 		LastUsed:      r.LastUsed,
 		ClientID:      r.ClientID,
@@ -490,6 +492,7 @@ func (cli *client) fromStorageRefreshToken(r storage.RefreshToken) RefreshToken
 			Namespace: cli.namespace,
 		},
 		Token:         r.Token,
+		ObsoleteToken: r.ObsoleteToken,
 		CreatedAt:     r.CreatedAt,
 		LastUsed:      r.LastUsed,
 		ClientID:      r.ClientID,
diff --git a/storage/storage.go b/storage/storage.go
index 5bbb2b3f..cccc6366 100644
--- a/storage/storage.go
+++ b/storage/storage.go
@@ -230,7 +230,8 @@ type RefreshToken struct {
 	// A single token that's rotated every time the refresh token is refreshed.
 	//
 	// May be empty.
-	Token string
+	Token         string
+	ObsoleteToken string

 	CreatedAt time.Time
 	LastUsed  time.Time
