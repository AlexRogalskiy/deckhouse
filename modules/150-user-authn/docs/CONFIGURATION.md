---
title: "Модуль user-authn: конфигурация"
---

Модуль по умолчанию **выключен**. Для включения добавьте в CM `deckhouse`:

```yaml
data:
  userAuthnEnabled: "true"
```

## Параметры

* `providers` — настройки провайдеров аутентификации:
  * `id` — уникальный идентификатор провайдера аутентификации;
  * `name` — имя провайдера, которое будет отображено на странице выбора провайдера для аутентификации (если настроен всего один – эта страница не будет показана);
  * `type` — тип внешнего провайдера, в данный момент поддерживается 6 типов: `Github`, `Gitlab`, `BitbucketCloud`, `Crowd`, `OIDC`, `LDAP`;
  * `github` – параметры провайдера Github (можно указывать только если `type: Github`; как [настроить Github](usage.html#создание-приложения-в-github-организации-для-аутентификации-в-кластере)):
    * `clientID` — ID организации на Github;
    * `clientSecret` — secret организации на Github;
    * `orgs` — массив названий организаций в Github;
        * `name` — название организации;
        * `teams` — массив команд, допустимых для приема из Github'а, токен пользователя будет содержать объединенное множество команд из Github'а и команд из этого списка (если множество окажется пустым, авторизация будет считаться не успешной), если параметр не указан, токен пользователя будет содержать все команды из Github'а;
    * `teamNameField` — данная опция отвечает за формат команд, которые будут получены из github. Может быть одним из трех вариантов: `name` (default), `slug`, `both`.
      * Если в организации `acme` есть группа `Site Reliability Engineers`, то в случае:
        * `name` будет получена группа с именем `['acme:Site Reliability Engineers']`;
        * `slug` будет получена группа с именем `['acme:site-reliability-engineers']`;
        * `both` будут получены группы с именами `['acme:Site Reliability Engineers', 'acme:site-reliability-engineers']`.
    * `useLoginAsID` — данная опция позволяет вместо использования внутреннего github id, использовать имя пользователя. 
  * `gitlab` – параметры провайдера Gitlab (можно указывать только если `type: Gitlab`; как [настроить Gitlab](usage.html#создание-приложения-в-gitlab-для-аутентификации-в-кластере)):
    * `clientID` — ID приложения созданного в Gitlab;
    * `clientSecret` — secret приложения созданного в Gitlab;
    * `baseURL` — адрес Gitlab'а (например: `https://fox.flant.com`);
    * `groups` — массив групп, допустимых для приема из Gitlab'а, токен пользователя будет содержать объединенное множество групп из Gitlab'а и групп из этого списка (если множество окажется пустым, авторизация будет считаться не успешной), если параметр не указан, токен пользователя будет содержать все группы из Gitlab'а;
        * Массив групп Gitlab содержит пути групп (path), а не их имена.
  * `bitbucketCloud` – параметры провайдера Bitbucket Cloud (можно указывать только если `type: BitbucketCloud`); 
    * `clientID` — ID приложения созданного в Bitbucket Cloud;
    * `clientSecret` — secret приложения созданного в Bitbucket Cloud;
    * `teams` — массив комманд, допустимых для приема из Bitbucket Cloud'а, токен пользователя будет содержать объединенное множество комманд из Bitbucket Cloud'а и комманд из этого списка (если множество окажется пустым, авторизация будет считаться не успешной), если параметр не указан, токен пользователя будет содержать все комманды из  Bitbucket Cloud'а;
        * Токен будет содержать команды пользователя в claim'е `groups`, как и у других провайдеров.
    * `includeTeamGroups` — при включении данной опции в список команд будут включены все группы команды, в которых состоит пользователь.
        * По-умолчанию `false`.
        * Пример групп пользователя с включенной опцией:
          ```yaml
          groups=["my_team", "my_team/administrators", "my_team/members"]
          ```
  * `crowd` – параметры провайдера Crowd (можно указывать только если `type: Crowd`; как [настроить Crowd](usage.html#создание-приложения-в-crowd-для-аутентификации-в-кластере)):
    * `baseURL` – адрес Crowd'а (например: `https://crowd.example.com/crowd`);
    * `clientID` – ID приложения созданного в Crowd;
    * `clientSecret` – пароль приложения созданного в Crowd;
    * `groups` – массив групп, допустимых для приема из Crowd'а, токен пользователя будет содержать объединенное множество групп из Crowd'а и групп из этого списка (если множество окажется пустым, авторизация будет считаться не успешной), если параметр не указан, токен пользователя будет содержать все группы из Crowd'а;
    * `usernamePrompt` – строка, которая будет отображаться возле поля для имени пользователя в форме ввода логина и пароля.
        * По-умолчанию `Crowd username`.
    * `enableBasicAuth` – включает возможность basic авторизации для kubernetes api server, в качестве credentials для basic авторизации указываются логин и пароль пользователя из приложения, созданного в Crowd (возможно включить при указании только одного провайдера с типом Crowd), работает ТОЛЬКО при включенном `publishAPI`, полученные от Crowd данные авторизации и групп сохраняются в кэш на 10 секунд; 
  * `ldap` – параметры провайдера LDAP (можно указывать только если `type: LDAP`):
    * `host` — адрес (и опционально порт) для LDAP-сервера;
    * `ca` — CA, используемый для валидации TLS;
    * `insecureSkipVerify` — при включении данной опции не происходит проверка подлинности ответа от провайдера с помощью `ca`;
      * По-умолчанию `false`.
    * `bindDN` — путь до сервис-аккаунта приложения в LDAP (пример: `uid=seviceaccount,cn=users,dc=example,dc=com`);
    * `bindPW` — пароль для сервис-аккаунта приложения в LDAP;
    * `startTLS` — использовать ли [STARTTLS](https://www.digitalocean.com/community/tutorials/how-to-encrypt-openldap-connections-using-starttls) для шифрования;
      * По-умолчанию `false`.
    * `userSearch` — настройки фильтра пользователей, которые помогают сначала отфильтровать директории, в которых будет производится поиск пользователей, а затем найти пользователя по полям (его имени, адресу электронной почты или отображаемому имени), [подробнее о процессе фильтрации можно прочитать в документации](https://github.com/dexidp/dex/blob/3b7292a08fd2c61900f5e6c67f3aa2ee81827dea/Documentation/connectors/ldap.md#example-mapping-a-schema-to-a-search-config):
      * `baseDN` — откуда будет начат поиск пользователей (пример: `cn=users,dc=example,dc=com`)
      * `filter` — опциональное поле, которое позволяет добавить фильтр для директории с пользователями (пример: `(objectClass=person)`);
      * `username` — имя атрибута из которого будет получен username пользователя (пример: `uid`);
      * `idAttr` — имя атрибута из которого будет получен идентификатор пользователя (пример: `uid`);
      * `emailAttr` — имя атрибута из которого будет получен email пользователя (пример: `mail`, указывать обязательно);
      * `nameAttr` — атрибут отображаемого имени пользователя (пример: `name`);
    * `groupSearch` — настройки фильтра для поиска групп для указанного пользователя, [подробнее о процессе фильтрации можно прочитать в документации](https://github.com/dexidp/dex/blob/3b7292a08fd2c61900f5e6c67f3aa2ee81827dea/Documentation/connectors/ldap.md#example-mapping-a-schema-to-a-search-config):
      * `baseDN` — откуда будет начат поиск групп (пример: `cn=groups,dc=freeipa,dc=example,dc=com`);
      * `filter` — опциональное поле, которое позволяет добавить фильтр для директории с группами (пример: `(objectClass=group)`);
      * `nameAttr` — имя атрибута, в котором хранится уникальное имя группы (пример: `name`);
      * `userAttr` — имя атрибута, в котором хранится имя пользователя (пример: `uid`); 
      * `groupAttr` — имя атрибута, в котором хранятся имена пользователей, состоящих в группе (пример: `member`);
  * `oidc` — параметры провайдера OIDC (можно указывать только если `type: OIDC`):
    * `issuer` — адрес провайдера (пример: `https://accounts.google.com`);
    * `clientID` – ID приложения, созданного в OIDC провайдере;
    * `clientSecret` – пароль приложения, созданного в OIDC провайдере;
    * `basicAuthUnsupported` — включение этого параметра означает, что dex для общения с провайдером будет использовать POST запросы вместо добавления токена в Basic Authorization header (в большинстве случаев dex сам определяет, какой запрос ему нужно сделать, но иногда включение этого параметра может помочь);
      * По-умолчанию `false`.
    * `insecureSkipEmailVerified` — при включении данной опции dex перестает обращать внимание на информацию о том, подтвержден e-mail пользователя или нет (как именно подтверждается e-mail решает сам провайдер, в ответе от провайдера приходит лишь информация, подтвержден e-mail или нет);
      * По-умолчанию `false`.
    * `getUserInfo` — запрашивать ли дополнительные данные об успешно подключенном пользователе, подробнее о механизме можно прочитать [здесь](https://openid.net/specs/openid-connect-core-1_0.html#UserInfo));
      * По-умолчанию `false`.
    * `scopes` — список [полей](https://github.com/dexidp/website/blob/main/content/docs/custom-scopes-claims-clients.md#scopes) для включения в ответ при запросе токена;
      * По-умолчанию `["openid", "profile", "email", "groups", "offline_access"]`
    * `userIDKey` — [Claim](https://openid.net/specs/openid-connect-core-1_0.html#Claims), который будет использован для получения ID пользователя;
      * По-умолчанию `sub`.
    * `userNameKey` — [Claim](https://openid.net/specs/openid-connect-core-1_0.html#Claims), который будет использован для получения имени пользователя;
      * По-умолчанию `name`.  
* `publishAPI` — настройки публикации API-сервера, чeрез ingress:
  * `enable` — если выставить данный параметр в `true`, то в кластере будет создан ingress в namespace d8-user-authn, который выставляет Kubernetes API наружу.
    * По-умолчанию: `false`.
  * `ingressClass` — ingress-класс, который будет использован для публикации API kubernetes через ingress.
  * `whitelistSourceRanges` — массив CIDR, которым разрешено подключение к API.
    * Если параметр не указан, подключение к API не ограничивается по IP.
  * `https` — режим работы https для ingress'а API-сервера:
    * `mode` — режим выдачи сертификатов для данного ingress ресурса. Возможные значения `SelfSigned` и `Global`. В случае использования режима `SelfSigned` для ingress ресурса будет выпущен самоподписанный сертификат. В случае использования `Global` будут применены политики из глобальной настройки `global.modules.https.mode`. Т.е. если в глобальной настройке стоит режим `CertManager` с clusterissuer `letsencrypt`, то для ingress ресурса будет заказан сертификат Lets Encrypt.
      * По-умолчанию: `SelfSigned`
    * `global` — дополнительный параметр для режима `Global`;
      * `kubeconfigGeneratorMasterCA` — если у вас перед ingress'ом есть внешний балансер, который терминирует HTTPS трафик, то тут необходимо вставить CA от сертификата на балансировщике, что бы kubectl мог достучаться до API-сервера; 
          * В качестве CA можно указать сам сертификат с внешнего балансера, если по какой-то причине вы не можете получить подписавший его CA. Но нужно помнить, что после обновления сертификата на балансере сгенерированные ранее kubeconfig'и перестанут работать.
* `kubeconfigGenerator` — массив, в котором указываются дополнительные возможные способы доступа к API. Это может быть полезно, в случае если вы не хотите предоставить доступ к API-кластера через ingress, а хотите предоставить доступ другими способами (например, с бастион-хоста или через OpenVPN).
  * `id` — имя способа доступа к API-серверу (без пробелов, маленькими буквами);
  * `masterURI` — адрес API-сервера;
    * Если вы планируете использовать TCP прокси, то для адреса TCP-прокси должен быть сконфигурирован сертификат на стороне API-сервера. Например, в случае, если у вас API-сервера'а слушают на трех разных адресах (`192.168.0.10`, `192.168.0.11` и `192.168.0.12`), а ходить к API-серверу клиент будет, через TCP-балансер (пусть будет `192.168.0.15`), то вам необходимо перегенерировать сертификаты для API-серверов:
      * отредактировать `kubeadm-config`: `kubectl -n kube-system edit configmap kubeadm-config` добавив в `.apiServer.certSANs` адрес `192.168.0.15`;
      * сохранить получившийся конфиг: `kubeadm config view > kubeadmconf.yaml`;
      * удалить старые сертификаты API-сервера: `mv /etc/kubernetes/pki/apiserver.* /tmp/`;
      * перевыпустить новые сертификаты: `kubeadm init phase certs apiserver --config=kubeadmconf.yaml`;
      * перезапустить контейнер с API-сервером: `docker ps -a | grep 'kube-apiserver' | grep -v pause| awk '{print $1}' | xargs docker restart`;
      * повторить данное действие для всех мастеров.
  * `masterCA` — CA для доступа к API.
    * Если данный параметр не указать, то будет автоматически использован Kubernetes CA.
    * При публикации через HTTP-прокси, который терминирует HTTPS трафик, рекомендуется использовать самоподписанный сертификат, который и указать в настоящем параметре.
  * `description` — описание способа доступа к API-серверу, которое показывается пользователю (в списке).
* `idTokenTTL` — данный параметр отвечает за время жизни id токена (указывается с суффиксом s, m или h);
  * По-умолчанию — 10 минут.
  * Пример: `1h`
* `highAvailability` — ручное управление режимом отказоустойчивости.
* `nodeSelector` — как в Kubernetes в `spec.nodeSelector` у pod'ов.
    * Если ничего не указано — будет использоваться значение `{"node-role.deckhouse.io/vsphere-csi-driver":""}` или `{"node-role.deckhouse.io/system":""}` (если в кластере есть такие узлы) или ничего не будет указано.
    * Можно указать `false`, чтобы не добавлять никакой nodeSelector.
* `tolerations` — как в Kubernetes в `spec.tolerations` у pod'ов.
    * Если ничего не указано — будет настроено значение `[{"key":"dedicated.deckhouse.io","operator":"Equal","value":"vsphere-csi-driver"},{"key":"dedicated.deckhouse.io","operator":"Equal","value":"system"}]`.
    * Можно указать `false`, чтобы не добавлять никакие toleration'ы.
* `ingressClass` — класс Ingress-контроллера, который используется для dex и kubeconfig-generator.
  * Опциональный параметр, по умолчанию используется глобальное значение `modules.ingressClass`.
* `https` — выбираем, какой тип сертификата использовать для dex и kubeconfig-generator.
  * При использовании этого параметра полностью переопределяются глобальные настройки `global.modules.https`.
  * `mode` — режим работы HTTPS:
    * `Disabled` — при данном значении модуль автоматически отключается.
    * `CertManager` — dex и kubeconfig-generator будут работать по https и заказывать сертификат с помощью clusterissuer заданном в параметре `certManager.clusterIssuerName`;
    * `CustomCertificate` — dex и kubeconfig-generator будут работать по https используя сертификат из namespace `d8-system`;
    * `OnlyInURI` — dex и kubeconfig-generator будут работать по http (подразумевая, что перед ними стоит внешний https балансер, который терминирует https) и все ссылки в `user-authn` будут генерироваться с https схемой.
  * `certManager`
    * `clusterIssuerName` — указываем, какой ClusterIssuer использовать для dex и kubeconfig-generator (в данный момент доступны `letsencrypt`, `letsencrypt-staging`, `selfsigned`, но вы можете определить свои).
  * `customCertificate`
    * `secretName` — указываем имя secret'а в namespace `d8-system`, который будет использоваться для dex и kubeconfig-generator (данный секрет должен быть в формате [kubernetes.io/tls](https://kubernetes.github.io/ingress-nginx/user-guide/tls/#tls-secrets)).
* `controlPlaneConfigurator` — настройки параметров для модуля автоматической настройки kube-apiserver [control-plane-configurator](/modules/160-control-plane-configurator/).
  * `enabled` — использовать ли control-plane-configurator для настройки OIDC в kube-apiserver.
    * По-умолчанию `true`.
  * `dexCAMode` — как вычислить CA, который будет использован при настройке kube-apiserver.
    * Значения:
      * `FromIngressSecret` — извлечь CA или сам сертификат из секрета, который используется в ингрессе. Если вы используете самоподписанные сертификаты на ингрессах — это ваш вариант.
      * `Custom` — использовать CA указанный явно, в параметре `dexCustomCA` (см. ниже). Этот вариант уместен, например, если вы используете внешний https-балансер перед ингрессами и на этом балансировщике используется самоподписанный сертификат.
      * `DoNotNeed` — CA не требуется (например, при использовании публичного LE или других TLS-провайдеров).
    * По-умолчанию — `DoNotNeed`.
  * `dexCustomCA` — CA, которая будет использована в случае `dexCAMode` = `Custom`.
    * Формат — обычный текст, без base64.
    * Необязательный параметр.

Автоматический деплой [oauth2-proxy](https://github.com/pusher/oauth2_proxy) в namespace вашего приложения и подключения его к dex происходит при создании Custom Resource [`DexAuthenticator`](cr.html#dexauthenticator).
