Разработка графиков Grafana
===========================

Общая информация
----------------

1. Dashboard'ы лежат в директории [grafana_dashboards](../grafana-dashboards/), при этом:
    * каждая поддиректория в этой директории соответствует Folder'у в Grafana,
    * а каждый файл — Dashboard'у в Grafana.
2. Если нужно добавить новый Folder, то, кроме создания поддиректории, необходимо поправить [хелпер](../templates/grafana/_dashboards_helpers.tpl) (там есть кортеж имен поддиректорий).
3. Править Dashboard'ы в файлах не нужно (если только это не какая-то совсем простая правка), вместо этого:
    * Открываем Dashboard в Grafana:
        * если это один из существующих — открываем его и [нажимаем кнопку Make editable](img/grafana_make_editable.jpg);
        * если это новый — его необходимо просто создать (в любом Folder, это не важно, он потом переедет в тот, в который будет положен в репозитарии);
        * если это чужой готовый Dashboard — его можно импортировать в Grafana (там есть кнопка Import).
    * Меняем, меняем, меняем... до тех пор, пока не станем довольны Dasboard'ом. Лучше периодически нажимать на кнопку сохранить в Grafana чтобы, если браузер упадет, не потерять изменения.
    * [Выгружаем Dashboard в JSON](img/grafana_export.jpg) и сохраняем в файл (новый или существующий).
4. Можно менять название Dashboard'а, название файла, переносить файл между Folder'ами — все подцепится автоматически.

### Как быстро привести чужой dashboard более-менее в порядок?

1. Найти все range'и и заменить на `$__interval_rv`:

    ```bash
    for range in $(grep '\[[0-9]\+[a-z]\]' $dashboard | sed 's/.*\(\[[0-9][a-z]\]\).*/\1/g' | sort | uniq); do
      sed 's/\['$range'\]/[$__interval_rv]/g' -i $dashboard
    end
    ```
2. Заменить `irate` на `rate`

    ```bash
    sed 's/irate(/rate(/g' -i $dashboard
    ```
3. Заменить `Resolution` на `1/1`

    ```bash
    sed 's/"intervalFactor":\s[0-9]/"intervalFactor": 1/' -i $dashboard
    ```
4. Убрать `Min Step`

    ```bash
    sed 'd/"interval":/' -i $dashboard
    ```
5. Заменить все графики на `Staircase` (поломает графики `Stack` + `Percent`, которые придется поправить руками на `Bars`)

    ```bash
    sed 's/"steppedLine": false/"steppedLine": true/' -i $dashboard
    ```

Лучшие практики
---------------

### Сохраняйте uid Dashboard'а

При любых изменениях (в том числе при переименовании и переносе между Folder'ами) сохраняйте uid Dashboard'а (он обычно на одной из последних строк в JSON-файле). В этом случае все старые ссылки продолжат работать. Для этого никаких специальных действий не требуется, просто не меняйте намерено.

### Следите за изменениями в JSON-файлах

Редактировать JSON-файлы напрямую не стоит (это неудобно), а вот после внесения изменений в интерфейсе Grafana и выгрузки JSON-файла — обязательно стоит внимательно посмотреть, что изменилось, чтобы удостовериться, что случайно не поправили лишнего. Для этого есть `git add -p` и diff'ы в MR'ах, кому как удобней.

При изменении сложных Dashboard'ов, использующих функционал шаблонизирования, старайтесь редактировать Dashboard там же, где он был создан (обычно это https://prometheus.kube.domain.my/) и с теми же значениями в Variables — тогда в MR'е не будет множества лишних изменений "динамических данных".

### Что делать если мне нужно при отсутствии данных "прятать" дашборд или часть дашборда?

Не нужно пытаться генерировать Grafana Dashboard средствами Helm'а. Лучше заведите Issue в Grafana, чтобы сделали поддержку такого функционала.

Требования к Dashboard'ам
-------------------------

### Job должен быть явно указан

Как и при разработке правил для Prometheus, необходимо всегда [явно указывать job](PROMETHEUS_RULES_DEVELOPMENT.md#Всегда-явно-указывать-job), чтобы гарантированно избежать конфликтов в именах метрик.

### Prometheus должен выбираться

В наших Grafana может быть доступно несколько Prometheus'ов (с разной степенью детализации данных и разным периодом хранения), а значит должна быть возможность удобного выбора сервера Prometheus. Чтобы это сделать, нужно:
* [создать](img/grafana_ds_prometheus_variable.jpg) переменную `$ds_prometheus`
* в каждой панели [указать](img/grafana_ds_prometheus_select_in_panel.jpg) именно `$ds_prometheus` в качестве Datasource, а не один из конкретных Prometheus'ов

### Graph Tooltip должен быть в режиме Shared crosshair


Одна из важнейших возможностей, которую предоставляют графики — возможность визуального анализа корреляций. Но чтобы проводить такой анализ — нужно сопоставлять одну точку во времени на разных графиках, и если графики все одного размера и показаны друг под другом — это не создает проблем, но делать все графики одного размера не всегда возможно (и всегда некрасиво).

[Включайте](img/grafana_graph_tooltip.jpg) Graph Tooltip всегда в режим Shared crosshair — он очень сильно помогает в визуальном анализе корреляций: стоит только навести мышь на один график, как на всех остальных появится полоса показывающая это время.

Использовать более навороченный режим Shared tooltip не рекомендуется, так как он перегружает лишней информацией.

### Единица измерения — это очень важно

График, на котором не указана единица измерения, всегда вводит в заблуждение! Что показано на графике — rpm или rps, биты или байты, ...? Всегда, когда вы смотрите на график, вы задаете вопрос — "Что показано на этом графике?", на который и отвечает правильно проставленная единица измерения. В Grafana есть возможность четко указать единицу измерения и это обязательно нужно делать.

Кроме этого, старайтесь использовать общепринятые единицы измерения, например:
* Скорость передачи данных принято измерять в битах в секунду, а не в байтах в секунду;
* Количество операций — обычно указывают в секунду, а не в минуту (iops, rps и пр.);
* Объем данных — всегда измеряют в байтах, а не в битах.

### Точность данных и детализация

Конечно бывают случаи, когда степень детализации мешает отследить большие тренды, но гораздо чаще происходит обратное — из-за недостаточной детализации не видно часть данных, необходимых для анализа. Чтобы показывать данные без потери точности:
1. **всегда используйте функцию `rate`, а не `irate`**;
2. **в качестве диапазона для range-векторов используйте `$__interval_rv`**;
3. **всегда используйте Resolution 1/1**;
4. **никогда не устанавливайте Min step**.

![](img/grafana_accuracy.jpg)

<details>
<summary>Объяснение деталей и причин</summary>
  <ul dir="auto">
    <li>В Prometheus в API в запросе можно указать <code>step</code>. Если мы загружаем данные за период в 3 часа и укажем <code>step</code> 30 секунд — получим 360 точек (3 часа * 60 минут * 2 точки в минуту) и показать их на графике вполне реально. Однако, если мы показываем данные за 24 часа — использовать шаг в 30 секунд уже нет никакого смысла, так как 2880 точек показать просто не возможно (если только на мониторе 4К полосками в один пиксель, но это ничего не дает, так-как человеческий глаз не может воспринимать такую информацию). Чтобы решить эту проблему Grafana имеет хитрую механику автоматического определения <code>step</code> работающую примерно следующим образом:
    <ul>
      <li>В зависимости от размера графика (полная ширина, 1/2 ширины экрана, 1/4 ширины экрана и т.д.), размера окна браузера и разрешения экрана Grafana подсчитывает, сколько точек реально показать — например, на моем экране для графика на всю ширину Grafana считает нормальным показ 800 точек.</li>
      <li>Дальше она делит выбранный период показа на количество точек, которые реально показать, и получает "минимальный возможный для показа шаг" — например, на моем экране:
        <ul>
          <li>30 минут — 2.25 секунды,</li>
          <li>3 часа — 13.5 секунд,</li>
          <li>24 часа — 108 секунд,</li>
          <li>7 дней — 756 секунд.</li>
        </ul>
      </li>
      <li>Дальше Grafana смотрит настройки <code>Min step</code> и если он указан — делает <code>step</code> не меньше <code>Min step</code>. При этом <code>Min step</code> может быть указан в двух местах — глобально, в настройках data source'а и для каждого query в panel. У нас <code>Min step</code> указан глобально и соответствует <code>scrape_interval</code> у Prometheus (у основного это 30 секунд). Получаются следующие значения:
        <ul>
          <li>30 минут — 30 секунд (а не 2.25),</li>
          <li>3 часа — 30 секунд (а не 13.5 секунд),</li>
          <li>24 часа — 108 секунд,</li>
          <li>7 дней — 756 секунд.</li>
        </ul>
      </li>
      <li>Затем Grafana как-то хитро округляет получившиеся значения (до 5/15/30 секунд, 1/5/15 минут и т.д.), получаются следующие значения:
        <ul>
          <li>30 минут — 30 секунд,</li>
          <li>3 часа — 30 секунд,</li>
          <li>24 часа — 2 минуты,</li>
          <li>7 дней — 10 минут.</li>
        </ul>
      </li>
      <li>Затем Grafana смотрит параметр Resolution панели (там может быть 1/1, 1/2, ..., 1/10) и если там указано не 1/1 — увеличивает step (для 1/2 в два раза, для 1/10 в 10 раз).</li>
    </ul>
  </li>
  <li>Большая часть данных в Prometheus лежит в counter'ах (а не в gauge'ах), так что для получения текущего значения нужно использовать <code>rate</code> или <code>irate</code>. И тут начинается самое опасное и самое неприятное.
    <ul>
      <li>Функции <code>rate</code> и <code>irate</code> работают с range-векторами, но какой range передавать? В Grafana есть готовая переменная <code>$__interval</code> в которой уже хранится тот step, который будет отправлен в Prometheus, и казалось бы — используй!</li>
      <li>Но чтобы функции <code>rate</code> и <code>irate</code> работали — нужно чтобы в range-векторе обязательно было хотя бы две точки (что логично). А если мы возьмем range-вектор за 30 секунд в Prometheus со <code>scrape_interval</code> 30 секунд, в нем будет только одна точка и <code>rate</code>/<code>irate</code> ничего не выдадут. И тут есть множество НЕПРАВИЛЬНЫХ путей:
        <ul>
          <li>Кто-то ставит Resolution у всех query 1/2, чтобы в переменной <code>$__interval</code> при показе любого интервала было не меньше, чем 2 x <code>Min step</code>. Это помогает — графики начинают работать, но они всегда в два раза менее детальные, чем может хранит Prometheus.</li>
          <li>Кто-то ставит Min step равный двум <code>scrape_interval'ам</code> — это чуть лучше, но все равно шило на мыло.</li>
          <li>Кто-то начинает использовать <code>irate</code> и передает туда range-вектор за 1h (любое значение, заведомо больше периода) — и тут таится самый сильный подвох. В этом случае графики начинают показываться с абсолютной точностью, пока наш <code>step</code> меньше или равен <code>scrape_interval</code>, но если <code>step</code> больше <code>scrapte_interval</code> (показ данных за 24 часа и за 7 дней) — графит начинает жесточайше врать. Так как вместо того, чтобы показать в каждой точке rate за весь step, он показывает в каждой точке rate за последний <code>scrape_interval</code>. Проще говоря — получается, что при просмотре данных за 7 дней, вы видите на графике в каждой точке не среднее потребление CPU за 10 минут (<code>step</code>), а вы видите потребление за последние 30 секунд каждые 10 минут, а что было остальные 9 минут 30 секунд — просто не знаете!</li>
        </ul>
      </li>
      <li>Для решения этой проблемы мы пропатчили Grafana и добавили переменную <code>$__interval_rv</code> (rv = range vector). Эта переменная равна <code>max($__interval, scrape_interval * 2)</code>, то есть в ней тоже самое, что в <code>$__interval</code> но не меньше периода, в который попадет хотя бы две точки (<a href="https://github.com/grafana/grafana/issues/11451" rel="nofollow noreferrer noopener" target="_blank">мы завели тикет в Grafana об этом</a>). Это полностью решает проблему!</li>
    </ul>
  </li>
</ul>
</details>

#### Отсутствие данных нужно тоже точно показывать

У Grafana есть три режима показа Null Value (отсутствия данных).
* Никогда не используйте `connected`, он сильно вводит в заблуждение!
* Нужно использовать `null` во всех случаях, кроме стекирования — четко видно, что данных нет.
* При стекировании обычно нужно использовать `null as zero` (иначе при null в одной метрике пропадут все).

| connected      | null      | null as zero      |
|----------------|-----------|-------------------|
| ![][connected] | ![][null] | ![][null as zero] |


[connected]: img/grafana_null_value_connected.jpg
[null]: img/grafana_null_value_null.jpg
[null as zero]: img/grafana_null_value_as_zero.jpg

#### Точность значения должна соответствовать целям

* Если процент ошибок измеряется в диапазоне от 0 до 10%, то какой смысл показывать 5 знаков после запятой? Все будут следить за целой частью и одним-двумя знаками после запятой.
* Если количество запросов прошедших за 3 часа (период по-умолчанию для показа Dashboard'а) обычно измеряется десятками тысяч (а на некторых кластерах может быть и сотнями миллионов) — стоит ли показывать точное количество запросов, или достаточно показать порядок?

Точность отображения значения должна соответствовать целям использования показателя, следите за этим!

#### По-умолчанию показывать данные за последние 3 часа (автообновлять каждые 30 секунд)

Показ 3 часов является оптимальным по-умолчанию, так как это максимальный период, который можно показать в полной детализации:
* При `scrape_interval` равном `30s` (это наше основное значение), при показе данных за 3 часа, данные показываются без аппроксимации и с полной детализацией — даже на графиках размером в 1/4 ширины экрана еще показываются все точки (данные за каждые 30 секунд).
* Больший масштаб (уменьшение периода показа) не имеет смысла, так как не увеличивает детализацию, но сужает диапазон видимости по времени.
* Меньший масштаб (увеличение периода показа) снижает детализацию и данные начинают аппроксимироваться.

Автоматическое обновление имеет смысл делать каждые 30 секунд, так как именно с такой частотой производится scrape и в Prometheus поступают новые данные.

### TODO

* Использовать $__range и instant query, когда нужно посчитать данные за период показа (обычно это в singlestat'ах).
* Делать легенды одной ширины, чтобы графики были друг под другом.
* Проставлять ноль у оси Y.
* Указывать верхнюю границу у оси Y для графиков 0-100%.
* Как рисовать графики процентные (bars, вместо stepped lines).
* Трюк с использованием стекирования и показом Total.
* Не забывать ставить "On time range change", когда переменная получает значения, которые могут поменяться (например имена подов).
* Цвета у CPU указывать как в okmeter.
* Когда использовать какой режим отрисовки и чем хорош staircase.
