package etcd

// Code generated by http://github.com/gojuno/minimock (dev). DO NOT EDIT.

//go:generate minimock -i github.com/deckhouse/deckhouse/go_lib/dependency/etcd.Client -o ./etcd_mock.go

import (
	"context"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
	clientv3 "go.etcd.io/etcd/client/v3"
)

// ClientMock implements Client
type ClientMock struct {
	t minimock.Tester

	funcClose          func() (err error)
	inspectFuncClose   func()
	afterCloseCounter  uint64
	beforeCloseCounter uint64
	CloseMock          mClientMockClose

	funcCompact          func(ctx context.Context, rev int64, opts ...clientv3.CompactOption) (cp1 *clientv3.CompactResponse, err error)
	inspectFuncCompact   func(ctx context.Context, rev int64, opts ...clientv3.CompactOption)
	afterCompactCounter  uint64
	beforeCompactCounter uint64
	CompactMock          mClientMockCompact

	funcDelete          func(ctx context.Context, key string, opts ...clientv3.OpOption) (dp1 *clientv3.DeleteResponse, err error)
	inspectFuncDelete   func(ctx context.Context, key string, opts ...clientv3.OpOption)
	afterDeleteCounter  uint64
	beforeDeleteCounter uint64
	DeleteMock          mClientMockDelete

	funcDo          func(ctx context.Context, op clientv3.Op) (o1 clientv3.OpResponse, err error)
	inspectFuncDo   func(ctx context.Context, op clientv3.Op)
	afterDoCounter  uint64
	beforeDoCounter uint64
	DoMock          mClientMockDo

	funcGet          func(ctx context.Context, key string, opts ...clientv3.OpOption) (gp1 *clientv3.GetResponse, err error)
	inspectFuncGet   func(ctx context.Context, key string, opts ...clientv3.OpOption)
	afterGetCounter  uint64
	beforeGetCounter uint64
	GetMock          mClientMockGet

	funcMemberAdd          func(ctx context.Context, peerAddrs []string) (mp1 *clientv3.MemberAddResponse, err error)
	inspectFuncMemberAdd   func(ctx context.Context, peerAddrs []string)
	afterMemberAddCounter  uint64
	beforeMemberAddCounter uint64
	MemberAddMock          mClientMockMemberAdd

	funcMemberAddAsLearner          func(ctx context.Context, peerAddrs []string) (mp1 *clientv3.MemberAddResponse, err error)
	inspectFuncMemberAddAsLearner   func(ctx context.Context, peerAddrs []string)
	afterMemberAddAsLearnerCounter  uint64
	beforeMemberAddAsLearnerCounter uint64
	MemberAddAsLearnerMock          mClientMockMemberAddAsLearner

	funcMemberList          func(ctx context.Context) (mp1 *clientv3.MemberListResponse, err error)
	inspectFuncMemberList   func(ctx context.Context)
	afterMemberListCounter  uint64
	beforeMemberListCounter uint64
	MemberListMock          mClientMockMemberList

	funcMemberPromote          func(ctx context.Context, id uint64) (mp1 *clientv3.MemberPromoteResponse, err error)
	inspectFuncMemberPromote   func(ctx context.Context, id uint64)
	afterMemberPromoteCounter  uint64
	beforeMemberPromoteCounter uint64
	MemberPromoteMock          mClientMockMemberPromote

	funcMemberRemove          func(ctx context.Context, id uint64) (mp1 *clientv3.MemberRemoveResponse, err error)
	inspectFuncMemberRemove   func(ctx context.Context, id uint64)
	afterMemberRemoveCounter  uint64
	beforeMemberRemoveCounter uint64
	MemberRemoveMock          mClientMockMemberRemove

	funcMemberUpdate          func(ctx context.Context, id uint64, peerAddrs []string) (mp1 *clientv3.MemberUpdateResponse, err error)
	inspectFuncMemberUpdate   func(ctx context.Context, id uint64, peerAddrs []string)
	afterMemberUpdateCounter  uint64
	beforeMemberUpdateCounter uint64
	MemberUpdateMock          mClientMockMemberUpdate

	funcPut          func(ctx context.Context, key string, val string, opts ...clientv3.OpOption) (pp1 *clientv3.PutResponse, err error)
	inspectFuncPut   func(ctx context.Context, key string, val string, opts ...clientv3.OpOption)
	afterPutCounter  uint64
	beforePutCounter uint64
	PutMock          mClientMockPut

	funcRequestProgress          func(ctx context.Context) (err error)
	inspectFuncRequestProgress   func(ctx context.Context)
	afterRequestProgressCounter  uint64
	beforeRequestProgressCounter uint64
	RequestProgressMock          mClientMockRequestProgress

	funcTxn          func(ctx context.Context) (t1 clientv3.Txn)
	inspectFuncTxn   func(ctx context.Context)
	afterTxnCounter  uint64
	beforeTxnCounter uint64
	TxnMock          mClientMockTxn

	funcWatch          func(ctx context.Context, key string, opts ...clientv3.OpOption) (w1 clientv3.WatchChan)
	inspectFuncWatch   func(ctx context.Context, key string, opts ...clientv3.OpOption)
	afterWatchCounter  uint64
	beforeWatchCounter uint64
	WatchMock          mClientMockWatch
}

// NewClientMock returns a mock for Client
func NewClientMock(t minimock.Tester) *ClientMock {
	m := &ClientMock{t: t}
	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.CloseMock = mClientMockClose{mock: m}

	m.CompactMock = mClientMockCompact{mock: m}
	m.CompactMock.callArgs = []*ClientMockCompactParams{}

	m.DeleteMock = mClientMockDelete{mock: m}
	m.DeleteMock.callArgs = []*ClientMockDeleteParams{}

	m.DoMock = mClientMockDo{mock: m}
	m.DoMock.callArgs = []*ClientMockDoParams{}

	m.GetMock = mClientMockGet{mock: m}
	m.GetMock.callArgs = []*ClientMockGetParams{}

	m.MemberAddMock = mClientMockMemberAdd{mock: m}
	m.MemberAddMock.callArgs = []*ClientMockMemberAddParams{}

	m.MemberAddAsLearnerMock = mClientMockMemberAddAsLearner{mock: m}
	m.MemberAddAsLearnerMock.callArgs = []*ClientMockMemberAddAsLearnerParams{}

	m.MemberListMock = mClientMockMemberList{mock: m}
	m.MemberListMock.callArgs = []*ClientMockMemberListParams{}

	m.MemberPromoteMock = mClientMockMemberPromote{mock: m}
	m.MemberPromoteMock.callArgs = []*ClientMockMemberPromoteParams{}

	m.MemberRemoveMock = mClientMockMemberRemove{mock: m}
	m.MemberRemoveMock.callArgs = []*ClientMockMemberRemoveParams{}

	m.MemberUpdateMock = mClientMockMemberUpdate{mock: m}
	m.MemberUpdateMock.callArgs = []*ClientMockMemberUpdateParams{}

	m.PutMock = mClientMockPut{mock: m}
	m.PutMock.callArgs = []*ClientMockPutParams{}

	m.RequestProgressMock = mClientMockRequestProgress{mock: m}
	m.RequestProgressMock.callArgs = []*ClientMockRequestProgressParams{}

	m.TxnMock = mClientMockTxn{mock: m}
	m.TxnMock.callArgs = []*ClientMockTxnParams{}

	m.WatchMock = mClientMockWatch{mock: m}
	m.WatchMock.callArgs = []*ClientMockWatchParams{}

	return m
}

type mClientMockClose struct {
	mock               *ClientMock
	defaultExpectation *ClientMockCloseExpectation
	expectations       []*ClientMockCloseExpectation
}

// ClientMockCloseExpectation specifies expectation struct of the Client.Close
type ClientMockCloseExpectation struct {
	mock *ClientMock

	results *ClientMockCloseResults
	Counter uint64
}

// ClientMockCloseResults contains results of the Client.Close
type ClientMockCloseResults struct {
	err error
}

// Expect sets up expected params for Client.Close
func (mmClose *mClientMockClose) Expect() *mClientMockClose {
	if mmClose.mock.funcClose != nil {
		mmClose.mock.t.Fatalf("ClientMock.Close mock is already set by Set")
	}

	if mmClose.defaultExpectation == nil {
		mmClose.defaultExpectation = &ClientMockCloseExpectation{}
	}

	return mmClose
}

// Inspect accepts an inspector function that has same arguments as the Client.Close
func (mmClose *mClientMockClose) Inspect(f func()) *mClientMockClose {
	if mmClose.mock.inspectFuncClose != nil {
		mmClose.mock.t.Fatalf("Inspect function is already set for ClientMock.Close")
	}

	mmClose.mock.inspectFuncClose = f

	return mmClose
}

// Return sets up results that will be returned by Client.Close
func (mmClose *mClientMockClose) Return(err error) *ClientMock {
	if mmClose.mock.funcClose != nil {
		mmClose.mock.t.Fatalf("ClientMock.Close mock is already set by Set")
	}

	if mmClose.defaultExpectation == nil {
		mmClose.defaultExpectation = &ClientMockCloseExpectation{mock: mmClose.mock}
	}
	mmClose.defaultExpectation.results = &ClientMockCloseResults{err}
	return mmClose.mock
}

//Set uses given function f to mock the Client.Close method
func (mmClose *mClientMockClose) Set(f func() (err error)) *ClientMock {
	if mmClose.defaultExpectation != nil {
		mmClose.mock.t.Fatalf("Default expectation is already set for the Client.Close method")
	}

	if len(mmClose.expectations) > 0 {
		mmClose.mock.t.Fatalf("Some expectations are already set for the Client.Close method")
	}

	mmClose.mock.funcClose = f
	return mmClose.mock
}

// Close implements Client
func (mmClose *ClientMock) Close() (err error) {
	mm_atomic.AddUint64(&mmClose.beforeCloseCounter, 1)
	defer mm_atomic.AddUint64(&mmClose.afterCloseCounter, 1)

	if mmClose.inspectFuncClose != nil {
		mmClose.inspectFuncClose()
	}

	if mmClose.CloseMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmClose.CloseMock.defaultExpectation.Counter, 1)

		mm_results := mmClose.CloseMock.defaultExpectation.results
		if mm_results == nil {
			mmClose.t.Fatal("No results are set for the ClientMock.Close")
		}
		return (*mm_results).err
	}
	if mmClose.funcClose != nil {
		return mmClose.funcClose()
	}
	mmClose.t.Fatalf("Unexpected call to ClientMock.Close.")
	return
}

// CloseAfterCounter returns a count of finished ClientMock.Close invocations
func (mmClose *ClientMock) CloseAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmClose.afterCloseCounter)
}

// CloseBeforeCounter returns a count of ClientMock.Close invocations
func (mmClose *ClientMock) CloseBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmClose.beforeCloseCounter)
}

// MinimockCloseDone returns true if the count of the Close invocations corresponds
// the number of defined expectations
func (m *ClientMock) MinimockCloseDone() bool {
	for _, e := range m.CloseMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.CloseMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterCloseCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcClose != nil && mm_atomic.LoadUint64(&m.afterCloseCounter) < 1 {
		return false
	}
	return true
}

// MinimockCloseInspect logs each unmet expectation
func (m *ClientMock) MinimockCloseInspect() {
	for _, e := range m.CloseMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to ClientMock.Close")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.CloseMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterCloseCounter) < 1 {
		m.t.Error("Expected call to ClientMock.Close")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcClose != nil && mm_atomic.LoadUint64(&m.afterCloseCounter) < 1 {
		m.t.Error("Expected call to ClientMock.Close")
	}
}

type mClientMockCompact struct {
	mock               *ClientMock
	defaultExpectation *ClientMockCompactExpectation
	expectations       []*ClientMockCompactExpectation

	callArgs []*ClientMockCompactParams
	mutex    sync.RWMutex
}

// ClientMockCompactExpectation specifies expectation struct of the Client.Compact
type ClientMockCompactExpectation struct {
	mock    *ClientMock
	params  *ClientMockCompactParams
	results *ClientMockCompactResults
	Counter uint64
}

// ClientMockCompactParams contains parameters of the Client.Compact
type ClientMockCompactParams struct {
	ctx  context.Context
	rev  int64
	opts []clientv3.CompactOption
}

// ClientMockCompactResults contains results of the Client.Compact
type ClientMockCompactResults struct {
	cp1 *clientv3.CompactResponse
	err error
}

// Expect sets up expected params for Client.Compact
func (mmCompact *mClientMockCompact) Expect(ctx context.Context, rev int64, opts ...clientv3.CompactOption) *mClientMockCompact {
	if mmCompact.mock.funcCompact != nil {
		mmCompact.mock.t.Fatalf("ClientMock.Compact mock is already set by Set")
	}

	if mmCompact.defaultExpectation == nil {
		mmCompact.defaultExpectation = &ClientMockCompactExpectation{}
	}

	mmCompact.defaultExpectation.params = &ClientMockCompactParams{ctx, rev, opts}
	for _, e := range mmCompact.expectations {
		if minimock.Equal(e.params, mmCompact.defaultExpectation.params) {
			mmCompact.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmCompact.defaultExpectation.params)
		}
	}

	return mmCompact
}

// Inspect accepts an inspector function that has same arguments as the Client.Compact
func (mmCompact *mClientMockCompact) Inspect(f func(ctx context.Context, rev int64, opts ...clientv3.CompactOption)) *mClientMockCompact {
	if mmCompact.mock.inspectFuncCompact != nil {
		mmCompact.mock.t.Fatalf("Inspect function is already set for ClientMock.Compact")
	}

	mmCompact.mock.inspectFuncCompact = f

	return mmCompact
}

// Return sets up results that will be returned by Client.Compact
func (mmCompact *mClientMockCompact) Return(cp1 *clientv3.CompactResponse, err error) *ClientMock {
	if mmCompact.mock.funcCompact != nil {
		mmCompact.mock.t.Fatalf("ClientMock.Compact mock is already set by Set")
	}

	if mmCompact.defaultExpectation == nil {
		mmCompact.defaultExpectation = &ClientMockCompactExpectation{mock: mmCompact.mock}
	}
	mmCompact.defaultExpectation.results = &ClientMockCompactResults{cp1, err}
	return mmCompact.mock
}

//Set uses given function f to mock the Client.Compact method
func (mmCompact *mClientMockCompact) Set(f func(ctx context.Context, rev int64, opts ...clientv3.CompactOption) (cp1 *clientv3.CompactResponse, err error)) *ClientMock {
	if mmCompact.defaultExpectation != nil {
		mmCompact.mock.t.Fatalf("Default expectation is already set for the Client.Compact method")
	}

	if len(mmCompact.expectations) > 0 {
		mmCompact.mock.t.Fatalf("Some expectations are already set for the Client.Compact method")
	}

	mmCompact.mock.funcCompact = f
	return mmCompact.mock
}

// When sets expectation for the Client.Compact which will trigger the result defined by the following
// Then helper
func (mmCompact *mClientMockCompact) When(ctx context.Context, rev int64, opts ...clientv3.CompactOption) *ClientMockCompactExpectation {
	if mmCompact.mock.funcCompact != nil {
		mmCompact.mock.t.Fatalf("ClientMock.Compact mock is already set by Set")
	}

	expectation := &ClientMockCompactExpectation{
		mock:   mmCompact.mock,
		params: &ClientMockCompactParams{ctx, rev, opts},
	}
	mmCompact.expectations = append(mmCompact.expectations, expectation)
	return expectation
}

// Then sets up Client.Compact return parameters for the expectation previously defined by the When method
func (e *ClientMockCompactExpectation) Then(cp1 *clientv3.CompactResponse, err error) *ClientMock {
	e.results = &ClientMockCompactResults{cp1, err}
	return e.mock
}

// Compact implements Client
func (mmCompact *ClientMock) Compact(ctx context.Context, rev int64, opts ...clientv3.CompactOption) (cp1 *clientv3.CompactResponse, err error) {
	mm_atomic.AddUint64(&mmCompact.beforeCompactCounter, 1)
	defer mm_atomic.AddUint64(&mmCompact.afterCompactCounter, 1)

	if mmCompact.inspectFuncCompact != nil {
		mmCompact.inspectFuncCompact(ctx, rev, opts...)
	}

	mm_params := &ClientMockCompactParams{ctx, rev, opts}

	// Record call args
	mmCompact.CompactMock.mutex.Lock()
	mmCompact.CompactMock.callArgs = append(mmCompact.CompactMock.callArgs, mm_params)
	mmCompact.CompactMock.mutex.Unlock()

	for _, e := range mmCompact.CompactMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.cp1, e.results.err
		}
	}

	if mmCompact.CompactMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCompact.CompactMock.defaultExpectation.Counter, 1)
		mm_want := mmCompact.CompactMock.defaultExpectation.params
		mm_got := ClientMockCompactParams{ctx, rev, opts}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmCompact.t.Errorf("ClientMock.Compact got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmCompact.CompactMock.defaultExpectation.results
		if mm_results == nil {
			mmCompact.t.Fatal("No results are set for the ClientMock.Compact")
		}
		return (*mm_results).cp1, (*mm_results).err
	}
	if mmCompact.funcCompact != nil {
		return mmCompact.funcCompact(ctx, rev, opts...)
	}
	mmCompact.t.Fatalf("Unexpected call to ClientMock.Compact. %v %v %v", ctx, rev, opts)
	return
}

// CompactAfterCounter returns a count of finished ClientMock.Compact invocations
func (mmCompact *ClientMock) CompactAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCompact.afterCompactCounter)
}

// CompactBeforeCounter returns a count of ClientMock.Compact invocations
func (mmCompact *ClientMock) CompactBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCompact.beforeCompactCounter)
}

// Calls returns a list of arguments used in each call to ClientMock.Compact.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmCompact *mClientMockCompact) Calls() []*ClientMockCompactParams {
	mmCompact.mutex.RLock()

	argCopy := make([]*ClientMockCompactParams, len(mmCompact.callArgs))
	copy(argCopy, mmCompact.callArgs)

	mmCompact.mutex.RUnlock()

	return argCopy
}

// MinimockCompactDone returns true if the count of the Compact invocations corresponds
// the number of defined expectations
func (m *ClientMock) MinimockCompactDone() bool {
	for _, e := range m.CompactMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.CompactMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterCompactCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCompact != nil && mm_atomic.LoadUint64(&m.afterCompactCounter) < 1 {
		return false
	}
	return true
}

// MinimockCompactInspect logs each unmet expectation
func (m *ClientMock) MinimockCompactInspect() {
	for _, e := range m.CompactMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ClientMock.Compact with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.CompactMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterCompactCounter) < 1 {
		if m.CompactMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to ClientMock.Compact")
		} else {
			m.t.Errorf("Expected call to ClientMock.Compact with params: %#v", *m.CompactMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCompact != nil && mm_atomic.LoadUint64(&m.afterCompactCounter) < 1 {
		m.t.Error("Expected call to ClientMock.Compact")
	}
}

type mClientMockDelete struct {
	mock               *ClientMock
	defaultExpectation *ClientMockDeleteExpectation
	expectations       []*ClientMockDeleteExpectation

	callArgs []*ClientMockDeleteParams
	mutex    sync.RWMutex
}

// ClientMockDeleteExpectation specifies expectation struct of the Client.Delete
type ClientMockDeleteExpectation struct {
	mock    *ClientMock
	params  *ClientMockDeleteParams
	results *ClientMockDeleteResults
	Counter uint64
}

// ClientMockDeleteParams contains parameters of the Client.Delete
type ClientMockDeleteParams struct {
	ctx  context.Context
	key  string
	opts []clientv3.OpOption
}

// ClientMockDeleteResults contains results of the Client.Delete
type ClientMockDeleteResults struct {
	dp1 *clientv3.DeleteResponse
	err error
}

// Expect sets up expected params for Client.Delete
func (mmDelete *mClientMockDelete) Expect(ctx context.Context, key string, opts ...clientv3.OpOption) *mClientMockDelete {
	if mmDelete.mock.funcDelete != nil {
		mmDelete.mock.t.Fatalf("ClientMock.Delete mock is already set by Set")
	}

	if mmDelete.defaultExpectation == nil {
		mmDelete.defaultExpectation = &ClientMockDeleteExpectation{}
	}

	mmDelete.defaultExpectation.params = &ClientMockDeleteParams{ctx, key, opts}
	for _, e := range mmDelete.expectations {
		if minimock.Equal(e.params, mmDelete.defaultExpectation.params) {
			mmDelete.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmDelete.defaultExpectation.params)
		}
	}

	return mmDelete
}

// Inspect accepts an inspector function that has same arguments as the Client.Delete
func (mmDelete *mClientMockDelete) Inspect(f func(ctx context.Context, key string, opts ...clientv3.OpOption)) *mClientMockDelete {
	if mmDelete.mock.inspectFuncDelete != nil {
		mmDelete.mock.t.Fatalf("Inspect function is already set for ClientMock.Delete")
	}

	mmDelete.mock.inspectFuncDelete = f

	return mmDelete
}

// Return sets up results that will be returned by Client.Delete
func (mmDelete *mClientMockDelete) Return(dp1 *clientv3.DeleteResponse, err error) *ClientMock {
	if mmDelete.mock.funcDelete != nil {
		mmDelete.mock.t.Fatalf("ClientMock.Delete mock is already set by Set")
	}

	if mmDelete.defaultExpectation == nil {
		mmDelete.defaultExpectation = &ClientMockDeleteExpectation{mock: mmDelete.mock}
	}
	mmDelete.defaultExpectation.results = &ClientMockDeleteResults{dp1, err}
	return mmDelete.mock
}

//Set uses given function f to mock the Client.Delete method
func (mmDelete *mClientMockDelete) Set(f func(ctx context.Context, key string, opts ...clientv3.OpOption) (dp1 *clientv3.DeleteResponse, err error)) *ClientMock {
	if mmDelete.defaultExpectation != nil {
		mmDelete.mock.t.Fatalf("Default expectation is already set for the Client.Delete method")
	}

	if len(mmDelete.expectations) > 0 {
		mmDelete.mock.t.Fatalf("Some expectations are already set for the Client.Delete method")
	}

	mmDelete.mock.funcDelete = f
	return mmDelete.mock
}

// When sets expectation for the Client.Delete which will trigger the result defined by the following
// Then helper
func (mmDelete *mClientMockDelete) When(ctx context.Context, key string, opts ...clientv3.OpOption) *ClientMockDeleteExpectation {
	if mmDelete.mock.funcDelete != nil {
		mmDelete.mock.t.Fatalf("ClientMock.Delete mock is already set by Set")
	}

	expectation := &ClientMockDeleteExpectation{
		mock:   mmDelete.mock,
		params: &ClientMockDeleteParams{ctx, key, opts},
	}
	mmDelete.expectations = append(mmDelete.expectations, expectation)
	return expectation
}

// Then sets up Client.Delete return parameters for the expectation previously defined by the When method
func (e *ClientMockDeleteExpectation) Then(dp1 *clientv3.DeleteResponse, err error) *ClientMock {
	e.results = &ClientMockDeleteResults{dp1, err}
	return e.mock
}

// Delete implements Client
func (mmDelete *ClientMock) Delete(ctx context.Context, key string, opts ...clientv3.OpOption) (dp1 *clientv3.DeleteResponse, err error) {
	mm_atomic.AddUint64(&mmDelete.beforeDeleteCounter, 1)
	defer mm_atomic.AddUint64(&mmDelete.afterDeleteCounter, 1)

	if mmDelete.inspectFuncDelete != nil {
		mmDelete.inspectFuncDelete(ctx, key, opts...)
	}

	mm_params := &ClientMockDeleteParams{ctx, key, opts}

	// Record call args
	mmDelete.DeleteMock.mutex.Lock()
	mmDelete.DeleteMock.callArgs = append(mmDelete.DeleteMock.callArgs, mm_params)
	mmDelete.DeleteMock.mutex.Unlock()

	for _, e := range mmDelete.DeleteMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.dp1, e.results.err
		}
	}

	if mmDelete.DeleteMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmDelete.DeleteMock.defaultExpectation.Counter, 1)
		mm_want := mmDelete.DeleteMock.defaultExpectation.params
		mm_got := ClientMockDeleteParams{ctx, key, opts}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmDelete.t.Errorf("ClientMock.Delete got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmDelete.DeleteMock.defaultExpectation.results
		if mm_results == nil {
			mmDelete.t.Fatal("No results are set for the ClientMock.Delete")
		}
		return (*mm_results).dp1, (*mm_results).err
	}
	if mmDelete.funcDelete != nil {
		return mmDelete.funcDelete(ctx, key, opts...)
	}
	mmDelete.t.Fatalf("Unexpected call to ClientMock.Delete. %v %v %v", ctx, key, opts)
	return
}

// DeleteAfterCounter returns a count of finished ClientMock.Delete invocations
func (mmDelete *ClientMock) DeleteAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDelete.afterDeleteCounter)
}

// DeleteBeforeCounter returns a count of ClientMock.Delete invocations
func (mmDelete *ClientMock) DeleteBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDelete.beforeDeleteCounter)
}

// Calls returns a list of arguments used in each call to ClientMock.Delete.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmDelete *mClientMockDelete) Calls() []*ClientMockDeleteParams {
	mmDelete.mutex.RLock()

	argCopy := make([]*ClientMockDeleteParams, len(mmDelete.callArgs))
	copy(argCopy, mmDelete.callArgs)

	mmDelete.mutex.RUnlock()

	return argCopy
}

// MinimockDeleteDone returns true if the count of the Delete invocations corresponds
// the number of defined expectations
func (m *ClientMock) MinimockDeleteDone() bool {
	for _, e := range m.DeleteMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.DeleteMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterDeleteCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDelete != nil && mm_atomic.LoadUint64(&m.afterDeleteCounter) < 1 {
		return false
	}
	return true
}

// MinimockDeleteInspect logs each unmet expectation
func (m *ClientMock) MinimockDeleteInspect() {
	for _, e := range m.DeleteMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ClientMock.Delete with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.DeleteMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterDeleteCounter) < 1 {
		if m.DeleteMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to ClientMock.Delete")
		} else {
			m.t.Errorf("Expected call to ClientMock.Delete with params: %#v", *m.DeleteMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDelete != nil && mm_atomic.LoadUint64(&m.afterDeleteCounter) < 1 {
		m.t.Error("Expected call to ClientMock.Delete")
	}
}

type mClientMockDo struct {
	mock               *ClientMock
	defaultExpectation *ClientMockDoExpectation
	expectations       []*ClientMockDoExpectation

	callArgs []*ClientMockDoParams
	mutex    sync.RWMutex
}

// ClientMockDoExpectation specifies expectation struct of the Client.Do
type ClientMockDoExpectation struct {
	mock    *ClientMock
	params  *ClientMockDoParams
	results *ClientMockDoResults
	Counter uint64
}

// ClientMockDoParams contains parameters of the Client.Do
type ClientMockDoParams struct {
	ctx context.Context
	op  clientv3.Op
}

// ClientMockDoResults contains results of the Client.Do
type ClientMockDoResults struct {
	o1  clientv3.OpResponse
	err error
}

// Expect sets up expected params for Client.Do
func (mmDo *mClientMockDo) Expect(ctx context.Context, op clientv3.Op) *mClientMockDo {
	if mmDo.mock.funcDo != nil {
		mmDo.mock.t.Fatalf("ClientMock.Do mock is already set by Set")
	}

	if mmDo.defaultExpectation == nil {
		mmDo.defaultExpectation = &ClientMockDoExpectation{}
	}

	mmDo.defaultExpectation.params = &ClientMockDoParams{ctx, op}
	for _, e := range mmDo.expectations {
		if minimock.Equal(e.params, mmDo.defaultExpectation.params) {
			mmDo.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmDo.defaultExpectation.params)
		}
	}

	return mmDo
}

// Inspect accepts an inspector function that has same arguments as the Client.Do
func (mmDo *mClientMockDo) Inspect(f func(ctx context.Context, op clientv3.Op)) *mClientMockDo {
	if mmDo.mock.inspectFuncDo != nil {
		mmDo.mock.t.Fatalf("Inspect function is already set for ClientMock.Do")
	}

	mmDo.mock.inspectFuncDo = f

	return mmDo
}

// Return sets up results that will be returned by Client.Do
func (mmDo *mClientMockDo) Return(o1 clientv3.OpResponse, err error) *ClientMock {
	if mmDo.mock.funcDo != nil {
		mmDo.mock.t.Fatalf("ClientMock.Do mock is already set by Set")
	}

	if mmDo.defaultExpectation == nil {
		mmDo.defaultExpectation = &ClientMockDoExpectation{mock: mmDo.mock}
	}
	mmDo.defaultExpectation.results = &ClientMockDoResults{o1, err}
	return mmDo.mock
}

//Set uses given function f to mock the Client.Do method
func (mmDo *mClientMockDo) Set(f func(ctx context.Context, op clientv3.Op) (o1 clientv3.OpResponse, err error)) *ClientMock {
	if mmDo.defaultExpectation != nil {
		mmDo.mock.t.Fatalf("Default expectation is already set for the Client.Do method")
	}

	if len(mmDo.expectations) > 0 {
		mmDo.mock.t.Fatalf("Some expectations are already set for the Client.Do method")
	}

	mmDo.mock.funcDo = f
	return mmDo.mock
}

// When sets expectation for the Client.Do which will trigger the result defined by the following
// Then helper
func (mmDo *mClientMockDo) When(ctx context.Context, op clientv3.Op) *ClientMockDoExpectation {
	if mmDo.mock.funcDo != nil {
		mmDo.mock.t.Fatalf("ClientMock.Do mock is already set by Set")
	}

	expectation := &ClientMockDoExpectation{
		mock:   mmDo.mock,
		params: &ClientMockDoParams{ctx, op},
	}
	mmDo.expectations = append(mmDo.expectations, expectation)
	return expectation
}

// Then sets up Client.Do return parameters for the expectation previously defined by the When method
func (e *ClientMockDoExpectation) Then(o1 clientv3.OpResponse, err error) *ClientMock {
	e.results = &ClientMockDoResults{o1, err}
	return e.mock
}

// Do implements Client
func (mmDo *ClientMock) Do(ctx context.Context, op clientv3.Op) (o1 clientv3.OpResponse, err error) {
	mm_atomic.AddUint64(&mmDo.beforeDoCounter, 1)
	defer mm_atomic.AddUint64(&mmDo.afterDoCounter, 1)

	if mmDo.inspectFuncDo != nil {
		mmDo.inspectFuncDo(ctx, op)
	}

	mm_params := &ClientMockDoParams{ctx, op}

	// Record call args
	mmDo.DoMock.mutex.Lock()
	mmDo.DoMock.callArgs = append(mmDo.DoMock.callArgs, mm_params)
	mmDo.DoMock.mutex.Unlock()

	for _, e := range mmDo.DoMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.o1, e.results.err
		}
	}

	if mmDo.DoMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmDo.DoMock.defaultExpectation.Counter, 1)
		mm_want := mmDo.DoMock.defaultExpectation.params
		mm_got := ClientMockDoParams{ctx, op}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmDo.t.Errorf("ClientMock.Do got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmDo.DoMock.defaultExpectation.results
		if mm_results == nil {
			mmDo.t.Fatal("No results are set for the ClientMock.Do")
		}
		return (*mm_results).o1, (*mm_results).err
	}
	if mmDo.funcDo != nil {
		return mmDo.funcDo(ctx, op)
	}
	mmDo.t.Fatalf("Unexpected call to ClientMock.Do. %v %v", ctx, op)
	return
}

// DoAfterCounter returns a count of finished ClientMock.Do invocations
func (mmDo *ClientMock) DoAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDo.afterDoCounter)
}

// DoBeforeCounter returns a count of ClientMock.Do invocations
func (mmDo *ClientMock) DoBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDo.beforeDoCounter)
}

// Calls returns a list of arguments used in each call to ClientMock.Do.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmDo *mClientMockDo) Calls() []*ClientMockDoParams {
	mmDo.mutex.RLock()

	argCopy := make([]*ClientMockDoParams, len(mmDo.callArgs))
	copy(argCopy, mmDo.callArgs)

	mmDo.mutex.RUnlock()

	return argCopy
}

// MinimockDoDone returns true if the count of the Do invocations corresponds
// the number of defined expectations
func (m *ClientMock) MinimockDoDone() bool {
	for _, e := range m.DoMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.DoMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterDoCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDo != nil && mm_atomic.LoadUint64(&m.afterDoCounter) < 1 {
		return false
	}
	return true
}

// MinimockDoInspect logs each unmet expectation
func (m *ClientMock) MinimockDoInspect() {
	for _, e := range m.DoMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ClientMock.Do with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.DoMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterDoCounter) < 1 {
		if m.DoMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to ClientMock.Do")
		} else {
			m.t.Errorf("Expected call to ClientMock.Do with params: %#v", *m.DoMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDo != nil && mm_atomic.LoadUint64(&m.afterDoCounter) < 1 {
		m.t.Error("Expected call to ClientMock.Do")
	}
}

type mClientMockGet struct {
	mock               *ClientMock
	defaultExpectation *ClientMockGetExpectation
	expectations       []*ClientMockGetExpectation

	callArgs []*ClientMockGetParams
	mutex    sync.RWMutex
}

// ClientMockGetExpectation specifies expectation struct of the Client.Get
type ClientMockGetExpectation struct {
	mock    *ClientMock
	params  *ClientMockGetParams
	results *ClientMockGetResults
	Counter uint64
}

// ClientMockGetParams contains parameters of the Client.Get
type ClientMockGetParams struct {
	ctx  context.Context
	key  string
	opts []clientv3.OpOption
}

// ClientMockGetResults contains results of the Client.Get
type ClientMockGetResults struct {
	gp1 *clientv3.GetResponse
	err error
}

// Expect sets up expected params for Client.Get
func (mmGet *mClientMockGet) Expect(ctx context.Context, key string, opts ...clientv3.OpOption) *mClientMockGet {
	if mmGet.mock.funcGet != nil {
		mmGet.mock.t.Fatalf("ClientMock.Get mock is already set by Set")
	}

	if mmGet.defaultExpectation == nil {
		mmGet.defaultExpectation = &ClientMockGetExpectation{}
	}

	mmGet.defaultExpectation.params = &ClientMockGetParams{ctx, key, opts}
	for _, e := range mmGet.expectations {
		if minimock.Equal(e.params, mmGet.defaultExpectation.params) {
			mmGet.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGet.defaultExpectation.params)
		}
	}

	return mmGet
}

// Inspect accepts an inspector function that has same arguments as the Client.Get
func (mmGet *mClientMockGet) Inspect(f func(ctx context.Context, key string, opts ...clientv3.OpOption)) *mClientMockGet {
	if mmGet.mock.inspectFuncGet != nil {
		mmGet.mock.t.Fatalf("Inspect function is already set for ClientMock.Get")
	}

	mmGet.mock.inspectFuncGet = f

	return mmGet
}

// Return sets up results that will be returned by Client.Get
func (mmGet *mClientMockGet) Return(gp1 *clientv3.GetResponse, err error) *ClientMock {
	if mmGet.mock.funcGet != nil {
		mmGet.mock.t.Fatalf("ClientMock.Get mock is already set by Set")
	}

	if mmGet.defaultExpectation == nil {
		mmGet.defaultExpectation = &ClientMockGetExpectation{mock: mmGet.mock}
	}
	mmGet.defaultExpectation.results = &ClientMockGetResults{gp1, err}
	return mmGet.mock
}

//Set uses given function f to mock the Client.Get method
func (mmGet *mClientMockGet) Set(f func(ctx context.Context, key string, opts ...clientv3.OpOption) (gp1 *clientv3.GetResponse, err error)) *ClientMock {
	if mmGet.defaultExpectation != nil {
		mmGet.mock.t.Fatalf("Default expectation is already set for the Client.Get method")
	}

	if len(mmGet.expectations) > 0 {
		mmGet.mock.t.Fatalf("Some expectations are already set for the Client.Get method")
	}

	mmGet.mock.funcGet = f
	return mmGet.mock
}

// When sets expectation for the Client.Get which will trigger the result defined by the following
// Then helper
func (mmGet *mClientMockGet) When(ctx context.Context, key string, opts ...clientv3.OpOption) *ClientMockGetExpectation {
	if mmGet.mock.funcGet != nil {
		mmGet.mock.t.Fatalf("ClientMock.Get mock is already set by Set")
	}

	expectation := &ClientMockGetExpectation{
		mock:   mmGet.mock,
		params: &ClientMockGetParams{ctx, key, opts},
	}
	mmGet.expectations = append(mmGet.expectations, expectation)
	return expectation
}

// Then sets up Client.Get return parameters for the expectation previously defined by the When method
func (e *ClientMockGetExpectation) Then(gp1 *clientv3.GetResponse, err error) *ClientMock {
	e.results = &ClientMockGetResults{gp1, err}
	return e.mock
}

// Get implements Client
func (mmGet *ClientMock) Get(ctx context.Context, key string, opts ...clientv3.OpOption) (gp1 *clientv3.GetResponse, err error) {
	mm_atomic.AddUint64(&mmGet.beforeGetCounter, 1)
	defer mm_atomic.AddUint64(&mmGet.afterGetCounter, 1)

	if mmGet.inspectFuncGet != nil {
		mmGet.inspectFuncGet(ctx, key, opts...)
	}

	mm_params := &ClientMockGetParams{ctx, key, opts}

	// Record call args
	mmGet.GetMock.mutex.Lock()
	mmGet.GetMock.callArgs = append(mmGet.GetMock.callArgs, mm_params)
	mmGet.GetMock.mutex.Unlock()

	for _, e := range mmGet.GetMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.gp1, e.results.err
		}
	}

	if mmGet.GetMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGet.GetMock.defaultExpectation.Counter, 1)
		mm_want := mmGet.GetMock.defaultExpectation.params
		mm_got := ClientMockGetParams{ctx, key, opts}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGet.t.Errorf("ClientMock.Get got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGet.GetMock.defaultExpectation.results
		if mm_results == nil {
			mmGet.t.Fatal("No results are set for the ClientMock.Get")
		}
		return (*mm_results).gp1, (*mm_results).err
	}
	if mmGet.funcGet != nil {
		return mmGet.funcGet(ctx, key, opts...)
	}
	mmGet.t.Fatalf("Unexpected call to ClientMock.Get. %v %v %v", ctx, key, opts)
	return
}

// GetAfterCounter returns a count of finished ClientMock.Get invocations
func (mmGet *ClientMock) GetAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGet.afterGetCounter)
}

// GetBeforeCounter returns a count of ClientMock.Get invocations
func (mmGet *ClientMock) GetBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGet.beforeGetCounter)
}

// Calls returns a list of arguments used in each call to ClientMock.Get.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGet *mClientMockGet) Calls() []*ClientMockGetParams {
	mmGet.mutex.RLock()

	argCopy := make([]*ClientMockGetParams, len(mmGet.callArgs))
	copy(argCopy, mmGet.callArgs)

	mmGet.mutex.RUnlock()

	return argCopy
}

// MinimockGetDone returns true if the count of the Get invocations corresponds
// the number of defined expectations
func (m *ClientMock) MinimockGetDone() bool {
	for _, e := range m.GetMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGet != nil && mm_atomic.LoadUint64(&m.afterGetCounter) < 1 {
		return false
	}
	return true
}

// MinimockGetInspect logs each unmet expectation
func (m *ClientMock) MinimockGetInspect() {
	for _, e := range m.GetMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ClientMock.Get with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetCounter) < 1 {
		if m.GetMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to ClientMock.Get")
		} else {
			m.t.Errorf("Expected call to ClientMock.Get with params: %#v", *m.GetMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGet != nil && mm_atomic.LoadUint64(&m.afterGetCounter) < 1 {
		m.t.Error("Expected call to ClientMock.Get")
	}
}

type mClientMockMemberAdd struct {
	mock               *ClientMock
	defaultExpectation *ClientMockMemberAddExpectation
	expectations       []*ClientMockMemberAddExpectation

	callArgs []*ClientMockMemberAddParams
	mutex    sync.RWMutex
}

// ClientMockMemberAddExpectation specifies expectation struct of the Client.MemberAdd
type ClientMockMemberAddExpectation struct {
	mock    *ClientMock
	params  *ClientMockMemberAddParams
	results *ClientMockMemberAddResults
	Counter uint64
}

// ClientMockMemberAddParams contains parameters of the Client.MemberAdd
type ClientMockMemberAddParams struct {
	ctx       context.Context
	peerAddrs []string
}

// ClientMockMemberAddResults contains results of the Client.MemberAdd
type ClientMockMemberAddResults struct {
	mp1 *clientv3.MemberAddResponse
	err error
}

// Expect sets up expected params for Client.MemberAdd
func (mmMemberAdd *mClientMockMemberAdd) Expect(ctx context.Context, peerAddrs []string) *mClientMockMemberAdd {
	if mmMemberAdd.mock.funcMemberAdd != nil {
		mmMemberAdd.mock.t.Fatalf("ClientMock.MemberAdd mock is already set by Set")
	}

	if mmMemberAdd.defaultExpectation == nil {
		mmMemberAdd.defaultExpectation = &ClientMockMemberAddExpectation{}
	}

	mmMemberAdd.defaultExpectation.params = &ClientMockMemberAddParams{ctx, peerAddrs}
	for _, e := range mmMemberAdd.expectations {
		if minimock.Equal(e.params, mmMemberAdd.defaultExpectation.params) {
			mmMemberAdd.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmMemberAdd.defaultExpectation.params)
		}
	}

	return mmMemberAdd
}

// Inspect accepts an inspector function that has same arguments as the Client.MemberAdd
func (mmMemberAdd *mClientMockMemberAdd) Inspect(f func(ctx context.Context, peerAddrs []string)) *mClientMockMemberAdd {
	if mmMemberAdd.mock.inspectFuncMemberAdd != nil {
		mmMemberAdd.mock.t.Fatalf("Inspect function is already set for ClientMock.MemberAdd")
	}

	mmMemberAdd.mock.inspectFuncMemberAdd = f

	return mmMemberAdd
}

// Return sets up results that will be returned by Client.MemberAdd
func (mmMemberAdd *mClientMockMemberAdd) Return(mp1 *clientv3.MemberAddResponse, err error) *ClientMock {
	if mmMemberAdd.mock.funcMemberAdd != nil {
		mmMemberAdd.mock.t.Fatalf("ClientMock.MemberAdd mock is already set by Set")
	}

	if mmMemberAdd.defaultExpectation == nil {
		mmMemberAdd.defaultExpectation = &ClientMockMemberAddExpectation{mock: mmMemberAdd.mock}
	}
	mmMemberAdd.defaultExpectation.results = &ClientMockMemberAddResults{mp1, err}
	return mmMemberAdd.mock
}

//Set uses given function f to mock the Client.MemberAdd method
func (mmMemberAdd *mClientMockMemberAdd) Set(f func(ctx context.Context, peerAddrs []string) (mp1 *clientv3.MemberAddResponse, err error)) *ClientMock {
	if mmMemberAdd.defaultExpectation != nil {
		mmMemberAdd.mock.t.Fatalf("Default expectation is already set for the Client.MemberAdd method")
	}

	if len(mmMemberAdd.expectations) > 0 {
		mmMemberAdd.mock.t.Fatalf("Some expectations are already set for the Client.MemberAdd method")
	}

	mmMemberAdd.mock.funcMemberAdd = f
	return mmMemberAdd.mock
}

// When sets expectation for the Client.MemberAdd which will trigger the result defined by the following
// Then helper
func (mmMemberAdd *mClientMockMemberAdd) When(ctx context.Context, peerAddrs []string) *ClientMockMemberAddExpectation {
	if mmMemberAdd.mock.funcMemberAdd != nil {
		mmMemberAdd.mock.t.Fatalf("ClientMock.MemberAdd mock is already set by Set")
	}

	expectation := &ClientMockMemberAddExpectation{
		mock:   mmMemberAdd.mock,
		params: &ClientMockMemberAddParams{ctx, peerAddrs},
	}
	mmMemberAdd.expectations = append(mmMemberAdd.expectations, expectation)
	return expectation
}

// Then sets up Client.MemberAdd return parameters for the expectation previously defined by the When method
func (e *ClientMockMemberAddExpectation) Then(mp1 *clientv3.MemberAddResponse, err error) *ClientMock {
	e.results = &ClientMockMemberAddResults{mp1, err}
	return e.mock
}

// MemberAdd implements Client
func (mmMemberAdd *ClientMock) MemberAdd(ctx context.Context, peerAddrs []string) (mp1 *clientv3.MemberAddResponse, err error) {
	mm_atomic.AddUint64(&mmMemberAdd.beforeMemberAddCounter, 1)
	defer mm_atomic.AddUint64(&mmMemberAdd.afterMemberAddCounter, 1)

	if mmMemberAdd.inspectFuncMemberAdd != nil {
		mmMemberAdd.inspectFuncMemberAdd(ctx, peerAddrs)
	}

	mm_params := &ClientMockMemberAddParams{ctx, peerAddrs}

	// Record call args
	mmMemberAdd.MemberAddMock.mutex.Lock()
	mmMemberAdd.MemberAddMock.callArgs = append(mmMemberAdd.MemberAddMock.callArgs, mm_params)
	mmMemberAdd.MemberAddMock.mutex.Unlock()

	for _, e := range mmMemberAdd.MemberAddMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.mp1, e.results.err
		}
	}

	if mmMemberAdd.MemberAddMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmMemberAdd.MemberAddMock.defaultExpectation.Counter, 1)
		mm_want := mmMemberAdd.MemberAddMock.defaultExpectation.params
		mm_got := ClientMockMemberAddParams{ctx, peerAddrs}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmMemberAdd.t.Errorf("ClientMock.MemberAdd got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmMemberAdd.MemberAddMock.defaultExpectation.results
		if mm_results == nil {
			mmMemberAdd.t.Fatal("No results are set for the ClientMock.MemberAdd")
		}
		return (*mm_results).mp1, (*mm_results).err
	}
	if mmMemberAdd.funcMemberAdd != nil {
		return mmMemberAdd.funcMemberAdd(ctx, peerAddrs)
	}
	mmMemberAdd.t.Fatalf("Unexpected call to ClientMock.MemberAdd. %v %v", ctx, peerAddrs)
	return
}

// MemberAddAfterCounter returns a count of finished ClientMock.MemberAdd invocations
func (mmMemberAdd *ClientMock) MemberAddAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmMemberAdd.afterMemberAddCounter)
}

// MemberAddBeforeCounter returns a count of ClientMock.MemberAdd invocations
func (mmMemberAdd *ClientMock) MemberAddBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmMemberAdd.beforeMemberAddCounter)
}

// Calls returns a list of arguments used in each call to ClientMock.MemberAdd.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmMemberAdd *mClientMockMemberAdd) Calls() []*ClientMockMemberAddParams {
	mmMemberAdd.mutex.RLock()

	argCopy := make([]*ClientMockMemberAddParams, len(mmMemberAdd.callArgs))
	copy(argCopy, mmMemberAdd.callArgs)

	mmMemberAdd.mutex.RUnlock()

	return argCopy
}

// MinimockMemberAddDone returns true if the count of the MemberAdd invocations corresponds
// the number of defined expectations
func (m *ClientMock) MinimockMemberAddDone() bool {
	for _, e := range m.MemberAddMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.MemberAddMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterMemberAddCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcMemberAdd != nil && mm_atomic.LoadUint64(&m.afterMemberAddCounter) < 1 {
		return false
	}
	return true
}

// MinimockMemberAddInspect logs each unmet expectation
func (m *ClientMock) MinimockMemberAddInspect() {
	for _, e := range m.MemberAddMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ClientMock.MemberAdd with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.MemberAddMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterMemberAddCounter) < 1 {
		if m.MemberAddMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to ClientMock.MemberAdd")
		} else {
			m.t.Errorf("Expected call to ClientMock.MemberAdd with params: %#v", *m.MemberAddMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcMemberAdd != nil && mm_atomic.LoadUint64(&m.afterMemberAddCounter) < 1 {
		m.t.Error("Expected call to ClientMock.MemberAdd")
	}
}

type mClientMockMemberAddAsLearner struct {
	mock               *ClientMock
	defaultExpectation *ClientMockMemberAddAsLearnerExpectation
	expectations       []*ClientMockMemberAddAsLearnerExpectation

	callArgs []*ClientMockMemberAddAsLearnerParams
	mutex    sync.RWMutex
}

// ClientMockMemberAddAsLearnerExpectation specifies expectation struct of the Client.MemberAddAsLearner
type ClientMockMemberAddAsLearnerExpectation struct {
	mock    *ClientMock
	params  *ClientMockMemberAddAsLearnerParams
	results *ClientMockMemberAddAsLearnerResults
	Counter uint64
}

// ClientMockMemberAddAsLearnerParams contains parameters of the Client.MemberAddAsLearner
type ClientMockMemberAddAsLearnerParams struct {
	ctx       context.Context
	peerAddrs []string
}

// ClientMockMemberAddAsLearnerResults contains results of the Client.MemberAddAsLearner
type ClientMockMemberAddAsLearnerResults struct {
	mp1 *clientv3.MemberAddResponse
	err error
}

// Expect sets up expected params for Client.MemberAddAsLearner
func (mmMemberAddAsLearner *mClientMockMemberAddAsLearner) Expect(ctx context.Context, peerAddrs []string) *mClientMockMemberAddAsLearner {
	if mmMemberAddAsLearner.mock.funcMemberAddAsLearner != nil {
		mmMemberAddAsLearner.mock.t.Fatalf("ClientMock.MemberAddAsLearner mock is already set by Set")
	}

	if mmMemberAddAsLearner.defaultExpectation == nil {
		mmMemberAddAsLearner.defaultExpectation = &ClientMockMemberAddAsLearnerExpectation{}
	}

	mmMemberAddAsLearner.defaultExpectation.params = &ClientMockMemberAddAsLearnerParams{ctx, peerAddrs}
	for _, e := range mmMemberAddAsLearner.expectations {
		if minimock.Equal(e.params, mmMemberAddAsLearner.defaultExpectation.params) {
			mmMemberAddAsLearner.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmMemberAddAsLearner.defaultExpectation.params)
		}
	}

	return mmMemberAddAsLearner
}

// Inspect accepts an inspector function that has same arguments as the Client.MemberAddAsLearner
func (mmMemberAddAsLearner *mClientMockMemberAddAsLearner) Inspect(f func(ctx context.Context, peerAddrs []string)) *mClientMockMemberAddAsLearner {
	if mmMemberAddAsLearner.mock.inspectFuncMemberAddAsLearner != nil {
		mmMemberAddAsLearner.mock.t.Fatalf("Inspect function is already set for ClientMock.MemberAddAsLearner")
	}

	mmMemberAddAsLearner.mock.inspectFuncMemberAddAsLearner = f

	return mmMemberAddAsLearner
}

// Return sets up results that will be returned by Client.MemberAddAsLearner
func (mmMemberAddAsLearner *mClientMockMemberAddAsLearner) Return(mp1 *clientv3.MemberAddResponse, err error) *ClientMock {
	if mmMemberAddAsLearner.mock.funcMemberAddAsLearner != nil {
		mmMemberAddAsLearner.mock.t.Fatalf("ClientMock.MemberAddAsLearner mock is already set by Set")
	}

	if mmMemberAddAsLearner.defaultExpectation == nil {
		mmMemberAddAsLearner.defaultExpectation = &ClientMockMemberAddAsLearnerExpectation{mock: mmMemberAddAsLearner.mock}
	}
	mmMemberAddAsLearner.defaultExpectation.results = &ClientMockMemberAddAsLearnerResults{mp1, err}
	return mmMemberAddAsLearner.mock
}

//Set uses given function f to mock the Client.MemberAddAsLearner method
func (mmMemberAddAsLearner *mClientMockMemberAddAsLearner) Set(f func(ctx context.Context, peerAddrs []string) (mp1 *clientv3.MemberAddResponse, err error)) *ClientMock {
	if mmMemberAddAsLearner.defaultExpectation != nil {
		mmMemberAddAsLearner.mock.t.Fatalf("Default expectation is already set for the Client.MemberAddAsLearner method")
	}

	if len(mmMemberAddAsLearner.expectations) > 0 {
		mmMemberAddAsLearner.mock.t.Fatalf("Some expectations are already set for the Client.MemberAddAsLearner method")
	}

	mmMemberAddAsLearner.mock.funcMemberAddAsLearner = f
	return mmMemberAddAsLearner.mock
}

// When sets expectation for the Client.MemberAddAsLearner which will trigger the result defined by the following
// Then helper
func (mmMemberAddAsLearner *mClientMockMemberAddAsLearner) When(ctx context.Context, peerAddrs []string) *ClientMockMemberAddAsLearnerExpectation {
	if mmMemberAddAsLearner.mock.funcMemberAddAsLearner != nil {
		mmMemberAddAsLearner.mock.t.Fatalf("ClientMock.MemberAddAsLearner mock is already set by Set")
	}

	expectation := &ClientMockMemberAddAsLearnerExpectation{
		mock:   mmMemberAddAsLearner.mock,
		params: &ClientMockMemberAddAsLearnerParams{ctx, peerAddrs},
	}
	mmMemberAddAsLearner.expectations = append(mmMemberAddAsLearner.expectations, expectation)
	return expectation
}

// Then sets up Client.MemberAddAsLearner return parameters for the expectation previously defined by the When method
func (e *ClientMockMemberAddAsLearnerExpectation) Then(mp1 *clientv3.MemberAddResponse, err error) *ClientMock {
	e.results = &ClientMockMemberAddAsLearnerResults{mp1, err}
	return e.mock
}

// MemberAddAsLearner implements Client
func (mmMemberAddAsLearner *ClientMock) MemberAddAsLearner(ctx context.Context, peerAddrs []string) (mp1 *clientv3.MemberAddResponse, err error) {
	mm_atomic.AddUint64(&mmMemberAddAsLearner.beforeMemberAddAsLearnerCounter, 1)
	defer mm_atomic.AddUint64(&mmMemberAddAsLearner.afterMemberAddAsLearnerCounter, 1)

	if mmMemberAddAsLearner.inspectFuncMemberAddAsLearner != nil {
		mmMemberAddAsLearner.inspectFuncMemberAddAsLearner(ctx, peerAddrs)
	}

	mm_params := &ClientMockMemberAddAsLearnerParams{ctx, peerAddrs}

	// Record call args
	mmMemberAddAsLearner.MemberAddAsLearnerMock.mutex.Lock()
	mmMemberAddAsLearner.MemberAddAsLearnerMock.callArgs = append(mmMemberAddAsLearner.MemberAddAsLearnerMock.callArgs, mm_params)
	mmMemberAddAsLearner.MemberAddAsLearnerMock.mutex.Unlock()

	for _, e := range mmMemberAddAsLearner.MemberAddAsLearnerMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.mp1, e.results.err
		}
	}

	if mmMemberAddAsLearner.MemberAddAsLearnerMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmMemberAddAsLearner.MemberAddAsLearnerMock.defaultExpectation.Counter, 1)
		mm_want := mmMemberAddAsLearner.MemberAddAsLearnerMock.defaultExpectation.params
		mm_got := ClientMockMemberAddAsLearnerParams{ctx, peerAddrs}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmMemberAddAsLearner.t.Errorf("ClientMock.MemberAddAsLearner got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmMemberAddAsLearner.MemberAddAsLearnerMock.defaultExpectation.results
		if mm_results == nil {
			mmMemberAddAsLearner.t.Fatal("No results are set for the ClientMock.MemberAddAsLearner")
		}
		return (*mm_results).mp1, (*mm_results).err
	}
	if mmMemberAddAsLearner.funcMemberAddAsLearner != nil {
		return mmMemberAddAsLearner.funcMemberAddAsLearner(ctx, peerAddrs)
	}
	mmMemberAddAsLearner.t.Fatalf("Unexpected call to ClientMock.MemberAddAsLearner. %v %v", ctx, peerAddrs)
	return
}

// MemberAddAsLearnerAfterCounter returns a count of finished ClientMock.MemberAddAsLearner invocations
func (mmMemberAddAsLearner *ClientMock) MemberAddAsLearnerAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmMemberAddAsLearner.afterMemberAddAsLearnerCounter)
}

// MemberAddAsLearnerBeforeCounter returns a count of ClientMock.MemberAddAsLearner invocations
func (mmMemberAddAsLearner *ClientMock) MemberAddAsLearnerBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmMemberAddAsLearner.beforeMemberAddAsLearnerCounter)
}

// Calls returns a list of arguments used in each call to ClientMock.MemberAddAsLearner.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmMemberAddAsLearner *mClientMockMemberAddAsLearner) Calls() []*ClientMockMemberAddAsLearnerParams {
	mmMemberAddAsLearner.mutex.RLock()

	argCopy := make([]*ClientMockMemberAddAsLearnerParams, len(mmMemberAddAsLearner.callArgs))
	copy(argCopy, mmMemberAddAsLearner.callArgs)

	mmMemberAddAsLearner.mutex.RUnlock()

	return argCopy
}

// MinimockMemberAddAsLearnerDone returns true if the count of the MemberAddAsLearner invocations corresponds
// the number of defined expectations
func (m *ClientMock) MinimockMemberAddAsLearnerDone() bool {
	for _, e := range m.MemberAddAsLearnerMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.MemberAddAsLearnerMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterMemberAddAsLearnerCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcMemberAddAsLearner != nil && mm_atomic.LoadUint64(&m.afterMemberAddAsLearnerCounter) < 1 {
		return false
	}
	return true
}

// MinimockMemberAddAsLearnerInspect logs each unmet expectation
func (m *ClientMock) MinimockMemberAddAsLearnerInspect() {
	for _, e := range m.MemberAddAsLearnerMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ClientMock.MemberAddAsLearner with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.MemberAddAsLearnerMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterMemberAddAsLearnerCounter) < 1 {
		if m.MemberAddAsLearnerMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to ClientMock.MemberAddAsLearner")
		} else {
			m.t.Errorf("Expected call to ClientMock.MemberAddAsLearner with params: %#v", *m.MemberAddAsLearnerMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcMemberAddAsLearner != nil && mm_atomic.LoadUint64(&m.afterMemberAddAsLearnerCounter) < 1 {
		m.t.Error("Expected call to ClientMock.MemberAddAsLearner")
	}
}

type mClientMockMemberList struct {
	mock               *ClientMock
	defaultExpectation *ClientMockMemberListExpectation
	expectations       []*ClientMockMemberListExpectation

	callArgs []*ClientMockMemberListParams
	mutex    sync.RWMutex
}

// ClientMockMemberListExpectation specifies expectation struct of the Client.MemberList
type ClientMockMemberListExpectation struct {
	mock    *ClientMock
	params  *ClientMockMemberListParams
	results *ClientMockMemberListResults
	Counter uint64
}

// ClientMockMemberListParams contains parameters of the Client.MemberList
type ClientMockMemberListParams struct {
	ctx context.Context
}

// ClientMockMemberListResults contains results of the Client.MemberList
type ClientMockMemberListResults struct {
	mp1 *clientv3.MemberListResponse
	err error
}

// Expect sets up expected params for Client.MemberList
func (mmMemberList *mClientMockMemberList) Expect(ctx context.Context) *mClientMockMemberList {
	if mmMemberList.mock.funcMemberList != nil {
		mmMemberList.mock.t.Fatalf("ClientMock.MemberList mock is already set by Set")
	}

	if mmMemberList.defaultExpectation == nil {
		mmMemberList.defaultExpectation = &ClientMockMemberListExpectation{}
	}

	mmMemberList.defaultExpectation.params = &ClientMockMemberListParams{ctx}
	for _, e := range mmMemberList.expectations {
		if minimock.Equal(e.params, mmMemberList.defaultExpectation.params) {
			mmMemberList.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmMemberList.defaultExpectation.params)
		}
	}

	return mmMemberList
}

// Inspect accepts an inspector function that has same arguments as the Client.MemberList
func (mmMemberList *mClientMockMemberList) Inspect(f func(ctx context.Context)) *mClientMockMemberList {
	if mmMemberList.mock.inspectFuncMemberList != nil {
		mmMemberList.mock.t.Fatalf("Inspect function is already set for ClientMock.MemberList")
	}

	mmMemberList.mock.inspectFuncMemberList = f

	return mmMemberList
}

// Return sets up results that will be returned by Client.MemberList
func (mmMemberList *mClientMockMemberList) Return(mp1 *clientv3.MemberListResponse, err error) *ClientMock {
	if mmMemberList.mock.funcMemberList != nil {
		mmMemberList.mock.t.Fatalf("ClientMock.MemberList mock is already set by Set")
	}

	if mmMemberList.defaultExpectation == nil {
		mmMemberList.defaultExpectation = &ClientMockMemberListExpectation{mock: mmMemberList.mock}
	}
	mmMemberList.defaultExpectation.results = &ClientMockMemberListResults{mp1, err}
	return mmMemberList.mock
}

//Set uses given function f to mock the Client.MemberList method
func (mmMemberList *mClientMockMemberList) Set(f func(ctx context.Context) (mp1 *clientv3.MemberListResponse, err error)) *ClientMock {
	if mmMemberList.defaultExpectation != nil {
		mmMemberList.mock.t.Fatalf("Default expectation is already set for the Client.MemberList method")
	}

	if len(mmMemberList.expectations) > 0 {
		mmMemberList.mock.t.Fatalf("Some expectations are already set for the Client.MemberList method")
	}

	mmMemberList.mock.funcMemberList = f
	return mmMemberList.mock
}

// When sets expectation for the Client.MemberList which will trigger the result defined by the following
// Then helper
func (mmMemberList *mClientMockMemberList) When(ctx context.Context) *ClientMockMemberListExpectation {
	if mmMemberList.mock.funcMemberList != nil {
		mmMemberList.mock.t.Fatalf("ClientMock.MemberList mock is already set by Set")
	}

	expectation := &ClientMockMemberListExpectation{
		mock:   mmMemberList.mock,
		params: &ClientMockMemberListParams{ctx},
	}
	mmMemberList.expectations = append(mmMemberList.expectations, expectation)
	return expectation
}

// Then sets up Client.MemberList return parameters for the expectation previously defined by the When method
func (e *ClientMockMemberListExpectation) Then(mp1 *clientv3.MemberListResponse, err error) *ClientMock {
	e.results = &ClientMockMemberListResults{mp1, err}
	return e.mock
}

// MemberList implements Client
func (mmMemberList *ClientMock) MemberList(ctx context.Context) (mp1 *clientv3.MemberListResponse, err error) {
	mm_atomic.AddUint64(&mmMemberList.beforeMemberListCounter, 1)
	defer mm_atomic.AddUint64(&mmMemberList.afterMemberListCounter, 1)

	if mmMemberList.inspectFuncMemberList != nil {
		mmMemberList.inspectFuncMemberList(ctx)
	}

	mm_params := &ClientMockMemberListParams{ctx}

	// Record call args
	mmMemberList.MemberListMock.mutex.Lock()
	mmMemberList.MemberListMock.callArgs = append(mmMemberList.MemberListMock.callArgs, mm_params)
	mmMemberList.MemberListMock.mutex.Unlock()

	for _, e := range mmMemberList.MemberListMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.mp1, e.results.err
		}
	}

	if mmMemberList.MemberListMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmMemberList.MemberListMock.defaultExpectation.Counter, 1)
		mm_want := mmMemberList.MemberListMock.defaultExpectation.params
		mm_got := ClientMockMemberListParams{ctx}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmMemberList.t.Errorf("ClientMock.MemberList got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmMemberList.MemberListMock.defaultExpectation.results
		if mm_results == nil {
			mmMemberList.t.Fatal("No results are set for the ClientMock.MemberList")
		}
		return (*mm_results).mp1, (*mm_results).err
	}
	if mmMemberList.funcMemberList != nil {
		return mmMemberList.funcMemberList(ctx)
	}
	mmMemberList.t.Fatalf("Unexpected call to ClientMock.MemberList. %v", ctx)
	return
}

// MemberListAfterCounter returns a count of finished ClientMock.MemberList invocations
func (mmMemberList *ClientMock) MemberListAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmMemberList.afterMemberListCounter)
}

// MemberListBeforeCounter returns a count of ClientMock.MemberList invocations
func (mmMemberList *ClientMock) MemberListBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmMemberList.beforeMemberListCounter)
}

// Calls returns a list of arguments used in each call to ClientMock.MemberList.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmMemberList *mClientMockMemberList) Calls() []*ClientMockMemberListParams {
	mmMemberList.mutex.RLock()

	argCopy := make([]*ClientMockMemberListParams, len(mmMemberList.callArgs))
	copy(argCopy, mmMemberList.callArgs)

	mmMemberList.mutex.RUnlock()

	return argCopy
}

// MinimockMemberListDone returns true if the count of the MemberList invocations corresponds
// the number of defined expectations
func (m *ClientMock) MinimockMemberListDone() bool {
	for _, e := range m.MemberListMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.MemberListMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterMemberListCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcMemberList != nil && mm_atomic.LoadUint64(&m.afterMemberListCounter) < 1 {
		return false
	}
	return true
}

// MinimockMemberListInspect logs each unmet expectation
func (m *ClientMock) MinimockMemberListInspect() {
	for _, e := range m.MemberListMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ClientMock.MemberList with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.MemberListMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterMemberListCounter) < 1 {
		if m.MemberListMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to ClientMock.MemberList")
		} else {
			m.t.Errorf("Expected call to ClientMock.MemberList with params: %#v", *m.MemberListMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcMemberList != nil && mm_atomic.LoadUint64(&m.afterMemberListCounter) < 1 {
		m.t.Error("Expected call to ClientMock.MemberList")
	}
}

type mClientMockMemberPromote struct {
	mock               *ClientMock
	defaultExpectation *ClientMockMemberPromoteExpectation
	expectations       []*ClientMockMemberPromoteExpectation

	callArgs []*ClientMockMemberPromoteParams
	mutex    sync.RWMutex
}

// ClientMockMemberPromoteExpectation specifies expectation struct of the Client.MemberPromote
type ClientMockMemberPromoteExpectation struct {
	mock    *ClientMock
	params  *ClientMockMemberPromoteParams
	results *ClientMockMemberPromoteResults
	Counter uint64
}

// ClientMockMemberPromoteParams contains parameters of the Client.MemberPromote
type ClientMockMemberPromoteParams struct {
	ctx context.Context
	id  uint64
}

// ClientMockMemberPromoteResults contains results of the Client.MemberPromote
type ClientMockMemberPromoteResults struct {
	mp1 *clientv3.MemberPromoteResponse
	err error
}

// Expect sets up expected params for Client.MemberPromote
func (mmMemberPromote *mClientMockMemberPromote) Expect(ctx context.Context, id uint64) *mClientMockMemberPromote {
	if mmMemberPromote.mock.funcMemberPromote != nil {
		mmMemberPromote.mock.t.Fatalf("ClientMock.MemberPromote mock is already set by Set")
	}

	if mmMemberPromote.defaultExpectation == nil {
		mmMemberPromote.defaultExpectation = &ClientMockMemberPromoteExpectation{}
	}

	mmMemberPromote.defaultExpectation.params = &ClientMockMemberPromoteParams{ctx, id}
	for _, e := range mmMemberPromote.expectations {
		if minimock.Equal(e.params, mmMemberPromote.defaultExpectation.params) {
			mmMemberPromote.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmMemberPromote.defaultExpectation.params)
		}
	}

	return mmMemberPromote
}

// Inspect accepts an inspector function that has same arguments as the Client.MemberPromote
func (mmMemberPromote *mClientMockMemberPromote) Inspect(f func(ctx context.Context, id uint64)) *mClientMockMemberPromote {
	if mmMemberPromote.mock.inspectFuncMemberPromote != nil {
		mmMemberPromote.mock.t.Fatalf("Inspect function is already set for ClientMock.MemberPromote")
	}

	mmMemberPromote.mock.inspectFuncMemberPromote = f

	return mmMemberPromote
}

// Return sets up results that will be returned by Client.MemberPromote
func (mmMemberPromote *mClientMockMemberPromote) Return(mp1 *clientv3.MemberPromoteResponse, err error) *ClientMock {
	if mmMemberPromote.mock.funcMemberPromote != nil {
		mmMemberPromote.mock.t.Fatalf("ClientMock.MemberPromote mock is already set by Set")
	}

	if mmMemberPromote.defaultExpectation == nil {
		mmMemberPromote.defaultExpectation = &ClientMockMemberPromoteExpectation{mock: mmMemberPromote.mock}
	}
	mmMemberPromote.defaultExpectation.results = &ClientMockMemberPromoteResults{mp1, err}
	return mmMemberPromote.mock
}

//Set uses given function f to mock the Client.MemberPromote method
func (mmMemberPromote *mClientMockMemberPromote) Set(f func(ctx context.Context, id uint64) (mp1 *clientv3.MemberPromoteResponse, err error)) *ClientMock {
	if mmMemberPromote.defaultExpectation != nil {
		mmMemberPromote.mock.t.Fatalf("Default expectation is already set for the Client.MemberPromote method")
	}

	if len(mmMemberPromote.expectations) > 0 {
		mmMemberPromote.mock.t.Fatalf("Some expectations are already set for the Client.MemberPromote method")
	}

	mmMemberPromote.mock.funcMemberPromote = f
	return mmMemberPromote.mock
}

// When sets expectation for the Client.MemberPromote which will trigger the result defined by the following
// Then helper
func (mmMemberPromote *mClientMockMemberPromote) When(ctx context.Context, id uint64) *ClientMockMemberPromoteExpectation {
	if mmMemberPromote.mock.funcMemberPromote != nil {
		mmMemberPromote.mock.t.Fatalf("ClientMock.MemberPromote mock is already set by Set")
	}

	expectation := &ClientMockMemberPromoteExpectation{
		mock:   mmMemberPromote.mock,
		params: &ClientMockMemberPromoteParams{ctx, id},
	}
	mmMemberPromote.expectations = append(mmMemberPromote.expectations, expectation)
	return expectation
}

// Then sets up Client.MemberPromote return parameters for the expectation previously defined by the When method
func (e *ClientMockMemberPromoteExpectation) Then(mp1 *clientv3.MemberPromoteResponse, err error) *ClientMock {
	e.results = &ClientMockMemberPromoteResults{mp1, err}
	return e.mock
}

// MemberPromote implements Client
func (mmMemberPromote *ClientMock) MemberPromote(ctx context.Context, id uint64) (mp1 *clientv3.MemberPromoteResponse, err error) {
	mm_atomic.AddUint64(&mmMemberPromote.beforeMemberPromoteCounter, 1)
	defer mm_atomic.AddUint64(&mmMemberPromote.afterMemberPromoteCounter, 1)

	if mmMemberPromote.inspectFuncMemberPromote != nil {
		mmMemberPromote.inspectFuncMemberPromote(ctx, id)
	}

	mm_params := &ClientMockMemberPromoteParams{ctx, id}

	// Record call args
	mmMemberPromote.MemberPromoteMock.mutex.Lock()
	mmMemberPromote.MemberPromoteMock.callArgs = append(mmMemberPromote.MemberPromoteMock.callArgs, mm_params)
	mmMemberPromote.MemberPromoteMock.mutex.Unlock()

	for _, e := range mmMemberPromote.MemberPromoteMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.mp1, e.results.err
		}
	}

	if mmMemberPromote.MemberPromoteMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmMemberPromote.MemberPromoteMock.defaultExpectation.Counter, 1)
		mm_want := mmMemberPromote.MemberPromoteMock.defaultExpectation.params
		mm_got := ClientMockMemberPromoteParams{ctx, id}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmMemberPromote.t.Errorf("ClientMock.MemberPromote got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmMemberPromote.MemberPromoteMock.defaultExpectation.results
		if mm_results == nil {
			mmMemberPromote.t.Fatal("No results are set for the ClientMock.MemberPromote")
		}
		return (*mm_results).mp1, (*mm_results).err
	}
	if mmMemberPromote.funcMemberPromote != nil {
		return mmMemberPromote.funcMemberPromote(ctx, id)
	}
	mmMemberPromote.t.Fatalf("Unexpected call to ClientMock.MemberPromote. %v %v", ctx, id)
	return
}

// MemberPromoteAfterCounter returns a count of finished ClientMock.MemberPromote invocations
func (mmMemberPromote *ClientMock) MemberPromoteAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmMemberPromote.afterMemberPromoteCounter)
}

// MemberPromoteBeforeCounter returns a count of ClientMock.MemberPromote invocations
func (mmMemberPromote *ClientMock) MemberPromoteBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmMemberPromote.beforeMemberPromoteCounter)
}

// Calls returns a list of arguments used in each call to ClientMock.MemberPromote.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmMemberPromote *mClientMockMemberPromote) Calls() []*ClientMockMemberPromoteParams {
	mmMemberPromote.mutex.RLock()

	argCopy := make([]*ClientMockMemberPromoteParams, len(mmMemberPromote.callArgs))
	copy(argCopy, mmMemberPromote.callArgs)

	mmMemberPromote.mutex.RUnlock()

	return argCopy
}

// MinimockMemberPromoteDone returns true if the count of the MemberPromote invocations corresponds
// the number of defined expectations
func (m *ClientMock) MinimockMemberPromoteDone() bool {
	for _, e := range m.MemberPromoteMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.MemberPromoteMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterMemberPromoteCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcMemberPromote != nil && mm_atomic.LoadUint64(&m.afterMemberPromoteCounter) < 1 {
		return false
	}
	return true
}

// MinimockMemberPromoteInspect logs each unmet expectation
func (m *ClientMock) MinimockMemberPromoteInspect() {
	for _, e := range m.MemberPromoteMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ClientMock.MemberPromote with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.MemberPromoteMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterMemberPromoteCounter) < 1 {
		if m.MemberPromoteMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to ClientMock.MemberPromote")
		} else {
			m.t.Errorf("Expected call to ClientMock.MemberPromote with params: %#v", *m.MemberPromoteMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcMemberPromote != nil && mm_atomic.LoadUint64(&m.afterMemberPromoteCounter) < 1 {
		m.t.Error("Expected call to ClientMock.MemberPromote")
	}
}

type mClientMockMemberRemove struct {
	mock               *ClientMock
	defaultExpectation *ClientMockMemberRemoveExpectation
	expectations       []*ClientMockMemberRemoveExpectation

	callArgs []*ClientMockMemberRemoveParams
	mutex    sync.RWMutex
}

// ClientMockMemberRemoveExpectation specifies expectation struct of the Client.MemberRemove
type ClientMockMemberRemoveExpectation struct {
	mock    *ClientMock
	params  *ClientMockMemberRemoveParams
	results *ClientMockMemberRemoveResults
	Counter uint64
}

// ClientMockMemberRemoveParams contains parameters of the Client.MemberRemove
type ClientMockMemberRemoveParams struct {
	ctx context.Context
	id  uint64
}

// ClientMockMemberRemoveResults contains results of the Client.MemberRemove
type ClientMockMemberRemoveResults struct {
	mp1 *clientv3.MemberRemoveResponse
	err error
}

// Expect sets up expected params for Client.MemberRemove
func (mmMemberRemove *mClientMockMemberRemove) Expect(ctx context.Context, id uint64) *mClientMockMemberRemove {
	if mmMemberRemove.mock.funcMemberRemove != nil {
		mmMemberRemove.mock.t.Fatalf("ClientMock.MemberRemove mock is already set by Set")
	}

	if mmMemberRemove.defaultExpectation == nil {
		mmMemberRemove.defaultExpectation = &ClientMockMemberRemoveExpectation{}
	}

	mmMemberRemove.defaultExpectation.params = &ClientMockMemberRemoveParams{ctx, id}
	for _, e := range mmMemberRemove.expectations {
		if minimock.Equal(e.params, mmMemberRemove.defaultExpectation.params) {
			mmMemberRemove.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmMemberRemove.defaultExpectation.params)
		}
	}

	return mmMemberRemove
}

// Inspect accepts an inspector function that has same arguments as the Client.MemberRemove
func (mmMemberRemove *mClientMockMemberRemove) Inspect(f func(ctx context.Context, id uint64)) *mClientMockMemberRemove {
	if mmMemberRemove.mock.inspectFuncMemberRemove != nil {
		mmMemberRemove.mock.t.Fatalf("Inspect function is already set for ClientMock.MemberRemove")
	}

	mmMemberRemove.mock.inspectFuncMemberRemove = f

	return mmMemberRemove
}

// Return sets up results that will be returned by Client.MemberRemove
func (mmMemberRemove *mClientMockMemberRemove) Return(mp1 *clientv3.MemberRemoveResponse, err error) *ClientMock {
	if mmMemberRemove.mock.funcMemberRemove != nil {
		mmMemberRemove.mock.t.Fatalf("ClientMock.MemberRemove mock is already set by Set")
	}

	if mmMemberRemove.defaultExpectation == nil {
		mmMemberRemove.defaultExpectation = &ClientMockMemberRemoveExpectation{mock: mmMemberRemove.mock}
	}
	mmMemberRemove.defaultExpectation.results = &ClientMockMemberRemoveResults{mp1, err}
	return mmMemberRemove.mock
}

//Set uses given function f to mock the Client.MemberRemove method
func (mmMemberRemove *mClientMockMemberRemove) Set(f func(ctx context.Context, id uint64) (mp1 *clientv3.MemberRemoveResponse, err error)) *ClientMock {
	if mmMemberRemove.defaultExpectation != nil {
		mmMemberRemove.mock.t.Fatalf("Default expectation is already set for the Client.MemberRemove method")
	}

	if len(mmMemberRemove.expectations) > 0 {
		mmMemberRemove.mock.t.Fatalf("Some expectations are already set for the Client.MemberRemove method")
	}

	mmMemberRemove.mock.funcMemberRemove = f
	return mmMemberRemove.mock
}

// When sets expectation for the Client.MemberRemove which will trigger the result defined by the following
// Then helper
func (mmMemberRemove *mClientMockMemberRemove) When(ctx context.Context, id uint64) *ClientMockMemberRemoveExpectation {
	if mmMemberRemove.mock.funcMemberRemove != nil {
		mmMemberRemove.mock.t.Fatalf("ClientMock.MemberRemove mock is already set by Set")
	}

	expectation := &ClientMockMemberRemoveExpectation{
		mock:   mmMemberRemove.mock,
		params: &ClientMockMemberRemoveParams{ctx, id},
	}
	mmMemberRemove.expectations = append(mmMemberRemove.expectations, expectation)
	return expectation
}

// Then sets up Client.MemberRemove return parameters for the expectation previously defined by the When method
func (e *ClientMockMemberRemoveExpectation) Then(mp1 *clientv3.MemberRemoveResponse, err error) *ClientMock {
	e.results = &ClientMockMemberRemoveResults{mp1, err}
	return e.mock
}

// MemberRemove implements Client
func (mmMemberRemove *ClientMock) MemberRemove(ctx context.Context, id uint64) (mp1 *clientv3.MemberRemoveResponse, err error) {
	mm_atomic.AddUint64(&mmMemberRemove.beforeMemberRemoveCounter, 1)
	defer mm_atomic.AddUint64(&mmMemberRemove.afterMemberRemoveCounter, 1)

	if mmMemberRemove.inspectFuncMemberRemove != nil {
		mmMemberRemove.inspectFuncMemberRemove(ctx, id)
	}

	mm_params := &ClientMockMemberRemoveParams{ctx, id}

	// Record call args
	mmMemberRemove.MemberRemoveMock.mutex.Lock()
	mmMemberRemove.MemberRemoveMock.callArgs = append(mmMemberRemove.MemberRemoveMock.callArgs, mm_params)
	mmMemberRemove.MemberRemoveMock.mutex.Unlock()

	for _, e := range mmMemberRemove.MemberRemoveMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.mp1, e.results.err
		}
	}

	if mmMemberRemove.MemberRemoveMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmMemberRemove.MemberRemoveMock.defaultExpectation.Counter, 1)
		mm_want := mmMemberRemove.MemberRemoveMock.defaultExpectation.params
		mm_got := ClientMockMemberRemoveParams{ctx, id}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmMemberRemove.t.Errorf("ClientMock.MemberRemove got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmMemberRemove.MemberRemoveMock.defaultExpectation.results
		if mm_results == nil {
			mmMemberRemove.t.Fatal("No results are set for the ClientMock.MemberRemove")
		}
		return (*mm_results).mp1, (*mm_results).err
	}
	if mmMemberRemove.funcMemberRemove != nil {
		return mmMemberRemove.funcMemberRemove(ctx, id)
	}
	mmMemberRemove.t.Fatalf("Unexpected call to ClientMock.MemberRemove. %v %v", ctx, id)
	return
}

// MemberRemoveAfterCounter returns a count of finished ClientMock.MemberRemove invocations
func (mmMemberRemove *ClientMock) MemberRemoveAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmMemberRemove.afterMemberRemoveCounter)
}

// MemberRemoveBeforeCounter returns a count of ClientMock.MemberRemove invocations
func (mmMemberRemove *ClientMock) MemberRemoveBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmMemberRemove.beforeMemberRemoveCounter)
}

// Calls returns a list of arguments used in each call to ClientMock.MemberRemove.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmMemberRemove *mClientMockMemberRemove) Calls() []*ClientMockMemberRemoveParams {
	mmMemberRemove.mutex.RLock()

	argCopy := make([]*ClientMockMemberRemoveParams, len(mmMemberRemove.callArgs))
	copy(argCopy, mmMemberRemove.callArgs)

	mmMemberRemove.mutex.RUnlock()

	return argCopy
}

// MinimockMemberRemoveDone returns true if the count of the MemberRemove invocations corresponds
// the number of defined expectations
func (m *ClientMock) MinimockMemberRemoveDone() bool {
	for _, e := range m.MemberRemoveMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.MemberRemoveMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterMemberRemoveCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcMemberRemove != nil && mm_atomic.LoadUint64(&m.afterMemberRemoveCounter) < 1 {
		return false
	}
	return true
}

// MinimockMemberRemoveInspect logs each unmet expectation
func (m *ClientMock) MinimockMemberRemoveInspect() {
	for _, e := range m.MemberRemoveMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ClientMock.MemberRemove with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.MemberRemoveMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterMemberRemoveCounter) < 1 {
		if m.MemberRemoveMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to ClientMock.MemberRemove")
		} else {
			m.t.Errorf("Expected call to ClientMock.MemberRemove with params: %#v", *m.MemberRemoveMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcMemberRemove != nil && mm_atomic.LoadUint64(&m.afterMemberRemoveCounter) < 1 {
		m.t.Error("Expected call to ClientMock.MemberRemove")
	}
}

type mClientMockMemberUpdate struct {
	mock               *ClientMock
	defaultExpectation *ClientMockMemberUpdateExpectation
	expectations       []*ClientMockMemberUpdateExpectation

	callArgs []*ClientMockMemberUpdateParams
	mutex    sync.RWMutex
}

// ClientMockMemberUpdateExpectation specifies expectation struct of the Client.MemberUpdate
type ClientMockMemberUpdateExpectation struct {
	mock    *ClientMock
	params  *ClientMockMemberUpdateParams
	results *ClientMockMemberUpdateResults
	Counter uint64
}

// ClientMockMemberUpdateParams contains parameters of the Client.MemberUpdate
type ClientMockMemberUpdateParams struct {
	ctx       context.Context
	id        uint64
	peerAddrs []string
}

// ClientMockMemberUpdateResults contains results of the Client.MemberUpdate
type ClientMockMemberUpdateResults struct {
	mp1 *clientv3.MemberUpdateResponse
	err error
}

// Expect sets up expected params for Client.MemberUpdate
func (mmMemberUpdate *mClientMockMemberUpdate) Expect(ctx context.Context, id uint64, peerAddrs []string) *mClientMockMemberUpdate {
	if mmMemberUpdate.mock.funcMemberUpdate != nil {
		mmMemberUpdate.mock.t.Fatalf("ClientMock.MemberUpdate mock is already set by Set")
	}

	if mmMemberUpdate.defaultExpectation == nil {
		mmMemberUpdate.defaultExpectation = &ClientMockMemberUpdateExpectation{}
	}

	mmMemberUpdate.defaultExpectation.params = &ClientMockMemberUpdateParams{ctx, id, peerAddrs}
	for _, e := range mmMemberUpdate.expectations {
		if minimock.Equal(e.params, mmMemberUpdate.defaultExpectation.params) {
			mmMemberUpdate.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmMemberUpdate.defaultExpectation.params)
		}
	}

	return mmMemberUpdate
}

// Inspect accepts an inspector function that has same arguments as the Client.MemberUpdate
func (mmMemberUpdate *mClientMockMemberUpdate) Inspect(f func(ctx context.Context, id uint64, peerAddrs []string)) *mClientMockMemberUpdate {
	if mmMemberUpdate.mock.inspectFuncMemberUpdate != nil {
		mmMemberUpdate.mock.t.Fatalf("Inspect function is already set for ClientMock.MemberUpdate")
	}

	mmMemberUpdate.mock.inspectFuncMemberUpdate = f

	return mmMemberUpdate
}

// Return sets up results that will be returned by Client.MemberUpdate
func (mmMemberUpdate *mClientMockMemberUpdate) Return(mp1 *clientv3.MemberUpdateResponse, err error) *ClientMock {
	if mmMemberUpdate.mock.funcMemberUpdate != nil {
		mmMemberUpdate.mock.t.Fatalf("ClientMock.MemberUpdate mock is already set by Set")
	}

	if mmMemberUpdate.defaultExpectation == nil {
		mmMemberUpdate.defaultExpectation = &ClientMockMemberUpdateExpectation{mock: mmMemberUpdate.mock}
	}
	mmMemberUpdate.defaultExpectation.results = &ClientMockMemberUpdateResults{mp1, err}
	return mmMemberUpdate.mock
}

//Set uses given function f to mock the Client.MemberUpdate method
func (mmMemberUpdate *mClientMockMemberUpdate) Set(f func(ctx context.Context, id uint64, peerAddrs []string) (mp1 *clientv3.MemberUpdateResponse, err error)) *ClientMock {
	if mmMemberUpdate.defaultExpectation != nil {
		mmMemberUpdate.mock.t.Fatalf("Default expectation is already set for the Client.MemberUpdate method")
	}

	if len(mmMemberUpdate.expectations) > 0 {
		mmMemberUpdate.mock.t.Fatalf("Some expectations are already set for the Client.MemberUpdate method")
	}

	mmMemberUpdate.mock.funcMemberUpdate = f
	return mmMemberUpdate.mock
}

// When sets expectation for the Client.MemberUpdate which will trigger the result defined by the following
// Then helper
func (mmMemberUpdate *mClientMockMemberUpdate) When(ctx context.Context, id uint64, peerAddrs []string) *ClientMockMemberUpdateExpectation {
	if mmMemberUpdate.mock.funcMemberUpdate != nil {
		mmMemberUpdate.mock.t.Fatalf("ClientMock.MemberUpdate mock is already set by Set")
	}

	expectation := &ClientMockMemberUpdateExpectation{
		mock:   mmMemberUpdate.mock,
		params: &ClientMockMemberUpdateParams{ctx, id, peerAddrs},
	}
	mmMemberUpdate.expectations = append(mmMemberUpdate.expectations, expectation)
	return expectation
}

// Then sets up Client.MemberUpdate return parameters for the expectation previously defined by the When method
func (e *ClientMockMemberUpdateExpectation) Then(mp1 *clientv3.MemberUpdateResponse, err error) *ClientMock {
	e.results = &ClientMockMemberUpdateResults{mp1, err}
	return e.mock
}

// MemberUpdate implements Client
func (mmMemberUpdate *ClientMock) MemberUpdate(ctx context.Context, id uint64, peerAddrs []string) (mp1 *clientv3.MemberUpdateResponse, err error) {
	mm_atomic.AddUint64(&mmMemberUpdate.beforeMemberUpdateCounter, 1)
	defer mm_atomic.AddUint64(&mmMemberUpdate.afterMemberUpdateCounter, 1)

	if mmMemberUpdate.inspectFuncMemberUpdate != nil {
		mmMemberUpdate.inspectFuncMemberUpdate(ctx, id, peerAddrs)
	}

	mm_params := &ClientMockMemberUpdateParams{ctx, id, peerAddrs}

	// Record call args
	mmMemberUpdate.MemberUpdateMock.mutex.Lock()
	mmMemberUpdate.MemberUpdateMock.callArgs = append(mmMemberUpdate.MemberUpdateMock.callArgs, mm_params)
	mmMemberUpdate.MemberUpdateMock.mutex.Unlock()

	for _, e := range mmMemberUpdate.MemberUpdateMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.mp1, e.results.err
		}
	}

	if mmMemberUpdate.MemberUpdateMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmMemberUpdate.MemberUpdateMock.defaultExpectation.Counter, 1)
		mm_want := mmMemberUpdate.MemberUpdateMock.defaultExpectation.params
		mm_got := ClientMockMemberUpdateParams{ctx, id, peerAddrs}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmMemberUpdate.t.Errorf("ClientMock.MemberUpdate got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmMemberUpdate.MemberUpdateMock.defaultExpectation.results
		if mm_results == nil {
			mmMemberUpdate.t.Fatal("No results are set for the ClientMock.MemberUpdate")
		}
		return (*mm_results).mp1, (*mm_results).err
	}
	if mmMemberUpdate.funcMemberUpdate != nil {
		return mmMemberUpdate.funcMemberUpdate(ctx, id, peerAddrs)
	}
	mmMemberUpdate.t.Fatalf("Unexpected call to ClientMock.MemberUpdate. %v %v %v", ctx, id, peerAddrs)
	return
}

// MemberUpdateAfterCounter returns a count of finished ClientMock.MemberUpdate invocations
func (mmMemberUpdate *ClientMock) MemberUpdateAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmMemberUpdate.afterMemberUpdateCounter)
}

// MemberUpdateBeforeCounter returns a count of ClientMock.MemberUpdate invocations
func (mmMemberUpdate *ClientMock) MemberUpdateBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmMemberUpdate.beforeMemberUpdateCounter)
}

// Calls returns a list of arguments used in each call to ClientMock.MemberUpdate.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmMemberUpdate *mClientMockMemberUpdate) Calls() []*ClientMockMemberUpdateParams {
	mmMemberUpdate.mutex.RLock()

	argCopy := make([]*ClientMockMemberUpdateParams, len(mmMemberUpdate.callArgs))
	copy(argCopy, mmMemberUpdate.callArgs)

	mmMemberUpdate.mutex.RUnlock()

	return argCopy
}

// MinimockMemberUpdateDone returns true if the count of the MemberUpdate invocations corresponds
// the number of defined expectations
func (m *ClientMock) MinimockMemberUpdateDone() bool {
	for _, e := range m.MemberUpdateMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.MemberUpdateMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterMemberUpdateCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcMemberUpdate != nil && mm_atomic.LoadUint64(&m.afterMemberUpdateCounter) < 1 {
		return false
	}
	return true
}

// MinimockMemberUpdateInspect logs each unmet expectation
func (m *ClientMock) MinimockMemberUpdateInspect() {
	for _, e := range m.MemberUpdateMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ClientMock.MemberUpdate with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.MemberUpdateMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterMemberUpdateCounter) < 1 {
		if m.MemberUpdateMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to ClientMock.MemberUpdate")
		} else {
			m.t.Errorf("Expected call to ClientMock.MemberUpdate with params: %#v", *m.MemberUpdateMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcMemberUpdate != nil && mm_atomic.LoadUint64(&m.afterMemberUpdateCounter) < 1 {
		m.t.Error("Expected call to ClientMock.MemberUpdate")
	}
}

type mClientMockPut struct {
	mock               *ClientMock
	defaultExpectation *ClientMockPutExpectation
	expectations       []*ClientMockPutExpectation

	callArgs []*ClientMockPutParams
	mutex    sync.RWMutex
}

// ClientMockPutExpectation specifies expectation struct of the Client.Put
type ClientMockPutExpectation struct {
	mock    *ClientMock
	params  *ClientMockPutParams
	results *ClientMockPutResults
	Counter uint64
}

// ClientMockPutParams contains parameters of the Client.Put
type ClientMockPutParams struct {
	ctx  context.Context
	key  string
	val  string
	opts []clientv3.OpOption
}

// ClientMockPutResults contains results of the Client.Put
type ClientMockPutResults struct {
	pp1 *clientv3.PutResponse
	err error
}

// Expect sets up expected params for Client.Put
func (mmPut *mClientMockPut) Expect(ctx context.Context, key string, val string, opts ...clientv3.OpOption) *mClientMockPut {
	if mmPut.mock.funcPut != nil {
		mmPut.mock.t.Fatalf("ClientMock.Put mock is already set by Set")
	}

	if mmPut.defaultExpectation == nil {
		mmPut.defaultExpectation = &ClientMockPutExpectation{}
	}

	mmPut.defaultExpectation.params = &ClientMockPutParams{ctx, key, val, opts}
	for _, e := range mmPut.expectations {
		if minimock.Equal(e.params, mmPut.defaultExpectation.params) {
			mmPut.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmPut.defaultExpectation.params)
		}
	}

	return mmPut
}

// Inspect accepts an inspector function that has same arguments as the Client.Put
func (mmPut *mClientMockPut) Inspect(f func(ctx context.Context, key string, val string, opts ...clientv3.OpOption)) *mClientMockPut {
	if mmPut.mock.inspectFuncPut != nil {
		mmPut.mock.t.Fatalf("Inspect function is already set for ClientMock.Put")
	}

	mmPut.mock.inspectFuncPut = f

	return mmPut
}

// Return sets up results that will be returned by Client.Put
func (mmPut *mClientMockPut) Return(pp1 *clientv3.PutResponse, err error) *ClientMock {
	if mmPut.mock.funcPut != nil {
		mmPut.mock.t.Fatalf("ClientMock.Put mock is already set by Set")
	}

	if mmPut.defaultExpectation == nil {
		mmPut.defaultExpectation = &ClientMockPutExpectation{mock: mmPut.mock}
	}
	mmPut.defaultExpectation.results = &ClientMockPutResults{pp1, err}
	return mmPut.mock
}

//Set uses given function f to mock the Client.Put method
func (mmPut *mClientMockPut) Set(f func(ctx context.Context, key string, val string, opts ...clientv3.OpOption) (pp1 *clientv3.PutResponse, err error)) *ClientMock {
	if mmPut.defaultExpectation != nil {
		mmPut.mock.t.Fatalf("Default expectation is already set for the Client.Put method")
	}

	if len(mmPut.expectations) > 0 {
		mmPut.mock.t.Fatalf("Some expectations are already set for the Client.Put method")
	}

	mmPut.mock.funcPut = f
	return mmPut.mock
}

// When sets expectation for the Client.Put which will trigger the result defined by the following
// Then helper
func (mmPut *mClientMockPut) When(ctx context.Context, key string, val string, opts ...clientv3.OpOption) *ClientMockPutExpectation {
	if mmPut.mock.funcPut != nil {
		mmPut.mock.t.Fatalf("ClientMock.Put mock is already set by Set")
	}

	expectation := &ClientMockPutExpectation{
		mock:   mmPut.mock,
		params: &ClientMockPutParams{ctx, key, val, opts},
	}
	mmPut.expectations = append(mmPut.expectations, expectation)
	return expectation
}

// Then sets up Client.Put return parameters for the expectation previously defined by the When method
func (e *ClientMockPutExpectation) Then(pp1 *clientv3.PutResponse, err error) *ClientMock {
	e.results = &ClientMockPutResults{pp1, err}
	return e.mock
}

// Put implements Client
func (mmPut *ClientMock) Put(ctx context.Context, key string, val string, opts ...clientv3.OpOption) (pp1 *clientv3.PutResponse, err error) {
	mm_atomic.AddUint64(&mmPut.beforePutCounter, 1)
	defer mm_atomic.AddUint64(&mmPut.afterPutCounter, 1)

	if mmPut.inspectFuncPut != nil {
		mmPut.inspectFuncPut(ctx, key, val, opts...)
	}

	mm_params := &ClientMockPutParams{ctx, key, val, opts}

	// Record call args
	mmPut.PutMock.mutex.Lock()
	mmPut.PutMock.callArgs = append(mmPut.PutMock.callArgs, mm_params)
	mmPut.PutMock.mutex.Unlock()

	for _, e := range mmPut.PutMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.pp1, e.results.err
		}
	}

	if mmPut.PutMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmPut.PutMock.defaultExpectation.Counter, 1)
		mm_want := mmPut.PutMock.defaultExpectation.params
		mm_got := ClientMockPutParams{ctx, key, val, opts}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmPut.t.Errorf("ClientMock.Put got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmPut.PutMock.defaultExpectation.results
		if mm_results == nil {
			mmPut.t.Fatal("No results are set for the ClientMock.Put")
		}
		return (*mm_results).pp1, (*mm_results).err
	}
	if mmPut.funcPut != nil {
		return mmPut.funcPut(ctx, key, val, opts...)
	}
	mmPut.t.Fatalf("Unexpected call to ClientMock.Put. %v %v %v %v", ctx, key, val, opts)
	return
}

// PutAfterCounter returns a count of finished ClientMock.Put invocations
func (mmPut *ClientMock) PutAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmPut.afterPutCounter)
}

// PutBeforeCounter returns a count of ClientMock.Put invocations
func (mmPut *ClientMock) PutBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmPut.beforePutCounter)
}

// Calls returns a list of arguments used in each call to ClientMock.Put.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmPut *mClientMockPut) Calls() []*ClientMockPutParams {
	mmPut.mutex.RLock()

	argCopy := make([]*ClientMockPutParams, len(mmPut.callArgs))
	copy(argCopy, mmPut.callArgs)

	mmPut.mutex.RUnlock()

	return argCopy
}

// MinimockPutDone returns true if the count of the Put invocations corresponds
// the number of defined expectations
func (m *ClientMock) MinimockPutDone() bool {
	for _, e := range m.PutMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.PutMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterPutCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcPut != nil && mm_atomic.LoadUint64(&m.afterPutCounter) < 1 {
		return false
	}
	return true
}

// MinimockPutInspect logs each unmet expectation
func (m *ClientMock) MinimockPutInspect() {
	for _, e := range m.PutMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ClientMock.Put with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.PutMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterPutCounter) < 1 {
		if m.PutMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to ClientMock.Put")
		} else {
			m.t.Errorf("Expected call to ClientMock.Put with params: %#v", *m.PutMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcPut != nil && mm_atomic.LoadUint64(&m.afterPutCounter) < 1 {
		m.t.Error("Expected call to ClientMock.Put")
	}
}

type mClientMockRequestProgress struct {
	mock               *ClientMock
	defaultExpectation *ClientMockRequestProgressExpectation
	expectations       []*ClientMockRequestProgressExpectation

	callArgs []*ClientMockRequestProgressParams
	mutex    sync.RWMutex
}

// ClientMockRequestProgressExpectation specifies expectation struct of the Client.RequestProgress
type ClientMockRequestProgressExpectation struct {
	mock    *ClientMock
	params  *ClientMockRequestProgressParams
	results *ClientMockRequestProgressResults
	Counter uint64
}

// ClientMockRequestProgressParams contains parameters of the Client.RequestProgress
type ClientMockRequestProgressParams struct {
	ctx context.Context
}

// ClientMockRequestProgressResults contains results of the Client.RequestProgress
type ClientMockRequestProgressResults struct {
	err error
}

// Expect sets up expected params for Client.RequestProgress
func (mmRequestProgress *mClientMockRequestProgress) Expect(ctx context.Context) *mClientMockRequestProgress {
	if mmRequestProgress.mock.funcRequestProgress != nil {
		mmRequestProgress.mock.t.Fatalf("ClientMock.RequestProgress mock is already set by Set")
	}

	if mmRequestProgress.defaultExpectation == nil {
		mmRequestProgress.defaultExpectation = &ClientMockRequestProgressExpectation{}
	}

	mmRequestProgress.defaultExpectation.params = &ClientMockRequestProgressParams{ctx}
	for _, e := range mmRequestProgress.expectations {
		if minimock.Equal(e.params, mmRequestProgress.defaultExpectation.params) {
			mmRequestProgress.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmRequestProgress.defaultExpectation.params)
		}
	}

	return mmRequestProgress
}

// Inspect accepts an inspector function that has same arguments as the Client.RequestProgress
func (mmRequestProgress *mClientMockRequestProgress) Inspect(f func(ctx context.Context)) *mClientMockRequestProgress {
	if mmRequestProgress.mock.inspectFuncRequestProgress != nil {
		mmRequestProgress.mock.t.Fatalf("Inspect function is already set for ClientMock.RequestProgress")
	}

	mmRequestProgress.mock.inspectFuncRequestProgress = f

	return mmRequestProgress
}

// Return sets up results that will be returned by Client.RequestProgress
func (mmRequestProgress *mClientMockRequestProgress) Return(err error) *ClientMock {
	if mmRequestProgress.mock.funcRequestProgress != nil {
		mmRequestProgress.mock.t.Fatalf("ClientMock.RequestProgress mock is already set by Set")
	}

	if mmRequestProgress.defaultExpectation == nil {
		mmRequestProgress.defaultExpectation = &ClientMockRequestProgressExpectation{mock: mmRequestProgress.mock}
	}
	mmRequestProgress.defaultExpectation.results = &ClientMockRequestProgressResults{err}
	return mmRequestProgress.mock
}

//Set uses given function f to mock the Client.RequestProgress method
func (mmRequestProgress *mClientMockRequestProgress) Set(f func(ctx context.Context) (err error)) *ClientMock {
	if mmRequestProgress.defaultExpectation != nil {
		mmRequestProgress.mock.t.Fatalf("Default expectation is already set for the Client.RequestProgress method")
	}

	if len(mmRequestProgress.expectations) > 0 {
		mmRequestProgress.mock.t.Fatalf("Some expectations are already set for the Client.RequestProgress method")
	}

	mmRequestProgress.mock.funcRequestProgress = f
	return mmRequestProgress.mock
}

// When sets expectation for the Client.RequestProgress which will trigger the result defined by the following
// Then helper
func (mmRequestProgress *mClientMockRequestProgress) When(ctx context.Context) *ClientMockRequestProgressExpectation {
	if mmRequestProgress.mock.funcRequestProgress != nil {
		mmRequestProgress.mock.t.Fatalf("ClientMock.RequestProgress mock is already set by Set")
	}

	expectation := &ClientMockRequestProgressExpectation{
		mock:   mmRequestProgress.mock,
		params: &ClientMockRequestProgressParams{ctx},
	}
	mmRequestProgress.expectations = append(mmRequestProgress.expectations, expectation)
	return expectation
}

// Then sets up Client.RequestProgress return parameters for the expectation previously defined by the When method
func (e *ClientMockRequestProgressExpectation) Then(err error) *ClientMock {
	e.results = &ClientMockRequestProgressResults{err}
	return e.mock
}

// RequestProgress implements Client
func (mmRequestProgress *ClientMock) RequestProgress(ctx context.Context) (err error) {
	mm_atomic.AddUint64(&mmRequestProgress.beforeRequestProgressCounter, 1)
	defer mm_atomic.AddUint64(&mmRequestProgress.afterRequestProgressCounter, 1)

	if mmRequestProgress.inspectFuncRequestProgress != nil {
		mmRequestProgress.inspectFuncRequestProgress(ctx)
	}

	mm_params := &ClientMockRequestProgressParams{ctx}

	// Record call args
	mmRequestProgress.RequestProgressMock.mutex.Lock()
	mmRequestProgress.RequestProgressMock.callArgs = append(mmRequestProgress.RequestProgressMock.callArgs, mm_params)
	mmRequestProgress.RequestProgressMock.mutex.Unlock()

	for _, e := range mmRequestProgress.RequestProgressMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmRequestProgress.RequestProgressMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmRequestProgress.RequestProgressMock.defaultExpectation.Counter, 1)
		mm_want := mmRequestProgress.RequestProgressMock.defaultExpectation.params
		mm_got := ClientMockRequestProgressParams{ctx}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmRequestProgress.t.Errorf("ClientMock.RequestProgress got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmRequestProgress.RequestProgressMock.defaultExpectation.results
		if mm_results == nil {
			mmRequestProgress.t.Fatal("No results are set for the ClientMock.RequestProgress")
		}
		return (*mm_results).err
	}
	if mmRequestProgress.funcRequestProgress != nil {
		return mmRequestProgress.funcRequestProgress(ctx)
	}
	mmRequestProgress.t.Fatalf("Unexpected call to ClientMock.RequestProgress. %v", ctx)
	return
}

// RequestProgressAfterCounter returns a count of finished ClientMock.RequestProgress invocations
func (mmRequestProgress *ClientMock) RequestProgressAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmRequestProgress.afterRequestProgressCounter)
}

// RequestProgressBeforeCounter returns a count of ClientMock.RequestProgress invocations
func (mmRequestProgress *ClientMock) RequestProgressBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmRequestProgress.beforeRequestProgressCounter)
}

// Calls returns a list of arguments used in each call to ClientMock.RequestProgress.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmRequestProgress *mClientMockRequestProgress) Calls() []*ClientMockRequestProgressParams {
	mmRequestProgress.mutex.RLock()

	argCopy := make([]*ClientMockRequestProgressParams, len(mmRequestProgress.callArgs))
	copy(argCopy, mmRequestProgress.callArgs)

	mmRequestProgress.mutex.RUnlock()

	return argCopy
}

// MinimockRequestProgressDone returns true if the count of the RequestProgress invocations corresponds
// the number of defined expectations
func (m *ClientMock) MinimockRequestProgressDone() bool {
	for _, e := range m.RequestProgressMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.RequestProgressMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterRequestProgressCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcRequestProgress != nil && mm_atomic.LoadUint64(&m.afterRequestProgressCounter) < 1 {
		return false
	}
	return true
}

// MinimockRequestProgressInspect logs each unmet expectation
func (m *ClientMock) MinimockRequestProgressInspect() {
	for _, e := range m.RequestProgressMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ClientMock.RequestProgress with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.RequestProgressMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterRequestProgressCounter) < 1 {
		if m.RequestProgressMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to ClientMock.RequestProgress")
		} else {
			m.t.Errorf("Expected call to ClientMock.RequestProgress with params: %#v", *m.RequestProgressMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcRequestProgress != nil && mm_atomic.LoadUint64(&m.afterRequestProgressCounter) < 1 {
		m.t.Error("Expected call to ClientMock.RequestProgress")
	}
}

type mClientMockTxn struct {
	mock               *ClientMock
	defaultExpectation *ClientMockTxnExpectation
	expectations       []*ClientMockTxnExpectation

	callArgs []*ClientMockTxnParams
	mutex    sync.RWMutex
}

// ClientMockTxnExpectation specifies expectation struct of the Client.Txn
type ClientMockTxnExpectation struct {
	mock    *ClientMock
	params  *ClientMockTxnParams
	results *ClientMockTxnResults
	Counter uint64
}

// ClientMockTxnParams contains parameters of the Client.Txn
type ClientMockTxnParams struct {
	ctx context.Context
}

// ClientMockTxnResults contains results of the Client.Txn
type ClientMockTxnResults struct {
	t1 clientv3.Txn
}

// Expect sets up expected params for Client.Txn
func (mmTxn *mClientMockTxn) Expect(ctx context.Context) *mClientMockTxn {
	if mmTxn.mock.funcTxn != nil {
		mmTxn.mock.t.Fatalf("ClientMock.Txn mock is already set by Set")
	}

	if mmTxn.defaultExpectation == nil {
		mmTxn.defaultExpectation = &ClientMockTxnExpectation{}
	}

	mmTxn.defaultExpectation.params = &ClientMockTxnParams{ctx}
	for _, e := range mmTxn.expectations {
		if minimock.Equal(e.params, mmTxn.defaultExpectation.params) {
			mmTxn.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmTxn.defaultExpectation.params)
		}
	}

	return mmTxn
}

// Inspect accepts an inspector function that has same arguments as the Client.Txn
func (mmTxn *mClientMockTxn) Inspect(f func(ctx context.Context)) *mClientMockTxn {
	if mmTxn.mock.inspectFuncTxn != nil {
		mmTxn.mock.t.Fatalf("Inspect function is already set for ClientMock.Txn")
	}

	mmTxn.mock.inspectFuncTxn = f

	return mmTxn
}

// Return sets up results that will be returned by Client.Txn
func (mmTxn *mClientMockTxn) Return(t1 clientv3.Txn) *ClientMock {
	if mmTxn.mock.funcTxn != nil {
		mmTxn.mock.t.Fatalf("ClientMock.Txn mock is already set by Set")
	}

	if mmTxn.defaultExpectation == nil {
		mmTxn.defaultExpectation = &ClientMockTxnExpectation{mock: mmTxn.mock}
	}
	mmTxn.defaultExpectation.results = &ClientMockTxnResults{t1}
	return mmTxn.mock
}

//Set uses given function f to mock the Client.Txn method
func (mmTxn *mClientMockTxn) Set(f func(ctx context.Context) (t1 clientv3.Txn)) *ClientMock {
	if mmTxn.defaultExpectation != nil {
		mmTxn.mock.t.Fatalf("Default expectation is already set for the Client.Txn method")
	}

	if len(mmTxn.expectations) > 0 {
		mmTxn.mock.t.Fatalf("Some expectations are already set for the Client.Txn method")
	}

	mmTxn.mock.funcTxn = f
	return mmTxn.mock
}

// When sets expectation for the Client.Txn which will trigger the result defined by the following
// Then helper
func (mmTxn *mClientMockTxn) When(ctx context.Context) *ClientMockTxnExpectation {
	if mmTxn.mock.funcTxn != nil {
		mmTxn.mock.t.Fatalf("ClientMock.Txn mock is already set by Set")
	}

	expectation := &ClientMockTxnExpectation{
		mock:   mmTxn.mock,
		params: &ClientMockTxnParams{ctx},
	}
	mmTxn.expectations = append(mmTxn.expectations, expectation)
	return expectation
}

// Then sets up Client.Txn return parameters for the expectation previously defined by the When method
func (e *ClientMockTxnExpectation) Then(t1 clientv3.Txn) *ClientMock {
	e.results = &ClientMockTxnResults{t1}
	return e.mock
}

// Txn implements Client
func (mmTxn *ClientMock) Txn(ctx context.Context) (t1 clientv3.Txn) {
	mm_atomic.AddUint64(&mmTxn.beforeTxnCounter, 1)
	defer mm_atomic.AddUint64(&mmTxn.afterTxnCounter, 1)

	if mmTxn.inspectFuncTxn != nil {
		mmTxn.inspectFuncTxn(ctx)
	}

	mm_params := &ClientMockTxnParams{ctx}

	// Record call args
	mmTxn.TxnMock.mutex.Lock()
	mmTxn.TxnMock.callArgs = append(mmTxn.TxnMock.callArgs, mm_params)
	mmTxn.TxnMock.mutex.Unlock()

	for _, e := range mmTxn.TxnMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.t1
		}
	}

	if mmTxn.TxnMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmTxn.TxnMock.defaultExpectation.Counter, 1)
		mm_want := mmTxn.TxnMock.defaultExpectation.params
		mm_got := ClientMockTxnParams{ctx}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmTxn.t.Errorf("ClientMock.Txn got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmTxn.TxnMock.defaultExpectation.results
		if mm_results == nil {
			mmTxn.t.Fatal("No results are set for the ClientMock.Txn")
		}
		return (*mm_results).t1
	}
	if mmTxn.funcTxn != nil {
		return mmTxn.funcTxn(ctx)
	}
	mmTxn.t.Fatalf("Unexpected call to ClientMock.Txn. %v", ctx)
	return
}

// TxnAfterCounter returns a count of finished ClientMock.Txn invocations
func (mmTxn *ClientMock) TxnAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmTxn.afterTxnCounter)
}

// TxnBeforeCounter returns a count of ClientMock.Txn invocations
func (mmTxn *ClientMock) TxnBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmTxn.beforeTxnCounter)
}

// Calls returns a list of arguments used in each call to ClientMock.Txn.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmTxn *mClientMockTxn) Calls() []*ClientMockTxnParams {
	mmTxn.mutex.RLock()

	argCopy := make([]*ClientMockTxnParams, len(mmTxn.callArgs))
	copy(argCopy, mmTxn.callArgs)

	mmTxn.mutex.RUnlock()

	return argCopy
}

// MinimockTxnDone returns true if the count of the Txn invocations corresponds
// the number of defined expectations
func (m *ClientMock) MinimockTxnDone() bool {
	for _, e := range m.TxnMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.TxnMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterTxnCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcTxn != nil && mm_atomic.LoadUint64(&m.afterTxnCounter) < 1 {
		return false
	}
	return true
}

// MinimockTxnInspect logs each unmet expectation
func (m *ClientMock) MinimockTxnInspect() {
	for _, e := range m.TxnMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ClientMock.Txn with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.TxnMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterTxnCounter) < 1 {
		if m.TxnMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to ClientMock.Txn")
		} else {
			m.t.Errorf("Expected call to ClientMock.Txn with params: %#v", *m.TxnMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcTxn != nil && mm_atomic.LoadUint64(&m.afterTxnCounter) < 1 {
		m.t.Error("Expected call to ClientMock.Txn")
	}
}

type mClientMockWatch struct {
	mock               *ClientMock
	defaultExpectation *ClientMockWatchExpectation
	expectations       []*ClientMockWatchExpectation

	callArgs []*ClientMockWatchParams
	mutex    sync.RWMutex
}

// ClientMockWatchExpectation specifies expectation struct of the Client.Watch
type ClientMockWatchExpectation struct {
	mock    *ClientMock
	params  *ClientMockWatchParams
	results *ClientMockWatchResults
	Counter uint64
}

// ClientMockWatchParams contains parameters of the Client.Watch
type ClientMockWatchParams struct {
	ctx  context.Context
	key  string
	opts []clientv3.OpOption
}

// ClientMockWatchResults contains results of the Client.Watch
type ClientMockWatchResults struct {
	w1 clientv3.WatchChan
}

// Expect sets up expected params for Client.Watch
func (mmWatch *mClientMockWatch) Expect(ctx context.Context, key string, opts ...clientv3.OpOption) *mClientMockWatch {
	if mmWatch.mock.funcWatch != nil {
		mmWatch.mock.t.Fatalf("ClientMock.Watch mock is already set by Set")
	}

	if mmWatch.defaultExpectation == nil {
		mmWatch.defaultExpectation = &ClientMockWatchExpectation{}
	}

	mmWatch.defaultExpectation.params = &ClientMockWatchParams{ctx, key, opts}
	for _, e := range mmWatch.expectations {
		if minimock.Equal(e.params, mmWatch.defaultExpectation.params) {
			mmWatch.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmWatch.defaultExpectation.params)
		}
	}

	return mmWatch
}

// Inspect accepts an inspector function that has same arguments as the Client.Watch
func (mmWatch *mClientMockWatch) Inspect(f func(ctx context.Context, key string, opts ...clientv3.OpOption)) *mClientMockWatch {
	if mmWatch.mock.inspectFuncWatch != nil {
		mmWatch.mock.t.Fatalf("Inspect function is already set for ClientMock.Watch")
	}

	mmWatch.mock.inspectFuncWatch = f

	return mmWatch
}

// Return sets up results that will be returned by Client.Watch
func (mmWatch *mClientMockWatch) Return(w1 clientv3.WatchChan) *ClientMock {
	if mmWatch.mock.funcWatch != nil {
		mmWatch.mock.t.Fatalf("ClientMock.Watch mock is already set by Set")
	}

	if mmWatch.defaultExpectation == nil {
		mmWatch.defaultExpectation = &ClientMockWatchExpectation{mock: mmWatch.mock}
	}
	mmWatch.defaultExpectation.results = &ClientMockWatchResults{w1}
	return mmWatch.mock
}

//Set uses given function f to mock the Client.Watch method
func (mmWatch *mClientMockWatch) Set(f func(ctx context.Context, key string, opts ...clientv3.OpOption) (w1 clientv3.WatchChan)) *ClientMock {
	if mmWatch.defaultExpectation != nil {
		mmWatch.mock.t.Fatalf("Default expectation is already set for the Client.Watch method")
	}

	if len(mmWatch.expectations) > 0 {
		mmWatch.mock.t.Fatalf("Some expectations are already set for the Client.Watch method")
	}

	mmWatch.mock.funcWatch = f
	return mmWatch.mock
}

// When sets expectation for the Client.Watch which will trigger the result defined by the following
// Then helper
func (mmWatch *mClientMockWatch) When(ctx context.Context, key string, opts ...clientv3.OpOption) *ClientMockWatchExpectation {
	if mmWatch.mock.funcWatch != nil {
		mmWatch.mock.t.Fatalf("ClientMock.Watch mock is already set by Set")
	}

	expectation := &ClientMockWatchExpectation{
		mock:   mmWatch.mock,
		params: &ClientMockWatchParams{ctx, key, opts},
	}
	mmWatch.expectations = append(mmWatch.expectations, expectation)
	return expectation
}

// Then sets up Client.Watch return parameters for the expectation previously defined by the When method
func (e *ClientMockWatchExpectation) Then(w1 clientv3.WatchChan) *ClientMock {
	e.results = &ClientMockWatchResults{w1}
	return e.mock
}

// Watch implements Client
func (mmWatch *ClientMock) Watch(ctx context.Context, key string, opts ...clientv3.OpOption) (w1 clientv3.WatchChan) {
	mm_atomic.AddUint64(&mmWatch.beforeWatchCounter, 1)
	defer mm_atomic.AddUint64(&mmWatch.afterWatchCounter, 1)

	if mmWatch.inspectFuncWatch != nil {
		mmWatch.inspectFuncWatch(ctx, key, opts...)
	}

	mm_params := &ClientMockWatchParams{ctx, key, opts}

	// Record call args
	mmWatch.WatchMock.mutex.Lock()
	mmWatch.WatchMock.callArgs = append(mmWatch.WatchMock.callArgs, mm_params)
	mmWatch.WatchMock.mutex.Unlock()

	for _, e := range mmWatch.WatchMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.w1
		}
	}

	if mmWatch.WatchMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmWatch.WatchMock.defaultExpectation.Counter, 1)
		mm_want := mmWatch.WatchMock.defaultExpectation.params
		mm_got := ClientMockWatchParams{ctx, key, opts}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmWatch.t.Errorf("ClientMock.Watch got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmWatch.WatchMock.defaultExpectation.results
		if mm_results == nil {
			mmWatch.t.Fatal("No results are set for the ClientMock.Watch")
		}
		return (*mm_results).w1
	}
	if mmWatch.funcWatch != nil {
		return mmWatch.funcWatch(ctx, key, opts...)
	}
	mmWatch.t.Fatalf("Unexpected call to ClientMock.Watch. %v %v %v", ctx, key, opts)
	return
}

// WatchAfterCounter returns a count of finished ClientMock.Watch invocations
func (mmWatch *ClientMock) WatchAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmWatch.afterWatchCounter)
}

// WatchBeforeCounter returns a count of ClientMock.Watch invocations
func (mmWatch *ClientMock) WatchBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmWatch.beforeWatchCounter)
}

// Calls returns a list of arguments used in each call to ClientMock.Watch.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmWatch *mClientMockWatch) Calls() []*ClientMockWatchParams {
	mmWatch.mutex.RLock()

	argCopy := make([]*ClientMockWatchParams, len(mmWatch.callArgs))
	copy(argCopy, mmWatch.callArgs)

	mmWatch.mutex.RUnlock()

	return argCopy
}

// MinimockWatchDone returns true if the count of the Watch invocations corresponds
// the number of defined expectations
func (m *ClientMock) MinimockWatchDone() bool {
	for _, e := range m.WatchMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.WatchMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterWatchCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcWatch != nil && mm_atomic.LoadUint64(&m.afterWatchCounter) < 1 {
		return false
	}
	return true
}

// MinimockWatchInspect logs each unmet expectation
func (m *ClientMock) MinimockWatchInspect() {
	for _, e := range m.WatchMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ClientMock.Watch with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.WatchMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterWatchCounter) < 1 {
		if m.WatchMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to ClientMock.Watch")
		} else {
			m.t.Errorf("Expected call to ClientMock.Watch with params: %#v", *m.WatchMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcWatch != nil && mm_atomic.LoadUint64(&m.afterWatchCounter) < 1 {
		m.t.Error("Expected call to ClientMock.Watch")
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *ClientMock) MinimockFinish() {
	if !m.minimockDone() {
		m.MinimockCloseInspect()

		m.MinimockCompactInspect()

		m.MinimockDeleteInspect()

		m.MinimockDoInspect()

		m.MinimockGetInspect()

		m.MinimockMemberAddInspect()

		m.MinimockMemberAddAsLearnerInspect()

		m.MinimockMemberListInspect()

		m.MinimockMemberPromoteInspect()

		m.MinimockMemberRemoveInspect()

		m.MinimockMemberUpdateInspect()

		m.MinimockPutInspect()

		m.MinimockRequestProgressInspect()

		m.MinimockTxnInspect()

		m.MinimockWatchInspect()
		m.t.FailNow()
	}
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *ClientMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *ClientMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockCloseDone() &&
		m.MinimockCompactDone() &&
		m.MinimockDeleteDone() &&
		m.MinimockDoDone() &&
		m.MinimockGetDone() &&
		m.MinimockMemberAddDone() &&
		m.MinimockMemberAddAsLearnerDone() &&
		m.MinimockMemberListDone() &&
		m.MinimockMemberPromoteDone() &&
		m.MinimockMemberRemoveDone() &&
		m.MinimockMemberUpdateDone() &&
		m.MinimockPutDone() &&
		m.MinimockRequestProgressDone() &&
		m.MinimockTxnDone() &&
		m.MinimockWatchDone()
}
