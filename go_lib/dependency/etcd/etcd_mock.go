package etcd

// Code generated by http://github.com/gojuno/minimock (dev). DO NOT EDIT.

//go:generate minimock -i github.com/deckhouse/deckhouse/go_lib/dependency/etcd.Client -o ./etcd_mock.go

import (
	"context"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
	clientv3 "go.etcd.io/etcd/client/v3"
)

// ClientMock implements Client
type ClientMock struct {
	t minimock.Tester

	funcClose          func() (err error)
	inspectFuncClose   func()
	afterCloseCounter  uint64
	beforeCloseCounter uint64
	CloseMock          mClientMockClose

	funcCompact          func(ctx context.Context, rev int64, opts ...clientv3.CompactOption) (cp1 *clientv3.CompactResponse, err error)
	inspectFuncCompact   func(ctx context.Context, rev int64, opts ...clientv3.CompactOption)
	afterCompactCounter  uint64
	beforeCompactCounter uint64
	CompactMock          mClientMockCompact

	funcDelete          func(ctx context.Context, key string, opts ...clientv3.OpOption) (dp1 *clientv3.DeleteResponse, err error)
	inspectFuncDelete   func(ctx context.Context, key string, opts ...clientv3.OpOption)
	afterDeleteCounter  uint64
	beforeDeleteCounter uint64
	DeleteMock          mClientMockDelete

	funcDo          func(ctx context.Context, op clientv3.Op) (o1 clientv3.OpResponse, err error)
	inspectFuncDo   func(ctx context.Context, op clientv3.Op)
	afterDoCounter  uint64
	beforeDoCounter uint64
	DoMock          mClientMockDo

	funcGet          func(ctx context.Context, key string, opts ...clientv3.OpOption) (gp1 *clientv3.GetResponse, err error)
	inspectFuncGet   func(ctx context.Context, key string, opts ...clientv3.OpOption)
	afterGetCounter  uint64
	beforeGetCounter uint64
	GetMock          mClientMockGet

	funcPut          func(ctx context.Context, key string, val string, opts ...clientv3.OpOption) (pp1 *clientv3.PutResponse, err error)
	inspectFuncPut   func(ctx context.Context, key string, val string, opts ...clientv3.OpOption)
	afterPutCounter  uint64
	beforePutCounter uint64
	PutMock          mClientMockPut

	funcRequestProgress          func(ctx context.Context) (err error)
	inspectFuncRequestProgress   func(ctx context.Context)
	afterRequestProgressCounter  uint64
	beforeRequestProgressCounter uint64
	RequestProgressMock          mClientMockRequestProgress

	funcTxn          func(ctx context.Context) (t1 clientv3.Txn)
	inspectFuncTxn   func(ctx context.Context)
	afterTxnCounter  uint64
	beforeTxnCounter uint64
	TxnMock          mClientMockTxn

	funcWatch          func(ctx context.Context, key string, opts ...clientv3.OpOption) (w1 clientv3.WatchChan)
	inspectFuncWatch   func(ctx context.Context, key string, opts ...clientv3.OpOption)
	afterWatchCounter  uint64
	beforeWatchCounter uint64
	WatchMock          mClientMockWatch
}

// NewClientMock returns a mock for Client
func NewClientMock(t minimock.Tester) *ClientMock {
	m := &ClientMock{t: t}
	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.CloseMock = mClientMockClose{mock: m}

	m.CompactMock = mClientMockCompact{mock: m}
	m.CompactMock.callArgs = []*ClientMockCompactParams{}

	m.DeleteMock = mClientMockDelete{mock: m}
	m.DeleteMock.callArgs = []*ClientMockDeleteParams{}

	m.DoMock = mClientMockDo{mock: m}
	m.DoMock.callArgs = []*ClientMockDoParams{}

	m.GetMock = mClientMockGet{mock: m}
	m.GetMock.callArgs = []*ClientMockGetParams{}

	m.PutMock = mClientMockPut{mock: m}
	m.PutMock.callArgs = []*ClientMockPutParams{}

	m.RequestProgressMock = mClientMockRequestProgress{mock: m}
	m.RequestProgressMock.callArgs = []*ClientMockRequestProgressParams{}

	m.TxnMock = mClientMockTxn{mock: m}
	m.TxnMock.callArgs = []*ClientMockTxnParams{}

	m.WatchMock = mClientMockWatch{mock: m}
	m.WatchMock.callArgs = []*ClientMockWatchParams{}

	return m
}

type mClientMockClose struct {
	mock               *ClientMock
	defaultExpectation *ClientMockCloseExpectation
	expectations       []*ClientMockCloseExpectation
}

// ClientMockCloseExpectation specifies expectation struct of the Client.Close
type ClientMockCloseExpectation struct {
	mock *ClientMock

	results *ClientMockCloseResults
	Counter uint64
}

// ClientMockCloseResults contains results of the Client.Close
type ClientMockCloseResults struct {
	err error
}

// Expect sets up expected params for Client.Close
func (mmClose *mClientMockClose) Expect() *mClientMockClose {
	if mmClose.mock.funcClose != nil {
		mmClose.mock.t.Fatalf("ClientMock.Close mock is already set by Set")
	}

	if mmClose.defaultExpectation == nil {
		mmClose.defaultExpectation = &ClientMockCloseExpectation{}
	}

	return mmClose
}

// Inspect accepts an inspector function that has same arguments as the Client.Close
func (mmClose *mClientMockClose) Inspect(f func()) *mClientMockClose {
	if mmClose.mock.inspectFuncClose != nil {
		mmClose.mock.t.Fatalf("Inspect function is already set for ClientMock.Close")
	}

	mmClose.mock.inspectFuncClose = f

	return mmClose
}

// Return sets up results that will be returned by Client.Close
func (mmClose *mClientMockClose) Return(err error) *ClientMock {
	if mmClose.mock.funcClose != nil {
		mmClose.mock.t.Fatalf("ClientMock.Close mock is already set by Set")
	}

	if mmClose.defaultExpectation == nil {
		mmClose.defaultExpectation = &ClientMockCloseExpectation{mock: mmClose.mock}
	}
	mmClose.defaultExpectation.results = &ClientMockCloseResults{err}
	return mmClose.mock
}

//Set uses given function f to mock the Client.Close method
func (mmClose *mClientMockClose) Set(f func() (err error)) *ClientMock {
	if mmClose.defaultExpectation != nil {
		mmClose.mock.t.Fatalf("Default expectation is already set for the Client.Close method")
	}

	if len(mmClose.expectations) > 0 {
		mmClose.mock.t.Fatalf("Some expectations are already set for the Client.Close method")
	}

	mmClose.mock.funcClose = f
	return mmClose.mock
}

// Close implements Client
func (mmClose *ClientMock) Close() (err error) {
	mm_atomic.AddUint64(&mmClose.beforeCloseCounter, 1)
	defer mm_atomic.AddUint64(&mmClose.afterCloseCounter, 1)

	if mmClose.inspectFuncClose != nil {
		mmClose.inspectFuncClose()
	}

	if mmClose.CloseMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmClose.CloseMock.defaultExpectation.Counter, 1)

		mm_results := mmClose.CloseMock.defaultExpectation.results
		if mm_results == nil {
			mmClose.t.Fatal("No results are set for the ClientMock.Close")
		}
		return (*mm_results).err
	}
	if mmClose.funcClose != nil {
		return mmClose.funcClose()
	}
	mmClose.t.Fatalf("Unexpected call to ClientMock.Close.")
	return
}

// CloseAfterCounter returns a count of finished ClientMock.Close invocations
func (mmClose *ClientMock) CloseAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmClose.afterCloseCounter)
}

// CloseBeforeCounter returns a count of ClientMock.Close invocations
func (mmClose *ClientMock) CloseBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmClose.beforeCloseCounter)
}

// MinimockCloseDone returns true if the count of the Close invocations corresponds
// the number of defined expectations
func (m *ClientMock) MinimockCloseDone() bool {
	for _, e := range m.CloseMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.CloseMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterCloseCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcClose != nil && mm_atomic.LoadUint64(&m.afterCloseCounter) < 1 {
		return false
	}
	return true
}

// MinimockCloseInspect logs each unmet expectation
func (m *ClientMock) MinimockCloseInspect() {
	for _, e := range m.CloseMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to ClientMock.Close")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.CloseMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterCloseCounter) < 1 {
		m.t.Error("Expected call to ClientMock.Close")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcClose != nil && mm_atomic.LoadUint64(&m.afterCloseCounter) < 1 {
		m.t.Error("Expected call to ClientMock.Close")
	}
}

type mClientMockCompact struct {
	mock               *ClientMock
	defaultExpectation *ClientMockCompactExpectation
	expectations       []*ClientMockCompactExpectation

	callArgs []*ClientMockCompactParams
	mutex    sync.RWMutex
}

// ClientMockCompactExpectation specifies expectation struct of the Client.Compact
type ClientMockCompactExpectation struct {
	mock    *ClientMock
	params  *ClientMockCompactParams
	results *ClientMockCompactResults
	Counter uint64
}

// ClientMockCompactParams contains parameters of the Client.Compact
type ClientMockCompactParams struct {
	ctx  context.Context
	rev  int64
	opts []clientv3.CompactOption
}

// ClientMockCompactResults contains results of the Client.Compact
type ClientMockCompactResults struct {
	cp1 *clientv3.CompactResponse
	err error
}

// Expect sets up expected params for Client.Compact
func (mmCompact *mClientMockCompact) Expect(ctx context.Context, rev int64, opts ...clientv3.CompactOption) *mClientMockCompact {
	if mmCompact.mock.funcCompact != nil {
		mmCompact.mock.t.Fatalf("ClientMock.Compact mock is already set by Set")
	}

	if mmCompact.defaultExpectation == nil {
		mmCompact.defaultExpectation = &ClientMockCompactExpectation{}
	}

	mmCompact.defaultExpectation.params = &ClientMockCompactParams{ctx, rev, opts}
	for _, e := range mmCompact.expectations {
		if minimock.Equal(e.params, mmCompact.defaultExpectation.params) {
			mmCompact.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmCompact.defaultExpectation.params)
		}
	}

	return mmCompact
}

// Inspect accepts an inspector function that has same arguments as the Client.Compact
func (mmCompact *mClientMockCompact) Inspect(f func(ctx context.Context, rev int64, opts ...clientv3.CompactOption)) *mClientMockCompact {
	if mmCompact.mock.inspectFuncCompact != nil {
		mmCompact.mock.t.Fatalf("Inspect function is already set for ClientMock.Compact")
	}

	mmCompact.mock.inspectFuncCompact = f

	return mmCompact
}

// Return sets up results that will be returned by Client.Compact
func (mmCompact *mClientMockCompact) Return(cp1 *clientv3.CompactResponse, err error) *ClientMock {
	if mmCompact.mock.funcCompact != nil {
		mmCompact.mock.t.Fatalf("ClientMock.Compact mock is already set by Set")
	}

	if mmCompact.defaultExpectation == nil {
		mmCompact.defaultExpectation = &ClientMockCompactExpectation{mock: mmCompact.mock}
	}
	mmCompact.defaultExpectation.results = &ClientMockCompactResults{cp1, err}
	return mmCompact.mock
}

//Set uses given function f to mock the Client.Compact method
func (mmCompact *mClientMockCompact) Set(f func(ctx context.Context, rev int64, opts ...clientv3.CompactOption) (cp1 *clientv3.CompactResponse, err error)) *ClientMock {
	if mmCompact.defaultExpectation != nil {
		mmCompact.mock.t.Fatalf("Default expectation is already set for the Client.Compact method")
	}

	if len(mmCompact.expectations) > 0 {
		mmCompact.mock.t.Fatalf("Some expectations are already set for the Client.Compact method")
	}

	mmCompact.mock.funcCompact = f
	return mmCompact.mock
}

// When sets expectation for the Client.Compact which will trigger the result defined by the following
// Then helper
func (mmCompact *mClientMockCompact) When(ctx context.Context, rev int64, opts ...clientv3.CompactOption) *ClientMockCompactExpectation {
	if mmCompact.mock.funcCompact != nil {
		mmCompact.mock.t.Fatalf("ClientMock.Compact mock is already set by Set")
	}

	expectation := &ClientMockCompactExpectation{
		mock:   mmCompact.mock,
		params: &ClientMockCompactParams{ctx, rev, opts},
	}
	mmCompact.expectations = append(mmCompact.expectations, expectation)
	return expectation
}

// Then sets up Client.Compact return parameters for the expectation previously defined by the When method
func (e *ClientMockCompactExpectation) Then(cp1 *clientv3.CompactResponse, err error) *ClientMock {
	e.results = &ClientMockCompactResults{cp1, err}
	return e.mock
}

// Compact implements Client
func (mmCompact *ClientMock) Compact(ctx context.Context, rev int64, opts ...clientv3.CompactOption) (cp1 *clientv3.CompactResponse, err error) {
	mm_atomic.AddUint64(&mmCompact.beforeCompactCounter, 1)
	defer mm_atomic.AddUint64(&mmCompact.afterCompactCounter, 1)

	if mmCompact.inspectFuncCompact != nil {
		mmCompact.inspectFuncCompact(ctx, rev, opts...)
	}

	mm_params := &ClientMockCompactParams{ctx, rev, opts}

	// Record call args
	mmCompact.CompactMock.mutex.Lock()
	mmCompact.CompactMock.callArgs = append(mmCompact.CompactMock.callArgs, mm_params)
	mmCompact.CompactMock.mutex.Unlock()

	for _, e := range mmCompact.CompactMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.cp1, e.results.err
		}
	}

	if mmCompact.CompactMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCompact.CompactMock.defaultExpectation.Counter, 1)
		mm_want := mmCompact.CompactMock.defaultExpectation.params
		mm_got := ClientMockCompactParams{ctx, rev, opts}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmCompact.t.Errorf("ClientMock.Compact got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmCompact.CompactMock.defaultExpectation.results
		if mm_results == nil {
			mmCompact.t.Fatal("No results are set for the ClientMock.Compact")
		}
		return (*mm_results).cp1, (*mm_results).err
	}
	if mmCompact.funcCompact != nil {
		return mmCompact.funcCompact(ctx, rev, opts...)
	}
	mmCompact.t.Fatalf("Unexpected call to ClientMock.Compact. %v %v %v", ctx, rev, opts)
	return
}

// CompactAfterCounter returns a count of finished ClientMock.Compact invocations
func (mmCompact *ClientMock) CompactAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCompact.afterCompactCounter)
}

// CompactBeforeCounter returns a count of ClientMock.Compact invocations
func (mmCompact *ClientMock) CompactBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCompact.beforeCompactCounter)
}

// Calls returns a list of arguments used in each call to ClientMock.Compact.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmCompact *mClientMockCompact) Calls() []*ClientMockCompactParams {
	mmCompact.mutex.RLock()

	argCopy := make([]*ClientMockCompactParams, len(mmCompact.callArgs))
	copy(argCopy, mmCompact.callArgs)

	mmCompact.mutex.RUnlock()

	return argCopy
}

// MinimockCompactDone returns true if the count of the Compact invocations corresponds
// the number of defined expectations
func (m *ClientMock) MinimockCompactDone() bool {
	for _, e := range m.CompactMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.CompactMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterCompactCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCompact != nil && mm_atomic.LoadUint64(&m.afterCompactCounter) < 1 {
		return false
	}
	return true
}

// MinimockCompactInspect logs each unmet expectation
func (m *ClientMock) MinimockCompactInspect() {
	for _, e := range m.CompactMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ClientMock.Compact with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.CompactMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterCompactCounter) < 1 {
		if m.CompactMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to ClientMock.Compact")
		} else {
			m.t.Errorf("Expected call to ClientMock.Compact with params: %#v", *m.CompactMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCompact != nil && mm_atomic.LoadUint64(&m.afterCompactCounter) < 1 {
		m.t.Error("Expected call to ClientMock.Compact")
	}
}

type mClientMockDelete struct {
	mock               *ClientMock
	defaultExpectation *ClientMockDeleteExpectation
	expectations       []*ClientMockDeleteExpectation

	callArgs []*ClientMockDeleteParams
	mutex    sync.RWMutex
}

// ClientMockDeleteExpectation specifies expectation struct of the Client.Delete
type ClientMockDeleteExpectation struct {
	mock    *ClientMock
	params  *ClientMockDeleteParams
	results *ClientMockDeleteResults
	Counter uint64
}

// ClientMockDeleteParams contains parameters of the Client.Delete
type ClientMockDeleteParams struct {
	ctx  context.Context
	key  string
	opts []clientv3.OpOption
}

// ClientMockDeleteResults contains results of the Client.Delete
type ClientMockDeleteResults struct {
	dp1 *clientv3.DeleteResponse
	err error
}

// Expect sets up expected params for Client.Delete
func (mmDelete *mClientMockDelete) Expect(ctx context.Context, key string, opts ...clientv3.OpOption) *mClientMockDelete {
	if mmDelete.mock.funcDelete != nil {
		mmDelete.mock.t.Fatalf("ClientMock.Delete mock is already set by Set")
	}

	if mmDelete.defaultExpectation == nil {
		mmDelete.defaultExpectation = &ClientMockDeleteExpectation{}
	}

	mmDelete.defaultExpectation.params = &ClientMockDeleteParams{ctx, key, opts}
	for _, e := range mmDelete.expectations {
		if minimock.Equal(e.params, mmDelete.defaultExpectation.params) {
			mmDelete.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmDelete.defaultExpectation.params)
		}
	}

	return mmDelete
}

// Inspect accepts an inspector function that has same arguments as the Client.Delete
func (mmDelete *mClientMockDelete) Inspect(f func(ctx context.Context, key string, opts ...clientv3.OpOption)) *mClientMockDelete {
	if mmDelete.mock.inspectFuncDelete != nil {
		mmDelete.mock.t.Fatalf("Inspect function is already set for ClientMock.Delete")
	}

	mmDelete.mock.inspectFuncDelete = f

	return mmDelete
}

// Return sets up results that will be returned by Client.Delete
func (mmDelete *mClientMockDelete) Return(dp1 *clientv3.DeleteResponse, err error) *ClientMock {
	if mmDelete.mock.funcDelete != nil {
		mmDelete.mock.t.Fatalf("ClientMock.Delete mock is already set by Set")
	}

	if mmDelete.defaultExpectation == nil {
		mmDelete.defaultExpectation = &ClientMockDeleteExpectation{mock: mmDelete.mock}
	}
	mmDelete.defaultExpectation.results = &ClientMockDeleteResults{dp1, err}
	return mmDelete.mock
}

//Set uses given function f to mock the Client.Delete method
func (mmDelete *mClientMockDelete) Set(f func(ctx context.Context, key string, opts ...clientv3.OpOption) (dp1 *clientv3.DeleteResponse, err error)) *ClientMock {
	if mmDelete.defaultExpectation != nil {
		mmDelete.mock.t.Fatalf("Default expectation is already set for the Client.Delete method")
	}

	if len(mmDelete.expectations) > 0 {
		mmDelete.mock.t.Fatalf("Some expectations are already set for the Client.Delete method")
	}

	mmDelete.mock.funcDelete = f
	return mmDelete.mock
}

// When sets expectation for the Client.Delete which will trigger the result defined by the following
// Then helper
func (mmDelete *mClientMockDelete) When(ctx context.Context, key string, opts ...clientv3.OpOption) *ClientMockDeleteExpectation {
	if mmDelete.mock.funcDelete != nil {
		mmDelete.mock.t.Fatalf("ClientMock.Delete mock is already set by Set")
	}

	expectation := &ClientMockDeleteExpectation{
		mock:   mmDelete.mock,
		params: &ClientMockDeleteParams{ctx, key, opts},
	}
	mmDelete.expectations = append(mmDelete.expectations, expectation)
	return expectation
}

// Then sets up Client.Delete return parameters for the expectation previously defined by the When method
func (e *ClientMockDeleteExpectation) Then(dp1 *clientv3.DeleteResponse, err error) *ClientMock {
	e.results = &ClientMockDeleteResults{dp1, err}
	return e.mock
}

// Delete implements Client
func (mmDelete *ClientMock) Delete(ctx context.Context, key string, opts ...clientv3.OpOption) (dp1 *clientv3.DeleteResponse, err error) {
	mm_atomic.AddUint64(&mmDelete.beforeDeleteCounter, 1)
	defer mm_atomic.AddUint64(&mmDelete.afterDeleteCounter, 1)

	if mmDelete.inspectFuncDelete != nil {
		mmDelete.inspectFuncDelete(ctx, key, opts...)
	}

	mm_params := &ClientMockDeleteParams{ctx, key, opts}

	// Record call args
	mmDelete.DeleteMock.mutex.Lock()
	mmDelete.DeleteMock.callArgs = append(mmDelete.DeleteMock.callArgs, mm_params)
	mmDelete.DeleteMock.mutex.Unlock()

	for _, e := range mmDelete.DeleteMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.dp1, e.results.err
		}
	}

	if mmDelete.DeleteMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmDelete.DeleteMock.defaultExpectation.Counter, 1)
		mm_want := mmDelete.DeleteMock.defaultExpectation.params
		mm_got := ClientMockDeleteParams{ctx, key, opts}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmDelete.t.Errorf("ClientMock.Delete got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmDelete.DeleteMock.defaultExpectation.results
		if mm_results == nil {
			mmDelete.t.Fatal("No results are set for the ClientMock.Delete")
		}
		return (*mm_results).dp1, (*mm_results).err
	}
	if mmDelete.funcDelete != nil {
		return mmDelete.funcDelete(ctx, key, opts...)
	}
	mmDelete.t.Fatalf("Unexpected call to ClientMock.Delete. %v %v %v", ctx, key, opts)
	return
}

// DeleteAfterCounter returns a count of finished ClientMock.Delete invocations
func (mmDelete *ClientMock) DeleteAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDelete.afterDeleteCounter)
}

// DeleteBeforeCounter returns a count of ClientMock.Delete invocations
func (mmDelete *ClientMock) DeleteBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDelete.beforeDeleteCounter)
}

// Calls returns a list of arguments used in each call to ClientMock.Delete.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmDelete *mClientMockDelete) Calls() []*ClientMockDeleteParams {
	mmDelete.mutex.RLock()

	argCopy := make([]*ClientMockDeleteParams, len(mmDelete.callArgs))
	copy(argCopy, mmDelete.callArgs)

	mmDelete.mutex.RUnlock()

	return argCopy
}

// MinimockDeleteDone returns true if the count of the Delete invocations corresponds
// the number of defined expectations
func (m *ClientMock) MinimockDeleteDone() bool {
	for _, e := range m.DeleteMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.DeleteMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterDeleteCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDelete != nil && mm_atomic.LoadUint64(&m.afterDeleteCounter) < 1 {
		return false
	}
	return true
}

// MinimockDeleteInspect logs each unmet expectation
func (m *ClientMock) MinimockDeleteInspect() {
	for _, e := range m.DeleteMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ClientMock.Delete with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.DeleteMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterDeleteCounter) < 1 {
		if m.DeleteMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to ClientMock.Delete")
		} else {
			m.t.Errorf("Expected call to ClientMock.Delete with params: %#v", *m.DeleteMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDelete != nil && mm_atomic.LoadUint64(&m.afterDeleteCounter) < 1 {
		m.t.Error("Expected call to ClientMock.Delete")
	}
}

type mClientMockDo struct {
	mock               *ClientMock
	defaultExpectation *ClientMockDoExpectation
	expectations       []*ClientMockDoExpectation

	callArgs []*ClientMockDoParams
	mutex    sync.RWMutex
}

// ClientMockDoExpectation specifies expectation struct of the Client.Do
type ClientMockDoExpectation struct {
	mock    *ClientMock
	params  *ClientMockDoParams
	results *ClientMockDoResults
	Counter uint64
}

// ClientMockDoParams contains parameters of the Client.Do
type ClientMockDoParams struct {
	ctx context.Context
	op  clientv3.Op
}

// ClientMockDoResults contains results of the Client.Do
type ClientMockDoResults struct {
	o1  clientv3.OpResponse
	err error
}

// Expect sets up expected params for Client.Do
func (mmDo *mClientMockDo) Expect(ctx context.Context, op clientv3.Op) *mClientMockDo {
	if mmDo.mock.funcDo != nil {
		mmDo.mock.t.Fatalf("ClientMock.Do mock is already set by Set")
	}

	if mmDo.defaultExpectation == nil {
		mmDo.defaultExpectation = &ClientMockDoExpectation{}
	}

	mmDo.defaultExpectation.params = &ClientMockDoParams{ctx, op}
	for _, e := range mmDo.expectations {
		if minimock.Equal(e.params, mmDo.defaultExpectation.params) {
			mmDo.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmDo.defaultExpectation.params)
		}
	}

	return mmDo
}

// Inspect accepts an inspector function that has same arguments as the Client.Do
func (mmDo *mClientMockDo) Inspect(f func(ctx context.Context, op clientv3.Op)) *mClientMockDo {
	if mmDo.mock.inspectFuncDo != nil {
		mmDo.mock.t.Fatalf("Inspect function is already set for ClientMock.Do")
	}

	mmDo.mock.inspectFuncDo = f

	return mmDo
}

// Return sets up results that will be returned by Client.Do
func (mmDo *mClientMockDo) Return(o1 clientv3.OpResponse, err error) *ClientMock {
	if mmDo.mock.funcDo != nil {
		mmDo.mock.t.Fatalf("ClientMock.Do mock is already set by Set")
	}

	if mmDo.defaultExpectation == nil {
		mmDo.defaultExpectation = &ClientMockDoExpectation{mock: mmDo.mock}
	}
	mmDo.defaultExpectation.results = &ClientMockDoResults{o1, err}
	return mmDo.mock
}

//Set uses given function f to mock the Client.Do method
func (mmDo *mClientMockDo) Set(f func(ctx context.Context, op clientv3.Op) (o1 clientv3.OpResponse, err error)) *ClientMock {
	if mmDo.defaultExpectation != nil {
		mmDo.mock.t.Fatalf("Default expectation is already set for the Client.Do method")
	}

	if len(mmDo.expectations) > 0 {
		mmDo.mock.t.Fatalf("Some expectations are already set for the Client.Do method")
	}

	mmDo.mock.funcDo = f
	return mmDo.mock
}

// When sets expectation for the Client.Do which will trigger the result defined by the following
// Then helper
func (mmDo *mClientMockDo) When(ctx context.Context, op clientv3.Op) *ClientMockDoExpectation {
	if mmDo.mock.funcDo != nil {
		mmDo.mock.t.Fatalf("ClientMock.Do mock is already set by Set")
	}

	expectation := &ClientMockDoExpectation{
		mock:   mmDo.mock,
		params: &ClientMockDoParams{ctx, op},
	}
	mmDo.expectations = append(mmDo.expectations, expectation)
	return expectation
}

// Then sets up Client.Do return parameters for the expectation previously defined by the When method
func (e *ClientMockDoExpectation) Then(o1 clientv3.OpResponse, err error) *ClientMock {
	e.results = &ClientMockDoResults{o1, err}
	return e.mock
}

// Do implements Client
func (mmDo *ClientMock) Do(ctx context.Context, op clientv3.Op) (o1 clientv3.OpResponse, err error) {
	mm_atomic.AddUint64(&mmDo.beforeDoCounter, 1)
	defer mm_atomic.AddUint64(&mmDo.afterDoCounter, 1)

	if mmDo.inspectFuncDo != nil {
		mmDo.inspectFuncDo(ctx, op)
	}

	mm_params := &ClientMockDoParams{ctx, op}

	// Record call args
	mmDo.DoMock.mutex.Lock()
	mmDo.DoMock.callArgs = append(mmDo.DoMock.callArgs, mm_params)
	mmDo.DoMock.mutex.Unlock()

	for _, e := range mmDo.DoMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.o1, e.results.err
		}
	}

	if mmDo.DoMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmDo.DoMock.defaultExpectation.Counter, 1)
		mm_want := mmDo.DoMock.defaultExpectation.params
		mm_got := ClientMockDoParams{ctx, op}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmDo.t.Errorf("ClientMock.Do got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmDo.DoMock.defaultExpectation.results
		if mm_results == nil {
			mmDo.t.Fatal("No results are set for the ClientMock.Do")
		}
		return (*mm_results).o1, (*mm_results).err
	}
	if mmDo.funcDo != nil {
		return mmDo.funcDo(ctx, op)
	}
	mmDo.t.Fatalf("Unexpected call to ClientMock.Do. %v %v", ctx, op)
	return
}

// DoAfterCounter returns a count of finished ClientMock.Do invocations
func (mmDo *ClientMock) DoAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDo.afterDoCounter)
}

// DoBeforeCounter returns a count of ClientMock.Do invocations
func (mmDo *ClientMock) DoBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDo.beforeDoCounter)
}

// Calls returns a list of arguments used in each call to ClientMock.Do.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmDo *mClientMockDo) Calls() []*ClientMockDoParams {
	mmDo.mutex.RLock()

	argCopy := make([]*ClientMockDoParams, len(mmDo.callArgs))
	copy(argCopy, mmDo.callArgs)

	mmDo.mutex.RUnlock()

	return argCopy
}

// MinimockDoDone returns true if the count of the Do invocations corresponds
// the number of defined expectations
func (m *ClientMock) MinimockDoDone() bool {
	for _, e := range m.DoMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.DoMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterDoCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDo != nil && mm_atomic.LoadUint64(&m.afterDoCounter) < 1 {
		return false
	}
	return true
}

// MinimockDoInspect logs each unmet expectation
func (m *ClientMock) MinimockDoInspect() {
	for _, e := range m.DoMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ClientMock.Do with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.DoMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterDoCounter) < 1 {
		if m.DoMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to ClientMock.Do")
		} else {
			m.t.Errorf("Expected call to ClientMock.Do with params: %#v", *m.DoMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDo != nil && mm_atomic.LoadUint64(&m.afterDoCounter) < 1 {
		m.t.Error("Expected call to ClientMock.Do")
	}
}

type mClientMockGet struct {
	mock               *ClientMock
	defaultExpectation *ClientMockGetExpectation
	expectations       []*ClientMockGetExpectation

	callArgs []*ClientMockGetParams
	mutex    sync.RWMutex
}

// ClientMockGetExpectation specifies expectation struct of the Client.Get
type ClientMockGetExpectation struct {
	mock    *ClientMock
	params  *ClientMockGetParams
	results *ClientMockGetResults
	Counter uint64
}

// ClientMockGetParams contains parameters of the Client.Get
type ClientMockGetParams struct {
	ctx  context.Context
	key  string
	opts []clientv3.OpOption
}

// ClientMockGetResults contains results of the Client.Get
type ClientMockGetResults struct {
	gp1 *clientv3.GetResponse
	err error
}

// Expect sets up expected params for Client.Get
func (mmGet *mClientMockGet) Expect(ctx context.Context, key string, opts ...clientv3.OpOption) *mClientMockGet {
	if mmGet.mock.funcGet != nil {
		mmGet.mock.t.Fatalf("ClientMock.Get mock is already set by Set")
	}

	if mmGet.defaultExpectation == nil {
		mmGet.defaultExpectation = &ClientMockGetExpectation{}
	}

	mmGet.defaultExpectation.params = &ClientMockGetParams{ctx, key, opts}
	for _, e := range mmGet.expectations {
		if minimock.Equal(e.params, mmGet.defaultExpectation.params) {
			mmGet.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGet.defaultExpectation.params)
		}
	}

	return mmGet
}

// Inspect accepts an inspector function that has same arguments as the Client.Get
func (mmGet *mClientMockGet) Inspect(f func(ctx context.Context, key string, opts ...clientv3.OpOption)) *mClientMockGet {
	if mmGet.mock.inspectFuncGet != nil {
		mmGet.mock.t.Fatalf("Inspect function is already set for ClientMock.Get")
	}

	mmGet.mock.inspectFuncGet = f

	return mmGet
}

// Return sets up results that will be returned by Client.Get
func (mmGet *mClientMockGet) Return(gp1 *clientv3.GetResponse, err error) *ClientMock {
	if mmGet.mock.funcGet != nil {
		mmGet.mock.t.Fatalf("ClientMock.Get mock is already set by Set")
	}

	if mmGet.defaultExpectation == nil {
		mmGet.defaultExpectation = &ClientMockGetExpectation{mock: mmGet.mock}
	}
	mmGet.defaultExpectation.results = &ClientMockGetResults{gp1, err}
	return mmGet.mock
}

//Set uses given function f to mock the Client.Get method
func (mmGet *mClientMockGet) Set(f func(ctx context.Context, key string, opts ...clientv3.OpOption) (gp1 *clientv3.GetResponse, err error)) *ClientMock {
	if mmGet.defaultExpectation != nil {
		mmGet.mock.t.Fatalf("Default expectation is already set for the Client.Get method")
	}

	if len(mmGet.expectations) > 0 {
		mmGet.mock.t.Fatalf("Some expectations are already set for the Client.Get method")
	}

	mmGet.mock.funcGet = f
	return mmGet.mock
}

// When sets expectation for the Client.Get which will trigger the result defined by the following
// Then helper
func (mmGet *mClientMockGet) When(ctx context.Context, key string, opts ...clientv3.OpOption) *ClientMockGetExpectation {
	if mmGet.mock.funcGet != nil {
		mmGet.mock.t.Fatalf("ClientMock.Get mock is already set by Set")
	}

	expectation := &ClientMockGetExpectation{
		mock:   mmGet.mock,
		params: &ClientMockGetParams{ctx, key, opts},
	}
	mmGet.expectations = append(mmGet.expectations, expectation)
	return expectation
}

// Then sets up Client.Get return parameters for the expectation previously defined by the When method
func (e *ClientMockGetExpectation) Then(gp1 *clientv3.GetResponse, err error) *ClientMock {
	e.results = &ClientMockGetResults{gp1, err}
	return e.mock
}

// Get implements Client
func (mmGet *ClientMock) Get(ctx context.Context, key string, opts ...clientv3.OpOption) (gp1 *clientv3.GetResponse, err error) {
	mm_atomic.AddUint64(&mmGet.beforeGetCounter, 1)
	defer mm_atomic.AddUint64(&mmGet.afterGetCounter, 1)

	if mmGet.inspectFuncGet != nil {
		mmGet.inspectFuncGet(ctx, key, opts...)
	}

	mm_params := &ClientMockGetParams{ctx, key, opts}

	// Record call args
	mmGet.GetMock.mutex.Lock()
	mmGet.GetMock.callArgs = append(mmGet.GetMock.callArgs, mm_params)
	mmGet.GetMock.mutex.Unlock()

	for _, e := range mmGet.GetMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.gp1, e.results.err
		}
	}

	if mmGet.GetMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGet.GetMock.defaultExpectation.Counter, 1)
		mm_want := mmGet.GetMock.defaultExpectation.params
		mm_got := ClientMockGetParams{ctx, key, opts}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGet.t.Errorf("ClientMock.Get got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGet.GetMock.defaultExpectation.results
		if mm_results == nil {
			mmGet.t.Fatal("No results are set for the ClientMock.Get")
		}
		return (*mm_results).gp1, (*mm_results).err
	}
	if mmGet.funcGet != nil {
		return mmGet.funcGet(ctx, key, opts...)
	}
	mmGet.t.Fatalf("Unexpected call to ClientMock.Get. %v %v %v", ctx, key, opts)
	return
}

// GetAfterCounter returns a count of finished ClientMock.Get invocations
func (mmGet *ClientMock) GetAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGet.afterGetCounter)
}

// GetBeforeCounter returns a count of ClientMock.Get invocations
func (mmGet *ClientMock) GetBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGet.beforeGetCounter)
}

// Calls returns a list of arguments used in each call to ClientMock.Get.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGet *mClientMockGet) Calls() []*ClientMockGetParams {
	mmGet.mutex.RLock()

	argCopy := make([]*ClientMockGetParams, len(mmGet.callArgs))
	copy(argCopy, mmGet.callArgs)

	mmGet.mutex.RUnlock()

	return argCopy
}

// MinimockGetDone returns true if the count of the Get invocations corresponds
// the number of defined expectations
func (m *ClientMock) MinimockGetDone() bool {
	for _, e := range m.GetMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGet != nil && mm_atomic.LoadUint64(&m.afterGetCounter) < 1 {
		return false
	}
	return true
}

// MinimockGetInspect logs each unmet expectation
func (m *ClientMock) MinimockGetInspect() {
	for _, e := range m.GetMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ClientMock.Get with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetCounter) < 1 {
		if m.GetMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to ClientMock.Get")
		} else {
			m.t.Errorf("Expected call to ClientMock.Get with params: %#v", *m.GetMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGet != nil && mm_atomic.LoadUint64(&m.afterGetCounter) < 1 {
		m.t.Error("Expected call to ClientMock.Get")
	}
}

type mClientMockPut struct {
	mock               *ClientMock
	defaultExpectation *ClientMockPutExpectation
	expectations       []*ClientMockPutExpectation

	callArgs []*ClientMockPutParams
	mutex    sync.RWMutex
}

// ClientMockPutExpectation specifies expectation struct of the Client.Put
type ClientMockPutExpectation struct {
	mock    *ClientMock
	params  *ClientMockPutParams
	results *ClientMockPutResults
	Counter uint64
}

// ClientMockPutParams contains parameters of the Client.Put
type ClientMockPutParams struct {
	ctx  context.Context
	key  string
	val  string
	opts []clientv3.OpOption
}

// ClientMockPutResults contains results of the Client.Put
type ClientMockPutResults struct {
	pp1 *clientv3.PutResponse
	err error
}

// Expect sets up expected params for Client.Put
func (mmPut *mClientMockPut) Expect(ctx context.Context, key string, val string, opts ...clientv3.OpOption) *mClientMockPut {
	if mmPut.mock.funcPut != nil {
		mmPut.mock.t.Fatalf("ClientMock.Put mock is already set by Set")
	}

	if mmPut.defaultExpectation == nil {
		mmPut.defaultExpectation = &ClientMockPutExpectation{}
	}

	mmPut.defaultExpectation.params = &ClientMockPutParams{ctx, key, val, opts}
	for _, e := range mmPut.expectations {
		if minimock.Equal(e.params, mmPut.defaultExpectation.params) {
			mmPut.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmPut.defaultExpectation.params)
		}
	}

	return mmPut
}

// Inspect accepts an inspector function that has same arguments as the Client.Put
func (mmPut *mClientMockPut) Inspect(f func(ctx context.Context, key string, val string, opts ...clientv3.OpOption)) *mClientMockPut {
	if mmPut.mock.inspectFuncPut != nil {
		mmPut.mock.t.Fatalf("Inspect function is already set for ClientMock.Put")
	}

	mmPut.mock.inspectFuncPut = f

	return mmPut
}

// Return sets up results that will be returned by Client.Put
func (mmPut *mClientMockPut) Return(pp1 *clientv3.PutResponse, err error) *ClientMock {
	if mmPut.mock.funcPut != nil {
		mmPut.mock.t.Fatalf("ClientMock.Put mock is already set by Set")
	}

	if mmPut.defaultExpectation == nil {
		mmPut.defaultExpectation = &ClientMockPutExpectation{mock: mmPut.mock}
	}
	mmPut.defaultExpectation.results = &ClientMockPutResults{pp1, err}
	return mmPut.mock
}

//Set uses given function f to mock the Client.Put method
func (mmPut *mClientMockPut) Set(f func(ctx context.Context, key string, val string, opts ...clientv3.OpOption) (pp1 *clientv3.PutResponse, err error)) *ClientMock {
	if mmPut.defaultExpectation != nil {
		mmPut.mock.t.Fatalf("Default expectation is already set for the Client.Put method")
	}

	if len(mmPut.expectations) > 0 {
		mmPut.mock.t.Fatalf("Some expectations are already set for the Client.Put method")
	}

	mmPut.mock.funcPut = f
	return mmPut.mock
}

// When sets expectation for the Client.Put which will trigger the result defined by the following
// Then helper
func (mmPut *mClientMockPut) When(ctx context.Context, key string, val string, opts ...clientv3.OpOption) *ClientMockPutExpectation {
	if mmPut.mock.funcPut != nil {
		mmPut.mock.t.Fatalf("ClientMock.Put mock is already set by Set")
	}

	expectation := &ClientMockPutExpectation{
		mock:   mmPut.mock,
		params: &ClientMockPutParams{ctx, key, val, opts},
	}
	mmPut.expectations = append(mmPut.expectations, expectation)
	return expectation
}

// Then sets up Client.Put return parameters for the expectation previously defined by the When method
func (e *ClientMockPutExpectation) Then(pp1 *clientv3.PutResponse, err error) *ClientMock {
	e.results = &ClientMockPutResults{pp1, err}
	return e.mock
}

// Put implements Client
func (mmPut *ClientMock) Put(ctx context.Context, key string, val string, opts ...clientv3.OpOption) (pp1 *clientv3.PutResponse, err error) {
	mm_atomic.AddUint64(&mmPut.beforePutCounter, 1)
	defer mm_atomic.AddUint64(&mmPut.afterPutCounter, 1)

	if mmPut.inspectFuncPut != nil {
		mmPut.inspectFuncPut(ctx, key, val, opts...)
	}

	mm_params := &ClientMockPutParams{ctx, key, val, opts}

	// Record call args
	mmPut.PutMock.mutex.Lock()
	mmPut.PutMock.callArgs = append(mmPut.PutMock.callArgs, mm_params)
	mmPut.PutMock.mutex.Unlock()

	for _, e := range mmPut.PutMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.pp1, e.results.err
		}
	}

	if mmPut.PutMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmPut.PutMock.defaultExpectation.Counter, 1)
		mm_want := mmPut.PutMock.defaultExpectation.params
		mm_got := ClientMockPutParams{ctx, key, val, opts}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmPut.t.Errorf("ClientMock.Put got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmPut.PutMock.defaultExpectation.results
		if mm_results == nil {
			mmPut.t.Fatal("No results are set for the ClientMock.Put")
		}
		return (*mm_results).pp1, (*mm_results).err
	}
	if mmPut.funcPut != nil {
		return mmPut.funcPut(ctx, key, val, opts...)
	}
	mmPut.t.Fatalf("Unexpected call to ClientMock.Put. %v %v %v %v", ctx, key, val, opts)
	return
}

// PutAfterCounter returns a count of finished ClientMock.Put invocations
func (mmPut *ClientMock) PutAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmPut.afterPutCounter)
}

// PutBeforeCounter returns a count of ClientMock.Put invocations
func (mmPut *ClientMock) PutBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmPut.beforePutCounter)
}

// Calls returns a list of arguments used in each call to ClientMock.Put.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmPut *mClientMockPut) Calls() []*ClientMockPutParams {
	mmPut.mutex.RLock()

	argCopy := make([]*ClientMockPutParams, len(mmPut.callArgs))
	copy(argCopy, mmPut.callArgs)

	mmPut.mutex.RUnlock()

	return argCopy
}

// MinimockPutDone returns true if the count of the Put invocations corresponds
// the number of defined expectations
func (m *ClientMock) MinimockPutDone() bool {
	for _, e := range m.PutMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.PutMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterPutCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcPut != nil && mm_atomic.LoadUint64(&m.afterPutCounter) < 1 {
		return false
	}
	return true
}

// MinimockPutInspect logs each unmet expectation
func (m *ClientMock) MinimockPutInspect() {
	for _, e := range m.PutMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ClientMock.Put with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.PutMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterPutCounter) < 1 {
		if m.PutMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to ClientMock.Put")
		} else {
			m.t.Errorf("Expected call to ClientMock.Put with params: %#v", *m.PutMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcPut != nil && mm_atomic.LoadUint64(&m.afterPutCounter) < 1 {
		m.t.Error("Expected call to ClientMock.Put")
	}
}

type mClientMockRequestProgress struct {
	mock               *ClientMock
	defaultExpectation *ClientMockRequestProgressExpectation
	expectations       []*ClientMockRequestProgressExpectation

	callArgs []*ClientMockRequestProgressParams
	mutex    sync.RWMutex
}

// ClientMockRequestProgressExpectation specifies expectation struct of the Client.RequestProgress
type ClientMockRequestProgressExpectation struct {
	mock    *ClientMock
	params  *ClientMockRequestProgressParams
	results *ClientMockRequestProgressResults
	Counter uint64
}

// ClientMockRequestProgressParams contains parameters of the Client.RequestProgress
type ClientMockRequestProgressParams struct {
	ctx context.Context
}

// ClientMockRequestProgressResults contains results of the Client.RequestProgress
type ClientMockRequestProgressResults struct {
	err error
}

// Expect sets up expected params for Client.RequestProgress
func (mmRequestProgress *mClientMockRequestProgress) Expect(ctx context.Context) *mClientMockRequestProgress {
	if mmRequestProgress.mock.funcRequestProgress != nil {
		mmRequestProgress.mock.t.Fatalf("ClientMock.RequestProgress mock is already set by Set")
	}

	if mmRequestProgress.defaultExpectation == nil {
		mmRequestProgress.defaultExpectation = &ClientMockRequestProgressExpectation{}
	}

	mmRequestProgress.defaultExpectation.params = &ClientMockRequestProgressParams{ctx}
	for _, e := range mmRequestProgress.expectations {
		if minimock.Equal(e.params, mmRequestProgress.defaultExpectation.params) {
			mmRequestProgress.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmRequestProgress.defaultExpectation.params)
		}
	}

	return mmRequestProgress
}

// Inspect accepts an inspector function that has same arguments as the Client.RequestProgress
func (mmRequestProgress *mClientMockRequestProgress) Inspect(f func(ctx context.Context)) *mClientMockRequestProgress {
	if mmRequestProgress.mock.inspectFuncRequestProgress != nil {
		mmRequestProgress.mock.t.Fatalf("Inspect function is already set for ClientMock.RequestProgress")
	}

	mmRequestProgress.mock.inspectFuncRequestProgress = f

	return mmRequestProgress
}

// Return sets up results that will be returned by Client.RequestProgress
func (mmRequestProgress *mClientMockRequestProgress) Return(err error) *ClientMock {
	if mmRequestProgress.mock.funcRequestProgress != nil {
		mmRequestProgress.mock.t.Fatalf("ClientMock.RequestProgress mock is already set by Set")
	}

	if mmRequestProgress.defaultExpectation == nil {
		mmRequestProgress.defaultExpectation = &ClientMockRequestProgressExpectation{mock: mmRequestProgress.mock}
	}
	mmRequestProgress.defaultExpectation.results = &ClientMockRequestProgressResults{err}
	return mmRequestProgress.mock
}

//Set uses given function f to mock the Client.RequestProgress method
func (mmRequestProgress *mClientMockRequestProgress) Set(f func(ctx context.Context) (err error)) *ClientMock {
	if mmRequestProgress.defaultExpectation != nil {
		mmRequestProgress.mock.t.Fatalf("Default expectation is already set for the Client.RequestProgress method")
	}

	if len(mmRequestProgress.expectations) > 0 {
		mmRequestProgress.mock.t.Fatalf("Some expectations are already set for the Client.RequestProgress method")
	}

	mmRequestProgress.mock.funcRequestProgress = f
	return mmRequestProgress.mock
}

// When sets expectation for the Client.RequestProgress which will trigger the result defined by the following
// Then helper
func (mmRequestProgress *mClientMockRequestProgress) When(ctx context.Context) *ClientMockRequestProgressExpectation {
	if mmRequestProgress.mock.funcRequestProgress != nil {
		mmRequestProgress.mock.t.Fatalf("ClientMock.RequestProgress mock is already set by Set")
	}

	expectation := &ClientMockRequestProgressExpectation{
		mock:   mmRequestProgress.mock,
		params: &ClientMockRequestProgressParams{ctx},
	}
	mmRequestProgress.expectations = append(mmRequestProgress.expectations, expectation)
	return expectation
}

// Then sets up Client.RequestProgress return parameters for the expectation previously defined by the When method
func (e *ClientMockRequestProgressExpectation) Then(err error) *ClientMock {
	e.results = &ClientMockRequestProgressResults{err}
	return e.mock
}

// RequestProgress implements Client
func (mmRequestProgress *ClientMock) RequestProgress(ctx context.Context) (err error) {
	mm_atomic.AddUint64(&mmRequestProgress.beforeRequestProgressCounter, 1)
	defer mm_atomic.AddUint64(&mmRequestProgress.afterRequestProgressCounter, 1)

	if mmRequestProgress.inspectFuncRequestProgress != nil {
		mmRequestProgress.inspectFuncRequestProgress(ctx)
	}

	mm_params := &ClientMockRequestProgressParams{ctx}

	// Record call args
	mmRequestProgress.RequestProgressMock.mutex.Lock()
	mmRequestProgress.RequestProgressMock.callArgs = append(mmRequestProgress.RequestProgressMock.callArgs, mm_params)
	mmRequestProgress.RequestProgressMock.mutex.Unlock()

	for _, e := range mmRequestProgress.RequestProgressMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmRequestProgress.RequestProgressMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmRequestProgress.RequestProgressMock.defaultExpectation.Counter, 1)
		mm_want := mmRequestProgress.RequestProgressMock.defaultExpectation.params
		mm_got := ClientMockRequestProgressParams{ctx}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmRequestProgress.t.Errorf("ClientMock.RequestProgress got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmRequestProgress.RequestProgressMock.defaultExpectation.results
		if mm_results == nil {
			mmRequestProgress.t.Fatal("No results are set for the ClientMock.RequestProgress")
		}
		return (*mm_results).err
	}
	if mmRequestProgress.funcRequestProgress != nil {
		return mmRequestProgress.funcRequestProgress(ctx)
	}
	mmRequestProgress.t.Fatalf("Unexpected call to ClientMock.RequestProgress. %v", ctx)
	return
}

// RequestProgressAfterCounter returns a count of finished ClientMock.RequestProgress invocations
func (mmRequestProgress *ClientMock) RequestProgressAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmRequestProgress.afterRequestProgressCounter)
}

// RequestProgressBeforeCounter returns a count of ClientMock.RequestProgress invocations
func (mmRequestProgress *ClientMock) RequestProgressBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmRequestProgress.beforeRequestProgressCounter)
}

// Calls returns a list of arguments used in each call to ClientMock.RequestProgress.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmRequestProgress *mClientMockRequestProgress) Calls() []*ClientMockRequestProgressParams {
	mmRequestProgress.mutex.RLock()

	argCopy := make([]*ClientMockRequestProgressParams, len(mmRequestProgress.callArgs))
	copy(argCopy, mmRequestProgress.callArgs)

	mmRequestProgress.mutex.RUnlock()

	return argCopy
}

// MinimockRequestProgressDone returns true if the count of the RequestProgress invocations corresponds
// the number of defined expectations
func (m *ClientMock) MinimockRequestProgressDone() bool {
	for _, e := range m.RequestProgressMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.RequestProgressMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterRequestProgressCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcRequestProgress != nil && mm_atomic.LoadUint64(&m.afterRequestProgressCounter) < 1 {
		return false
	}
	return true
}

// MinimockRequestProgressInspect logs each unmet expectation
func (m *ClientMock) MinimockRequestProgressInspect() {
	for _, e := range m.RequestProgressMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ClientMock.RequestProgress with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.RequestProgressMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterRequestProgressCounter) < 1 {
		if m.RequestProgressMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to ClientMock.RequestProgress")
		} else {
			m.t.Errorf("Expected call to ClientMock.RequestProgress with params: %#v", *m.RequestProgressMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcRequestProgress != nil && mm_atomic.LoadUint64(&m.afterRequestProgressCounter) < 1 {
		m.t.Error("Expected call to ClientMock.RequestProgress")
	}
}

type mClientMockTxn struct {
	mock               *ClientMock
	defaultExpectation *ClientMockTxnExpectation
	expectations       []*ClientMockTxnExpectation

	callArgs []*ClientMockTxnParams
	mutex    sync.RWMutex
}

// ClientMockTxnExpectation specifies expectation struct of the Client.Txn
type ClientMockTxnExpectation struct {
	mock    *ClientMock
	params  *ClientMockTxnParams
	results *ClientMockTxnResults
	Counter uint64
}

// ClientMockTxnParams contains parameters of the Client.Txn
type ClientMockTxnParams struct {
	ctx context.Context
}

// ClientMockTxnResults contains results of the Client.Txn
type ClientMockTxnResults struct {
	t1 clientv3.Txn
}

// Expect sets up expected params for Client.Txn
func (mmTxn *mClientMockTxn) Expect(ctx context.Context) *mClientMockTxn {
	if mmTxn.mock.funcTxn != nil {
		mmTxn.mock.t.Fatalf("ClientMock.Txn mock is already set by Set")
	}

	if mmTxn.defaultExpectation == nil {
		mmTxn.defaultExpectation = &ClientMockTxnExpectation{}
	}

	mmTxn.defaultExpectation.params = &ClientMockTxnParams{ctx}
	for _, e := range mmTxn.expectations {
		if minimock.Equal(e.params, mmTxn.defaultExpectation.params) {
			mmTxn.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmTxn.defaultExpectation.params)
		}
	}

	return mmTxn
}

// Inspect accepts an inspector function that has same arguments as the Client.Txn
func (mmTxn *mClientMockTxn) Inspect(f func(ctx context.Context)) *mClientMockTxn {
	if mmTxn.mock.inspectFuncTxn != nil {
		mmTxn.mock.t.Fatalf("Inspect function is already set for ClientMock.Txn")
	}

	mmTxn.mock.inspectFuncTxn = f

	return mmTxn
}

// Return sets up results that will be returned by Client.Txn
func (mmTxn *mClientMockTxn) Return(t1 clientv3.Txn) *ClientMock {
	if mmTxn.mock.funcTxn != nil {
		mmTxn.mock.t.Fatalf("ClientMock.Txn mock is already set by Set")
	}

	if mmTxn.defaultExpectation == nil {
		mmTxn.defaultExpectation = &ClientMockTxnExpectation{mock: mmTxn.mock}
	}
	mmTxn.defaultExpectation.results = &ClientMockTxnResults{t1}
	return mmTxn.mock
}

//Set uses given function f to mock the Client.Txn method
func (mmTxn *mClientMockTxn) Set(f func(ctx context.Context) (t1 clientv3.Txn)) *ClientMock {
	if mmTxn.defaultExpectation != nil {
		mmTxn.mock.t.Fatalf("Default expectation is already set for the Client.Txn method")
	}

	if len(mmTxn.expectations) > 0 {
		mmTxn.mock.t.Fatalf("Some expectations are already set for the Client.Txn method")
	}

	mmTxn.mock.funcTxn = f
	return mmTxn.mock
}

// When sets expectation for the Client.Txn which will trigger the result defined by the following
// Then helper
func (mmTxn *mClientMockTxn) When(ctx context.Context) *ClientMockTxnExpectation {
	if mmTxn.mock.funcTxn != nil {
		mmTxn.mock.t.Fatalf("ClientMock.Txn mock is already set by Set")
	}

	expectation := &ClientMockTxnExpectation{
		mock:   mmTxn.mock,
		params: &ClientMockTxnParams{ctx},
	}
	mmTxn.expectations = append(mmTxn.expectations, expectation)
	return expectation
}

// Then sets up Client.Txn return parameters for the expectation previously defined by the When method
func (e *ClientMockTxnExpectation) Then(t1 clientv3.Txn) *ClientMock {
	e.results = &ClientMockTxnResults{t1}
	return e.mock
}

// Txn implements Client
func (mmTxn *ClientMock) Txn(ctx context.Context) (t1 clientv3.Txn) {
	mm_atomic.AddUint64(&mmTxn.beforeTxnCounter, 1)
	defer mm_atomic.AddUint64(&mmTxn.afterTxnCounter, 1)

	if mmTxn.inspectFuncTxn != nil {
		mmTxn.inspectFuncTxn(ctx)
	}

	mm_params := &ClientMockTxnParams{ctx}

	// Record call args
	mmTxn.TxnMock.mutex.Lock()
	mmTxn.TxnMock.callArgs = append(mmTxn.TxnMock.callArgs, mm_params)
	mmTxn.TxnMock.mutex.Unlock()

	for _, e := range mmTxn.TxnMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.t1
		}
	}

	if mmTxn.TxnMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmTxn.TxnMock.defaultExpectation.Counter, 1)
		mm_want := mmTxn.TxnMock.defaultExpectation.params
		mm_got := ClientMockTxnParams{ctx}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmTxn.t.Errorf("ClientMock.Txn got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmTxn.TxnMock.defaultExpectation.results
		if mm_results == nil {
			mmTxn.t.Fatal("No results are set for the ClientMock.Txn")
		}
		return (*mm_results).t1
	}
	if mmTxn.funcTxn != nil {
		return mmTxn.funcTxn(ctx)
	}
	mmTxn.t.Fatalf("Unexpected call to ClientMock.Txn. %v", ctx)
	return
}

// TxnAfterCounter returns a count of finished ClientMock.Txn invocations
func (mmTxn *ClientMock) TxnAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmTxn.afterTxnCounter)
}

// TxnBeforeCounter returns a count of ClientMock.Txn invocations
func (mmTxn *ClientMock) TxnBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmTxn.beforeTxnCounter)
}

// Calls returns a list of arguments used in each call to ClientMock.Txn.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmTxn *mClientMockTxn) Calls() []*ClientMockTxnParams {
	mmTxn.mutex.RLock()

	argCopy := make([]*ClientMockTxnParams, len(mmTxn.callArgs))
	copy(argCopy, mmTxn.callArgs)

	mmTxn.mutex.RUnlock()

	return argCopy
}

// MinimockTxnDone returns true if the count of the Txn invocations corresponds
// the number of defined expectations
func (m *ClientMock) MinimockTxnDone() bool {
	for _, e := range m.TxnMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.TxnMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterTxnCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcTxn != nil && mm_atomic.LoadUint64(&m.afterTxnCounter) < 1 {
		return false
	}
	return true
}

// MinimockTxnInspect logs each unmet expectation
func (m *ClientMock) MinimockTxnInspect() {
	for _, e := range m.TxnMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ClientMock.Txn with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.TxnMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterTxnCounter) < 1 {
		if m.TxnMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to ClientMock.Txn")
		} else {
			m.t.Errorf("Expected call to ClientMock.Txn with params: %#v", *m.TxnMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcTxn != nil && mm_atomic.LoadUint64(&m.afterTxnCounter) < 1 {
		m.t.Error("Expected call to ClientMock.Txn")
	}
}

type mClientMockWatch struct {
	mock               *ClientMock
	defaultExpectation *ClientMockWatchExpectation
	expectations       []*ClientMockWatchExpectation

	callArgs []*ClientMockWatchParams
	mutex    sync.RWMutex
}

// ClientMockWatchExpectation specifies expectation struct of the Client.Watch
type ClientMockWatchExpectation struct {
	mock    *ClientMock
	params  *ClientMockWatchParams
	results *ClientMockWatchResults
	Counter uint64
}

// ClientMockWatchParams contains parameters of the Client.Watch
type ClientMockWatchParams struct {
	ctx  context.Context
	key  string
	opts []clientv3.OpOption
}

// ClientMockWatchResults contains results of the Client.Watch
type ClientMockWatchResults struct {
	w1 clientv3.WatchChan
}

// Expect sets up expected params for Client.Watch
func (mmWatch *mClientMockWatch) Expect(ctx context.Context, key string, opts ...clientv3.OpOption) *mClientMockWatch {
	if mmWatch.mock.funcWatch != nil {
		mmWatch.mock.t.Fatalf("ClientMock.Watch mock is already set by Set")
	}

	if mmWatch.defaultExpectation == nil {
		mmWatch.defaultExpectation = &ClientMockWatchExpectation{}
	}

	mmWatch.defaultExpectation.params = &ClientMockWatchParams{ctx, key, opts}
	for _, e := range mmWatch.expectations {
		if minimock.Equal(e.params, mmWatch.defaultExpectation.params) {
			mmWatch.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmWatch.defaultExpectation.params)
		}
	}

	return mmWatch
}

// Inspect accepts an inspector function that has same arguments as the Client.Watch
func (mmWatch *mClientMockWatch) Inspect(f func(ctx context.Context, key string, opts ...clientv3.OpOption)) *mClientMockWatch {
	if mmWatch.mock.inspectFuncWatch != nil {
		mmWatch.mock.t.Fatalf("Inspect function is already set for ClientMock.Watch")
	}

	mmWatch.mock.inspectFuncWatch = f

	return mmWatch
}

// Return sets up results that will be returned by Client.Watch
func (mmWatch *mClientMockWatch) Return(w1 clientv3.WatchChan) *ClientMock {
	if mmWatch.mock.funcWatch != nil {
		mmWatch.mock.t.Fatalf("ClientMock.Watch mock is already set by Set")
	}

	if mmWatch.defaultExpectation == nil {
		mmWatch.defaultExpectation = &ClientMockWatchExpectation{mock: mmWatch.mock}
	}
	mmWatch.defaultExpectation.results = &ClientMockWatchResults{w1}
	return mmWatch.mock
}

//Set uses given function f to mock the Client.Watch method
func (mmWatch *mClientMockWatch) Set(f func(ctx context.Context, key string, opts ...clientv3.OpOption) (w1 clientv3.WatchChan)) *ClientMock {
	if mmWatch.defaultExpectation != nil {
		mmWatch.mock.t.Fatalf("Default expectation is already set for the Client.Watch method")
	}

	if len(mmWatch.expectations) > 0 {
		mmWatch.mock.t.Fatalf("Some expectations are already set for the Client.Watch method")
	}

	mmWatch.mock.funcWatch = f
	return mmWatch.mock
}

// When sets expectation for the Client.Watch which will trigger the result defined by the following
// Then helper
func (mmWatch *mClientMockWatch) When(ctx context.Context, key string, opts ...clientv3.OpOption) *ClientMockWatchExpectation {
	if mmWatch.mock.funcWatch != nil {
		mmWatch.mock.t.Fatalf("ClientMock.Watch mock is already set by Set")
	}

	expectation := &ClientMockWatchExpectation{
		mock:   mmWatch.mock,
		params: &ClientMockWatchParams{ctx, key, opts},
	}
	mmWatch.expectations = append(mmWatch.expectations, expectation)
	return expectation
}

// Then sets up Client.Watch return parameters for the expectation previously defined by the When method
func (e *ClientMockWatchExpectation) Then(w1 clientv3.WatchChan) *ClientMock {
	e.results = &ClientMockWatchResults{w1}
	return e.mock
}

// Watch implements Client
func (mmWatch *ClientMock) Watch(ctx context.Context, key string, opts ...clientv3.OpOption) (w1 clientv3.WatchChan) {
	mm_atomic.AddUint64(&mmWatch.beforeWatchCounter, 1)
	defer mm_atomic.AddUint64(&mmWatch.afterWatchCounter, 1)

	if mmWatch.inspectFuncWatch != nil {
		mmWatch.inspectFuncWatch(ctx, key, opts...)
	}

	mm_params := &ClientMockWatchParams{ctx, key, opts}

	// Record call args
	mmWatch.WatchMock.mutex.Lock()
	mmWatch.WatchMock.callArgs = append(mmWatch.WatchMock.callArgs, mm_params)
	mmWatch.WatchMock.mutex.Unlock()

	for _, e := range mmWatch.WatchMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.w1
		}
	}

	if mmWatch.WatchMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmWatch.WatchMock.defaultExpectation.Counter, 1)
		mm_want := mmWatch.WatchMock.defaultExpectation.params
		mm_got := ClientMockWatchParams{ctx, key, opts}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmWatch.t.Errorf("ClientMock.Watch got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmWatch.WatchMock.defaultExpectation.results
		if mm_results == nil {
			mmWatch.t.Fatal("No results are set for the ClientMock.Watch")
		}
		return (*mm_results).w1
	}
	if mmWatch.funcWatch != nil {
		return mmWatch.funcWatch(ctx, key, opts...)
	}
	mmWatch.t.Fatalf("Unexpected call to ClientMock.Watch. %v %v %v", ctx, key, opts)
	return
}

// WatchAfterCounter returns a count of finished ClientMock.Watch invocations
func (mmWatch *ClientMock) WatchAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmWatch.afterWatchCounter)
}

// WatchBeforeCounter returns a count of ClientMock.Watch invocations
func (mmWatch *ClientMock) WatchBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmWatch.beforeWatchCounter)
}

// Calls returns a list of arguments used in each call to ClientMock.Watch.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmWatch *mClientMockWatch) Calls() []*ClientMockWatchParams {
	mmWatch.mutex.RLock()

	argCopy := make([]*ClientMockWatchParams, len(mmWatch.callArgs))
	copy(argCopy, mmWatch.callArgs)

	mmWatch.mutex.RUnlock()

	return argCopy
}

// MinimockWatchDone returns true if the count of the Watch invocations corresponds
// the number of defined expectations
func (m *ClientMock) MinimockWatchDone() bool {
	for _, e := range m.WatchMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.WatchMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterWatchCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcWatch != nil && mm_atomic.LoadUint64(&m.afterWatchCounter) < 1 {
		return false
	}
	return true
}

// MinimockWatchInspect logs each unmet expectation
func (m *ClientMock) MinimockWatchInspect() {
	for _, e := range m.WatchMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ClientMock.Watch with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.WatchMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterWatchCounter) < 1 {
		if m.WatchMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to ClientMock.Watch")
		} else {
			m.t.Errorf("Expected call to ClientMock.Watch with params: %#v", *m.WatchMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcWatch != nil && mm_atomic.LoadUint64(&m.afterWatchCounter) < 1 {
		m.t.Error("Expected call to ClientMock.Watch")
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *ClientMock) MinimockFinish() {
	if !m.minimockDone() {
		m.MinimockCloseInspect()

		m.MinimockCompactInspect()

		m.MinimockDeleteInspect()

		m.MinimockDoInspect()

		m.MinimockGetInspect()

		m.MinimockPutInspect()

		m.MinimockRequestProgressInspect()

		m.MinimockTxnInspect()

		m.MinimockWatchInspect()
		m.t.FailNow()
	}
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *ClientMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *ClientMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockCloseDone() &&
		m.MinimockCompactDone() &&
		m.MinimockDeleteDone() &&
		m.MinimockDoDone() &&
		m.MinimockGetDone() &&
		m.MinimockPutDone() &&
		m.MinimockRequestProgressDone() &&
		m.MinimockTxnDone() &&
		m.MinimockWatchDone()
}
