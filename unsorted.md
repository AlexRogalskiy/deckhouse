
Как устроена antiopa
--------------------

### Структура директорий модуля

```
modules
├── test1
│   ├── Chart.yaml
│   ├── hooks
│   │   ├── after-helm
│   │   │   └── onexit.sh
│   │   └── before-helm
│   │       ├── 000_print_values.sh
│   │       └── 001_abcd.sh
│   ├── templates
│   │   ├── 000_namespace.yaml
│   │   └── mysql.yaml
│   ├── initial_values
│   └── values.yaml
...
```

Каждый модуль это директория в директории `/modules`. Модуль это чарт для helm.

### Helm

* Helm upgrade --install вызывается при наличии файла `/modules/<module-name>/Chart.yaml`.
* Для каждого модуля создается релиз в helm с именем модуля. Т.к. это отдельный instance tiller.
* Чтобы просмотреть релизы в helm: TILLER_NAMESPACE=antiopa helm list.
* При первом выкате релиза в helm, если в кластере уже есть ресурсы, описанные в релизе – выкат в helm упадет. При этом будет создан релиз в состоянии FAILED. При повторном запуске (будет вызван автоматом через 30 сек) ошибка с уже существующим ресурсом проявляться не будет.

### Хуки

* Хук — это произвольный исполняемый файл.
* Хуки модулей
    * Before-helm хуки добавляются в директрию `/modules/<module-name>/hooks/before-helm/`
    * After-helm хуки добавляются в директрию `/modules/<module-name>/hooks/after-helm/`
* Глобальные хуки
    * On-kube-node-change хуки добавляются в директорию `/global-hooks/on-kube-node-change/`
        * Вызывается перед запуском всех модулей
        * Вызывается при изменении списка узлов
            * добавление/удаление узла
            * изменение узла
                * имя узла, поля spec, annotations, labels
* Хуки в каждой директории вызываются в алфавитном порядке.
* Хуки могут генерировать values для helm.
    * На данный момент поддерживается только генерация values для глобального хука on-kube-node-change
    * В хуке доступна переменная окружения RETURN_VALUES_PATH, в которой записан путь к пустому файлу (гарантируется, что файл существует на момент запуска хука). Содержимое файла после запуска хука будет воспринято как yaml.
    * Все values, которые возвращают хуки объединяются в единый в том порядке, в котором эти хуки вызывались.
* В хуках доступно использование утилиты kubectl или подключение к kubernetes-api через in-cluster connection (работает из коробки в любом языке).

### Values для helm

Есть 6 источников values.yaml для helm:

* Файл `/modules/values.yaml` — глобальные для всех модулей, для всех инсталляций.
* Values, которые генерируют глобальные хуки (возвращаются через файл $RETURN_VALUES_PATH).
* Файл `/modules/<module-name>/values.yaml` — для фодуля module-name, для всех инсталляций.
* Файл `/modules/<module-name>/initial_values` — для модуля module-name, для всех инсталляций, скрипт-генератор values (должен вернуть YAML в stdout).
* ConfigMap-antiopa yaml-строка в `data[values]` — глобальные для всех модулей, для данной инсталляции.
* ConfigMap-antiopa yaml-строка в `data[<module-name>-values]` — для модуля module-name, для данной инсталляции.

Все merge-ться в единый values.yaml в указанном порядке.

Результат initial_values дописывается в ConfigMap связанного модуля и "запоминается". Например, таким образом можно сгенерить пароль. Пароль при первом вызове initial_values запишется в ConfigMap и больше не будет перезаписан. Если после этого поменять этот пароль руками в ConfigMap — то все будет работать как и ожидается, т.к. значения из ConfigMap имеют приоритет.

Схема устройства merge-значений: https://docs.google.com/a/flant.com/drawings/d/1WjE9MtLjWQTul4mURE-TSrAXpLfEbpC22-zWIqc5RxI/edit?usp=sharing

Изменение ConfigMap-antiopa на данный момент не вызывает перезапуск модулей, поэтому требуется убить pod antiopa, чтобы инициировать перезапуск.

Пример манифеста:

```
apiVersion: v1
kind: ConfigMap
metadata:
name: antiopa
data:
  values: |
    go:
    - 2
  test1-values: |
    go:
    - 4
    - 6
    - 7
  test2-values: |
    key: value
```

### Обновление кода модулей
При коммите изменений модулей или самой antiopa в git-репо происходит сборка нового docker образа.

Уже запущенная версия antiopa периодически проверяет наличие нового образа в docker-registry (новый id для того же имени образа, т.е. всегда по логике "latest"). Если новый образ появился – запущенная версия antiopa изменяет manifest своего deployment и завершает работу, обновление до последней версии образа из registry делает уже сам deployment.

При каждом новом запуске/перезапуске antiopa перезапускает все модули (в алфавитном порядке).

### Как запускаются модули

* Модули запускаются при каждом старте программы/пода
    * Чтобы инициировать рестарт – убиваем под
    * Модули между собой запускаются в алфавитном порядке
    * Хуки модуля из одной директории запускаются в алфавитном порядке.
* Если во время работы модуля произошла ошибка, то он попадает в очередь на рестарт. Каждые 30 секунд перезапускается один модуль из этой очереди и если он отработает успешно, то больше не перезапускается, если опять фейл – попадает в конец очереди.
* Если во время работы глобального хука произошла ошибка, то перезапуск хуков и всех модулей откладывается на 30 секунд.

### Отключение модулей

Модули, которые указаны в ключе disable-modules в ConfigMap antiopa, будут выключены. Перечисляются через запятую, можно использовать glob'ы.

Пример:

```
apiVersion: v1
kind: ConfigMap
metadata:
name: antiopa
data:
  disable-modules: test*, kube-dashboard
...
```
