#!/bin/bash

source /antiopa/shell_lib.sh

fltr='.'

###
# Политика #1: kube-dns должен выполняться на system-узлах, если они есть
if cluster::has_system_nodes; then
  # Добавляем toleration, если не добавлен
  fltr=$fltr' | .spec.template.spec.tolerations |= (
    . + [{"key":"node-role/system","operator":"Exists"}] | unique
  )'

  # Добавляем в каждый nodeSelectorTerm по matchExpression, если он еще не добавлен
  fltr=$fltr' | .spec.template.spec.affinity.nodeAffinity.requiredDuringSchedulingIgnoredDuringExecution.nodeSelectorTerms |= (
    if . then . else [{}] end | map(
      .matchExpressions |= (
        . + [{"key":"node-role/system","operator":"Exists"}] | unique
      )
    )
  )'
else
  # Удаляем toleration, если был добавлен
  fltr=$fltr' | if .spec.template.spec.tolerations then
    .spec.template.spec.tolerations |= . - [{"key":"node-role/system","operator":"Exists"}]
  else . end'

  # Удаляем из каждого nodeSelectorTerm по matchExpression, если он был добавлен
  fltr=$fltr' | if .spec.template.spec.affinity.nodeAffinity.requiredDuringSchedulingIgnoredDuringExecution.nodeSelectorTerms then
    .spec.template.spec.affinity.nodeAffinity.requiredDuringSchedulingIgnoredDuringExecution.nodeSelectorTerms |= (
      . | map(
        .matchExpressions -= [{"key":"node-role/system","operator":"Exists"}]
      )
    )
  else . end'
fi
# В любом случае, есть system-узлы или нет, удаляем "старые" toleration'ы, с явно указанным effect
fltr=$fltr' | if .spec.template.spec.tolerations then
  .spec.template.spec.tolerations |= . - [{"effect":"NoExecute","key":"node-role/system","operator":"Exists"}]
else . end'


###
# Политика #2: Количество реплик kube-dns
#  * В AWS и GCE — работает kube-dns-autoscaler (который ставит kops, и мы не хотим с ним спорить)
#  * В других случаях:
#    * Если есть system-узлы, то kube-dns должен выполняться на каждом system-узле
#    * Иначе количество реплик должно быть:
#      * равно 2 или больше (если руками кто-то поставил),
#      * но не больше, чем количество неспецифичных нод в кластере (без наших специальных taint)
if [[ $(cluster::type) != "AWS" && $(cluster::type) != "GCE" ]] ; then
  if cluster::has_system_nodes; then
    fltr=$fltr' | .spec.replicas = '$(cluster::count_system_nodes)
  else
    fltr=$fltr' | .spec.replicas |= ([[2,.] | max, '$(cluster::nonspecific_nodes | wc -l)'] | min)'
  fi
fi


###
# Политика #3: Не нужно запускать больше одного kube-dns на узле
fltr=$fltr' | .spec.template.spec.affinity.podAntiAffinity.preferredDuringSchedulingIgnoredDuringExecution |= (. + [{"weight":100,"podAffinityTerm":{"labelSelector":{"matchLabels":{"k8s-app":"kube-dns"}},"topologyKey":"kubernetes.io/hostname"}}] | unique)'

# Определяем имя deployment'а (в Azure он называется не kube-dns)
kube_dns_deployment_name=$(kubectl -n kube-system get deployment -l k8s-app=kube-dns -o name)

# Применяем
kubectl::apply_jq kube-system ${kube_dns_deployment_name} "$fltr"
