#!/bin/bash

source /deckhouse/shell_lib.sh

function __config__() {
  cat << EOF
    configVersion: v1
    kubernetes:
    - name: node_roles
      apiVersion: v1
      kind: Node
      includeSnapshotsFrom: ["node_roles", "kube_dns_autoscaler", "kube_dns"]
      jqFilter: |
        .metadata.labels // {} |
        if ([keys[] | select(startswith("node-role.kubernetes.io/master"))] | length > 0) then
          [keys[] | select(startswith("node-role.kubernetes.io/"))][0]
        elif ([keys[] | select(startswith("node-role.flant.com/"))] | length > 0) then
          [keys[] | select(startswith("node-role.flant.com/"))][0]
        elif ([keys[] | select(startswith("node-role.deckhouse.io/"))] | length > 0) then
          [keys[] | select(startswith("node-role.deckhouse.io/"))][0]
        elif ([keys[] | select(startswith("node-role.kubernetes.io/"))] | length > 0) then
          [keys[] | select(startswith("node-role.kubernetes.io/"))][0]
        else
          null
        end |
        if . != null then
          . | split("/")[1] | gsub("-(?<a>[a-z])"; .a|ascii_upcase)
        else
          .
        end
    - name: kube_dns
      apiVersion: apps/v1
      kind: Deployment
      includeSnapshotsFrom: ["node_roles", "kube_dns_autoscaler", "kube_dns"]
      namespace:
        nameSelector:
          matchNames: [kube-system]
      labelSelector:
        matchLabels:
          k8s-app: kube-dns
    - name: kube_dns_autoscaler
      apiVersion: apps/v1
      kind: Deployment
      includeSnapshotsFrom: ["node_roles", "kube_dns_autoscaler", "kube_dns"]
      namespace:
        nameSelector:
          matchNames: [kube-system]
      labelSelector:
        matchLabels:
          k8s-app: kube-dns-autoscaler
EOF
}

function __main__() {
  if ! context::has snapshots.kube_dns.0; then
    >&2 echo "WARNING: Can't find kube-dns deployment."
    return 0
  fi

  count_master_nodes=$(context::jq -er '[.snapshots.node_roles[] | select(.filterResult == "master")] | length')
  count_system_nodes=$(context::jq -er '[.snapshots.node_roles[] | select(.filterResult == "system")] | length')
  count_kube_dns_nodes=$(context::jq -er '[.snapshots.node_roles[] | select(.filterResult == "kubeDns")] | length')
  count_nonspecific_nodes=$(context::jq -er '[.snapshots.node_roles[] | select(.filterResult == null)] | length')

  fltr="."

  ###
  # Policy #0: kube-dns must be able to work on every master and every specific node
  fltr=$fltr' |
    .spec.template.spec.tolerations = (
      (.spec.template.spec.tolerations // []) + [
        {"key":"node-role.kubernetes.io/master"},
        {"key":"dedicated.flant.com","operator":"Equal","value": "kube-dns"},
        {"key":"dedicated.flant.com","operator":"Equal","value": "system"},
        {"key":"node-role/system"}
      ] | unique
    )'

  ###
  # Policy #1:
  # * kube-dns must be primarily scheduled to master nodes
  # * then kube-dns must be scheduled to specific nodes

  if (( (count_system_nodes + count_kube_dns_nodes) > 0 )); then
    specific_node=""
    if (( count_kube_dns_nodes > 0 )); then
      specific_node="kube-dns"
    else # $count_system_nodes > 0
      specific_node="system"
    fi

    fltr=$fltr' |
      .spec.template.spec.affinity.nodeAffinity.requiredDuringSchedulingIgnoredDuringExecution.nodeSelectorTerms = [
        {"matchExpressions":[{"key":"node-role.kubernetes.io/master","operator":"Exists"}]},
        {"matchExpressions":[{"key":"node-role.flant.com/'${specific_node}'","operator":"Exists"}]},
        {"matchExpressions":[{"key":"node-role.deckhouse.io/'${specific_node}'","operator":"Exists"}]},
        {"matchExpressions":[{"key":"node-role.kubernetes.io/'${specific_node}'","operator":"Exists"}]}
      ] |
      del(.spec.template.spec.affinity.nodeAffinity.preferredDuringSchedulingIgnoredDuringExecution)'

  else
    fltr=$fltr' |
      .spec.template.spec.affinity.nodeAffinity.preferredDuringSchedulingIgnoredDuringExecution = [
        {"weight":1,"preference":{"matchExpressions":[{"key":"node-role.kubernetes.io/master","operator":"Exists"}]}}
      ] |
      del(.spec.template.spec.affinity.nodeAffinity.requiredDuringSchedulingIgnoredDuringExecution)'
  fi

  ###
  # policy #2: replicas
  #  * There is kube-dns-autoscaler in kops-deployed AWS and GCE. We don't want to interfere with him
  #  * In other cases:
  #    * If there are special nodes for kube-dns then deployment must fit there and on masters
  #    * If there are system-nodes then deployment must fit there and on masters
  #    * Else:
  #      * there should be at least 2 replicas or more if someone configured it manually
  #      * there must not be more replicas then non-specific nodes

  if ! context::has snapshots.kube_dns_autoscaler.0 ; then
    if (( count_kube_dns_nodes > 0 )); then
      fltr=$fltr' | .spec.replicas = '$((count_master_nodes + count_kube_dns_nodes))
    elif (( count_system_nodes > 0 )); then
      fltr=$fltr' | .spec.replicas = '$((count_master_nodes + count_system_nodes))
    else
      fltr=$fltr' | .spec.replicas |= (
        [
          ([2, '$count_master_nodes', .] | max),
          ([2, '$((count_master_nodes + count_nonspecific_nodes))'] | max)
        ] | min
      )'
    fi
  fi

  ###
  # Policy #3:
  # * do not run more than one kube-dns on single node except cases with single master and lack of specific nodes

  if (( (count_master_nodes + count_kube_dns_nodes + count_system_nodes) > 1 )); then
    fltr=$fltr' |
      .spec.template.spec.affinity.podAntiAffinity.requiredDuringSchedulingIgnoredDuringExecution = [
        {"labelSelector":{"matchLabels":{"k8s-app":"kube-dns"}},"topologyKey":"kubernetes.io/hostname"}
      ] |
      del(.spec.template.spec.affinity.podAntiAffinity.preferredDuringSchedulingIgnoredDuringExecution)'
  else
    fltr=$fltr' |
      .spec.template.spec.affinity.podAntiAffinity.preferredDuringSchedulingIgnoredDuringExecution = [
        {"weight":1,"podAffinityTerm":{"labelSelector":{"matchLabels":{"k8s-app":"kube-dns"}},"topologyKey":"kubernetes.io/hostname"}}
      ] |
      del(.spec.template.spec.affinity.podAntiAffinity.requiredDuringSchedulingIgnoredDuringExecution)'
  fi

  kubernetes::patch_jq kube-system deployment/$(context::get snapshots.kube_dns.0.object.metadata.name) "$fltr"
}

hook::run $@
