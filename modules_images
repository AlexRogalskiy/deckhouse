#!/bin/bash

#
# Скрипт для управления образами модулей.
#   * Собирает образы модулей из Dockerfile'ов, расположенных в директориях
#     modules/*/images/*/
#   * Умно тегирует образы на основании контрольной суммы содержимого
#     директории образа (content-addressable)
#   * Генерирует JSON-файл с маппингом имени модуля и имени образа в актуальный
#     тег
#   * Умеет очищать все не используемые теги (те теги, на которые не ссылается
#     ни один акутальный тег)
#
# Как к этому пришли: https://github.com/deckhouse/deckhouse/issues/48
#


function bp() {
  ! read -rd '' HELP_STRING <<"EOF"
Usage: modules_images bp [OPTION]...
Build and push all modules images

Optional arguments:
  --write-tags=PATH            write info about tags in JSON format
  --registry=REGISTRY          the address of the registry
                               (default: $CI_REGISTRY_IMAGE)
  --registry-user=USER         the username to use to push containers to registry
                               (default: $CI_REGISTRY_USER)
  --registry-password=PASS     the password to use to push containers to registry
                               (default: $CI_REGISTRY_PASSWORD)
  -h, --help                   output this message
EOF

  temp=$(getopt -o h --long write-tags:,registry:,registry-user:,registry-password:,help -n 'modules_images bp' -- "$@")

  eval set -- "$temp"

  TAGS_JSON_FILE=""
  REGISTRY=$CI_REGISTRY_IMAGE
  REGISTRY_USER=$CI_REGISTRY_USER
  REGISTRY_PASSWORD=$CI_REGISTRY_PASSWORD

  while true ; do
    case "$1" in
      --write-tags )
        TAGS_JSON_FILE=$2; shift 2;;
      --registry )
        REGISTRY=$2; shift 2;;
      --registry-user )
        REGISTRY_USER=$2; shift 2;;
      --registry-password )
        REGISTRY_PASSWORD=$2; shift 2;;
      -h | --help )
        echo "$HELP_STRING"; exit 0 ;;
      -- )
        shift; break ;;
      * )
        break ;;
    esac
  done

  if [[ $# -ne 0 ]] ; then
    echo "$HELP_STRING"
    exit 1
  fi

  if [[ -z $REGISTRY ]] ; then
    >&2 echo -e "\e[01;31mError, no registry is passed\e[0m"
    exit 1
  fi

  set -o pipefail
  set -e

  # Логинимся в registry
  if [[ -n $REGISTRY_USER || -n $REGISTRY_PASSWORD ]] ; then
    echo $REGISTRY_PASSWORD | docker login --username="$REGISTRY_USER" --password-stdin $REGISTRY > /dev/null 2> >(while IFS='' read line ; do echo -e "\e[01;31m$line\e[0m" >&2; done)
  fi

  # Получаем список образов, которые уже собраны (присутствуют локально на сборщике)
  existing_docker_images=$(docker image ls --format "{{.Repository}}:{{.Tag}}" | grep ^$REGISTRY)

  # Получаем тег для каждого образа каждого модуля
  modules_images_with_tags=$(git ls-tree @ -- modules/*/images/* | sed -r 's/^[0-9]{6}\s+tree\s+([0-9a-f]{40})\smodules\/([0-9]{3})-([^\/]+)\/images\/([^\/]+)$/\2:\3:\4:\1/' | sort)

  previous_module_in_tags_json_file=''
  previous_module=''
  # Проходим по каждому образу каждого тега
  echo "$modules_images_with_tags" | while IFS=':' read -r module_order module image tag ; do
    full_image_name=$REGISTRY/$module/$image:$tag

    # Генерируем запись в JSON файл
    if [[ -n $TAGS_JSON_FILE ]] ; then
      if [[ $module != $previous_module_in_tags_json_file ]] ; then
        if [[ -z $previous_module_in_tags_json_file ]] ; then
          rm -f $TAGS_JSON_FILE
          echo -n '{' >> $TAGS_JSON_FILE
        else
          echo -n '},' >> $TAGS_JSON_FILE
        fi

        echo -n '"'$(echo $module | sed -E 's/-(.)/\U\1/g')'":{' >> $TAGS_JSON_FILE
        previous_module_in_tags_json_file=$module
      else
        echo -n ',' >> $TAGS_JSON_FILE
      fi

      echo -n '"'$(echo $image | sed -E 's/-(.)/\U\1/g')'":"'$tag'"' >> $TAGS_JSON_FILE
    fi

    # Пропускаем, если образ уже собран (присутствует локально на сборщике)
    if echo "$existing_docker_images" | grep ^$full_image_name$ > /dev/null ; then
      continue
    fi

    # Красиво печатаем информацию о модуле
    if [[ $module != $previous_module ]] ; then
      if [[ -n $previous_module ]] ; then
        echo
      fi

      echo -e "\e[1;4m\e[93mBuilding images for $module\e[0m"
      previous_module=$module
    else
      echo
    fi

    # Печатаем информацию об образе
    echo -e "  \e[1m\e[33mBuilding $image\e[0m"

    # Собираем и пушим образ
    set +e
    (
      cd modules/${module_order}-${module}/images/${image}

      # Если Dockerfile состоит из единственной строки `FROM "reg.example.org/img:ver"`, то сквошить не надо, issue #582
      SQUASH="--squash"
      if grep -v '^#' Dockerfile | grep -qPz '\AFROM \N*\Z'; then
        SQUASH=""
      fi

      if ! docker image build --build-arg CI_JOB_TOKEN="$CI_JOB_TOKEN" $SQUASH -t $full_image_name . ; then
        sleep 0.1
        exit 1
      fi

      if ! docker image push $full_image_name ; then
        docker image rm $full_image_name
        sleep 0.1
        exit 1
      fi
    ) 2> >(while IFS='' read line ; do echo -e "\e[01;31m    $line\e[0m" >&2; done) 1> >(while IFS='' read line ; do echo -e "\e[94m    $line\e[0m"; done)

    # Обрабатываем результат
    if [[ $? -eq 0 ]] ; then
      echo -e "  \e[1m\e[32mDONE\e[0m"
    else
      echo -e "  \e[01;31mFAILED\e[0m"
      exit 1
    fi

    set -e
  done

  if [[ -n $TAGS_JSON_FILE ]] ; then
    echo '}}' >> $TAGS_JSON_FILE
  fi
}


function cleanup() {
  ! read -rd '' HELP_STRING <<"EOF"
Usage: modules_images cleanup [OPTION]...
Cleanup unused tags (localy from Docker and from remote registry)

Optional arguments:
  --registry=REGISTRY          the address of the registry
                               (default: $CI_REGISTRY_IMAGE)
  --registry-user=USER         the username to use to push containers to registry
                               (default: $CI_REGISTRY_USER)
  --registry-password=PASS     the password to use to push containers to registry
                               (default: $CI_REGISTRY_PASSWORD)
  -h, --help                   output this message
EOF

  temp=$(getopt -o h --long registry:,registry-user:,registry-password:,help -n 'modules_images cleanup' -- "$@")

  eval set -- "$temp"

  REGISTRY=$CI_REGISTRY_IMAGE
  REGISTRY_USER=$CI_REGISTRY_USER
  REGISTRY_PASSWORD=$CI_REGISTRY_PASSWORD

  while true ; do
    case "$1" in
      --registry )
        REGISTRY=$2; shift 2;;
      --registry-user )
        REGISTRY_USER=$2; shift 2;;
      --registry-password )
        REGISTRY_PASSWORD=$2; shift 2;;
      -h | --help )
        echo "$HELP_STRING"; exit 0 ;;
      -- )
        shift; break ;;
      * )
        break ;;
    esac
  done

  if [[ $# -ne 0 ]] ; then
    echo "$HELP_STRING"
    exit 1
  fi

  if [[ -z $REGISTRY ]] ; then
    >&2 echo -e "\e[01;31mError, no registry is passed\e[0m"
    exit 1
  fi

  # Парсим $REGISTRY
  REGISTRY_URL="https://$(echo $REGISTRY | cut -d/ -f1)"
  REGISTRY_REPO=$(echo $REGISTRY | cut -d/ -f2-)

  # Проверяем наличие консольного клиента к registry
  if ! command -v reg > /dev/null ; then
    >&2 echo -e "\e[01;31mError, no reg command available\e[0m" >&2
    echo "Please install https://github.com/jessfraz/reg:"
    echo "  wget https://github.com/jessfraz/reg/releases/download/v0.12.0/reg-linux-amd64 -O /usr/bin/reg && chmod +x /usr/bin/reg"
    exit 1
  fi

  set -o pipefail
  set -e

  # Логинимся в registry
  if [[ -n $REGISTRY_USER || -n $REGISTRY_PASSWORD ]] ; then
    echo $REGISTRY_PASSWORD | docker login --username="$REGISTRY_USER" --password-stdin $REGISTRY > /dev/null 2> >(while IFS='' read line ; do echo -e "\e[01;31m$line\e[0m" >&2; done)
  fi

  # Вычисляем список всех актуальных бранчей и тегов
  current_refs=$(git branch -r | awk {'print $1'} && git tag && echo HEAD)

  # Получаем список всех образов из всех модулей во всех current_ref'ах
  all_modules_images=$(
    for ref in $current_refs ; do
      git ls-tree $ref -- modules/*/images/* | sed -r 's/^[0-9]{6}\s+tree\s+[0-9a-f]{40}\smodules\/([0-9]{3}-)?([^\/]+)\/images\/([^\/]+)$/\2:\3/'
    done | sort | uniq
  )

  previous_module=''
  # Проходим по каждому образу каждого тега
  echo "$all_modules_images" | while IFS=':' read -r module image ; do
    # Определяем список актуальных тегов (по данным git)
    current_tags=$(
      for ref in $current_refs ; do
        git ls-tree $ref -- modules/{{0,1,2,3,4,5,6,7,8,9}{0,1,2,3,4,5,6,7,8,9}{0,1,2,3,4,5,6,7,8,9}-,}$module/images/$image | sed -r 's/^[0-9]{6}\s+tree\s+([0-9a-f]{40})\smodules\/([0-9]{3}-)?'$module'\/images\/'$image'$/\1/'
      done | sort | uniq
    )

    # Определяем список локальных тегов на удаление
    local_waste_tags=$(comm -13 <(echo "$current_tags") <(docker image ls $REGISTRY/$module/$image --format="{{.Tag}}" | sort))

    # Определяем список тегов на удаление из registry
    remote_waste_tags=$(comm -13 <(echo "$current_tags") <(reg --username="$REGISTRY_USER" --password="$REGISTRY_PASSWORD" --registry="$REGISTRY_URL" tags "$REGISTRY_REPO/$module/$image" | sort) 2> >(while IFS='' read line ; do echo -e "\e[01;31m$line\e[0m" >&2; done))

    # Пропускаем, если нечего чистить
    if [[ -z "${local_waste_tags}${remote_waste_tags}" ]] ; then
      continue
    fi

    # Красиво печатаем информацию о модуле
    if [[ $module != $previous_module ]] ; then
      if [[ -n $previous_module ]] ; then
        echo
      fi

      echo -e "\e[1;4m\e[93mCleaning images for $module\e[0m"
      previous_module=$module
    else
      echo
    fi

    # Печатаем информацию об образе
    echo -e "  \e[1m\e[33mCleaning $image\e[0m"

    # Производим локальную очистку
    if [[ -n "${local_waste_tags}" ]] ; then
      echo -e "    \e[1m\e[33mLocal docker\e[0m"
      set +e
      (
        for tag in $local_waste_tags ; do
          docker image rm $REGISTRY/$module/$image:$tag
        done
      ) 2> >(while IFS='' read line ; do echo -e "\e[01;31m      $line\e[0m" >&2; done) 1> >(while IFS='' read line ; do echo -e "\e[94m      $line\e[0m"; done)

      # Обрабатываем результат
      if [[ $? -eq 0 ]] ; then
        sleep 0.1
        echo -e "    \e[1m\e[32mDONE\e[0m"
      else
        sleep 0.1
        echo -e "    \e[01;31mFAILED\e[0m"
        exit 1
      fi
      set -e
    fi

    # Производим очистку registry
    #
    # Важно! Если несколько тегов ссылаются на один образ (образ с одним
    # digest'ом), то при удалении любого из таких тегов вместе с ним удаляется
    # и образ и все ссылающиеся на него теги.
    #   * Поведение одинаковое и при нажатии кнопки в интерфейсе Gitlab, и при
    #     использовании утилиты reg и руками через API registry.
    #   * У нас новый тег — это всегда новая контрольная сумма директории с
    #     Dockerfile'ом, и скорей всего изменение любого файла в этой
    #     директории приводит к созданию нового образа. По-другому может быть
    #     только в ситуации, если файл лежащий в директории с образом никак не
    #     используется, что странно.
    # Ну и так-как поведение везде одинаковое и так-как вероятность совпадания
    # образов у нас у разных тегов не большая, решил не разбираться, а воткнуть
    # костыль — после очистки каждого образа делается docker push всего, что
    # есть локально.
    #
    if [[ -n "${remote_waste_tags}" ]] ; then
      echo -e "    \e[1m\e[33mRemote registry\e[0m"
      set +e
      (
        set -e

        echo "Removing tags:"
        for tag in $remote_waste_tags ; do
          if reg --username="$REGISTRY_USER" --password="$REGISTRY_PASSWORD" --registry="$REGISTRY_URL" tags "$REGISTRY_REPO/$module/$image" | grep '^'$tag'$' > /dev/null ; then
            reg --username="$REGISTRY_USER" --password="$REGISTRY_PASSWORD" --registry="$REGISTRY_URL" rm "$REGISTRY_REPO/$module/$image:$tag" | sed 's/^/  /g'
          else
            echo "  Skipping $tag, image already removed"
          fi
        done

        echo
        echo "Repushing $REGISTRY/$module/$image"
        docker push $REGISTRY/$module/$image | sed 's/^/  /g'
      ) 2> >(while IFS='' read line ; do echo -e "\e[01;31m      $line\e[0m" >&2; done) 1> >(while IFS='' read line ; do echo -e "\e[94m      $line\e[0m"; done)

      # Обрабатываем результат
      if [[ $? -eq 0 ]] ; then
        sleep 0.1
        echo -e "    \e[1m\e[32mDONE\e[0m"
      else
        sleep 0.1
        echo -e "    \e[01;31mFAILED\e[0m"
        exit 1
      fi
      set -e
    fi
  done
}

! read -rd '' HELP_STRING <<"EOF"
Usage: modules_images SUBCOMMAND [SUBCOMMAND OPTIONS]...

Available subcommands: (for details, modules_images SUBCOMMAND --help)

modules_images bp
modules_images cleanup
EOF

if [[ $# -eq 0 ]] ; then
  echo "$HELP_STRING"
  exit 1
fi

SUBCOMMAND=$1
shift

case "$SUBCOMMAND" in
  bp )
    bp $@ ;;
  cleanup )
    cleanup $@ ;;
  * )
    echo "$HELP_STRING"; exit 1 ;;
esac
